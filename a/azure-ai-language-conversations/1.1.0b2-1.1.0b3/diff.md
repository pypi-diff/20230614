# Comparing `tmp/azure-ai-language-conversations-1.1.0b2.zip` & `tmp/azure-ai-language-conversations-1.1.0b3.zip`

## zipinfo {}

```diff
@@ -1,117 +1,122 @@
-Zip file size: 205232 bytes, number of entries: 115
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/samples/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/tests/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/doc/
--rw-rw-r--  2.0 unx       38 b- defN 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/setup.cfg
--rw-rw-r--  2.0 unx     1777 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/CHANGELOG.md
--rw-rw-r--  2.0 unx      322 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/MANIFEST.in
--rw-rw-r--  2.0 unx    26940 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/README.md
--rw-rw-r--  2.0 unx     1073 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/LICENSE
--rw-rw-r--  2.0 unx    34842 b- defN 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/PKG-INFO
--rw-rw-r--  2.0 unx     2936 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/setup.py
--rw-rw-r--  2.0 unx        1 b- defN 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx        6 b- defN 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/top_level.txt
--rw-rw-r--  2.0 unx     4400 b- defN 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx       48 b- defN 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/requires.txt
--rw-rw-r--  2.0 unx        1 b- defN 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx    34842 b- defN 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/PKG-INFO
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/samples/async/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/samples/authoring/
--rw-rw-r--  2.0 unx     3427 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_qna_response.py
--rw-rw-r--  2.0 unx     5265 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/sample_conv_pii_transcript_input.py
--rw-rw-r--  2.0 unx     3874 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_conversation_app.py
--rw-rw-r--  2.0 unx     4151 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/sample_conv_summarization.py
--rw-rw-r--  2.0 unx     7282 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/README.md
--rw-rw-r--  2.0 unx     3487 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_luis_response.py
--rw-rw-r--  2.0 unx     2367 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/sample_authentication.py
--rw-rw-r--  2.0 unx     3795 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_direct_target.py
--rw-rw-r--  2.0 unx     4672 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_conv_response.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/samples/async/authoring/
--rw-rw-r--  2.0 unx     4032 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_conversation_app_async.py
--rw-rw-r--  2.0 unx     3955 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_direct_target_async.py
--rw-rw-r--  2.0 unx     4316 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/sample_conv_summarization_async.py
--rw-rw-r--  2.0 unx     2545 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/sample_authentication_async.py
--rw-rw-r--  2.0 unx     4831 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_conv_response_async.py
--rw-rw-r--  2.0 unx     5431 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/sample_conv_pii_transcript_input_async.py
--rw-rw-r--  2.0 unx     3646 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_luis_response_async.py
--rw-rw-r--  2.0 unx     3586 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_qna_response_async.py
--rw-rw-r--  2.0 unx     4009 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/async/authoring/sample_import_train_deploy_project_async.py
--rw-rw-r--  2.0 unx     3806 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/samples/authoring/sample_import_train_deploy_project.py
--rw-rw-r--  2.0 unx     4305 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_conv_pii_transcript_input_async.py
--rw-rw-r--  2.0 unx      983 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_authoring.py
--rw-rw-r--  2.0 unx     4926 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_conversation_app.py
--rw-rw-r--  2.0 unx     3109 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_conv_response_async.py
--rw-rw-r--  2.0 unx     2556 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_qna_response.py
--rw-rw-r--  2.0 unx      840 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_authoring_async.py
--rw-rw-r--  2.0 unx     3496 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_conv_summarization_async.py
--rw-rw-r--  2.0 unx     2829 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_luis_response.py
--rw-rw-r--  2.0 unx     3439 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_conv_summarization.py
--rw-rw-r--  2.0 unx     5001 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_conversation_app_async.py
--rw-rw-r--  2.0 unx     3063 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_conv_response.py
--rw-rw-r--  2.0 unx     2886 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_luis_response_async.py
--rw-rw-r--  2.0 unx     4248 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_conv_pii_transcript_input.py
--rw-rw-r--  2.0 unx     2604 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_qna_response_async.py
--rw-rw-r--  2.0 unx     4168 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/testcase.py
--rw-rw-r--  2.0 unx      974 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/tests/asynctestcase.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/
--rw-rw-r--  2.0 unx       80 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/
--rw-rw-r--  2.0 unx       80 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/
--rw-rw-r--  2.0 unx       80 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/
--rw-rw-r--  2.0 unx    77452 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_serialization.py
--rw-rw-r--  2.0 unx      488 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_version.py
--rw-rw-r--  2.0 unx      904 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/__init__.py
--rw-rw-r--  2.0 unx       26 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/py.typed
--rw-rw-r--  2.0 unx     3532 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_configuration.py
--rw-rw-r--  2.0 unx     4596 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_client.py
--rw-rw-r--  2.0 unx     4594 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_patch.py
--rw-rw-r--  2.0 unx      986 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_vendor.py
--rw-rw-r--  2.0 unx      838 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/__init__.py
--rw-rw-r--  2.0 unx    34788 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/_operations.py
--rw-rw-r--  2.0 unx    17134 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/
--rw-rw-r--  2.0 unx    77452 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_serialization.py
--rw-rw-r--  2.0 unx      488 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_version.py
--rw-rw-r--  2.0 unx      906 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/__init__.py
--rw-rw-r--  2.0 unx       26 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/py.typed
--rw-rw-r--  2.0 unx     3535 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_configuration.py
--rw-rw-r--  2.0 unx     4379 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_client.py
--rw-rw-r--  2.0 unx     3524 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_patch.py
--rw-rw-r--  2.0 unx     1379 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_vendor.py
--rw-rw-r--  2.0 unx      840 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/__init__.py
--rw-rw-r--  2.0 unx   258681 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/_operations.py
--rw-rw-r--  2.0 unx   100913 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/
--rw-rw-r--  2.0 unx      853 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/__init__.py
--rw-rw-r--  2.0 unx     3534 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_configuration.py
--rw-rw-r--  2.0 unx     4447 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_client.py
--rw-rw-r--  2.0 unx     3599 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_patch.py
--rw-rw-r--  2.0 unx      999 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_vendor.py
--rw-rw-r--  2.0 unx      840 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/__init__.py
--rw-rw-r--  2.0 unx   228957 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/_operations.py
--rw-rw-r--  2.0 unx   100929 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Jul-01 18:08 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/
--rw-rw-r--  2.0 unx      851 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/__init__.py
--rw-rw-r--  2.0 unx     3531 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_configuration.py
--rw-rw-r--  2.0 unx     4664 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_client.py
--rw-rw-r--  2.0 unx     4669 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_patch.py
--rw-rw-r--  2.0 unx      997 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_vendor.py
--rw-rw-r--  2.0 unx      838 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/__init__.py
--rw-rw-r--  2.0 unx    33119 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/_operations.py
--rw-rw-r--  2.0 unx    17150 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/_patch.py
--rw-rw-r--  2.0 unx      205 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.conversations.aio.rst
--rw-rw-r--  2.0 unx      244 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.rst
--rw-rw-r--  2.0 unx      333 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.conversations.rst
--rw-rw-r--  2.0 unx      174 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/doc/azure.rst
--rw-rw-r--  2.0 unx      322 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.conversations.authoring.rst
--rw-rw-r--  2.0 unx      204 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/doc/azure.ai.rst
--rw-rw-r--  2.0 unx      226 b- defN 22-Jul-01 18:07 azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.conversations.authoring.aio.rst
-115 files, 1244516 bytes uncompressed, 177606 bytes compressed:  85.7%
+Zip file size: 209386 bytes, number of entries: 120
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/tests/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/samples/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/doc/
+-rw-rw-r--  2.0 unx     2717 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/CHANGELOG.md
+-rw-rw-r--  2.0 unx     1073 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/LICENSE
+-rw-rw-r--  2.0 unx       38 b- defN 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/setup.cfg
+-rw-rw-r--  2.0 unx    33481 b- defN 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/PKG-INFO
+-rw-rw-r--  2.0 unx      322 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/MANIFEST.in
+-rw-rw-r--  2.0 unx    29727 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/README.md
+-rw-rw-r--  2.0 unx     2997 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/setup.py
+-rw-rw-r--  2.0 unx     4251 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_conv_pii_transcript_input_async.py
+-rw-rw-r--  2.0 unx     2817 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_conv_sentiment.py
+-rw-rw-r--  2.0 unx     2731 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_luis_response.py
+-rw-rw-r--  2.0 unx     2942 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_conv_response.py
+-rw-rw-r--  2.0 unx     1316 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_authoring_async.py
+-rw-rw-r--  2.0 unx     2575 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/conftest.py
+-rw-rw-r--  2.0 unx     4954 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_conversation_app_async.py
+-rw-rw-r--  2.0 unx     8241 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_conv_summarization_async.py
+-rw-rw-r--  2.0 unx     3008 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_conv_response_async.py
+-rw-rw-r--  2.0 unx     2783 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_luis_response_async.py
+-rw-rw-r--  2.0 unx     2522 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_qna_response_async.py
+-rw-rw-r--  2.0 unx     2454 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_qna_response.py
+-rw-rw-r--  2.0 unx     2875 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_conv_sentiment_async.py
+-rw-rw-r--  2.0 unx     4178 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_conv_pii_transcript_input.py
+-rw-rw-r--  2.0 unx     4844 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_conversation_app.py
+-rw-rw-r--  2.0 unx     1241 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_authoring.py
+-rw-rw-r--  2.0 unx     8133 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/tests/test_conv_summarization.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/samples/async/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/samples/authoring/
+-rw-rw-r--  2.0 unx     3740 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_direct_target.py
+-rw-rw-r--  2.0 unx     3371 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_qna_response.py
+-rw-rw-r--  2.0 unx     3770 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_conversation_app.py
+-rw-rw-r--  2.0 unx     4610 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_conv_summarization.py
+-rw-rw-r--  2.0 unx     9032 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/README.md
+-rw-rw-r--  2.0 unx     5211 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_conv_pii_transcript_input.py
+-rw-rw-r--  2.0 unx     4544 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_conv_response.py
+-rw-rw-r--  2.0 unx     4745 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_conv_sentiment.py
+-rw-rw-r--  2.0 unx     3431 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_luis_response.py
+-rw-rw-r--  2.0 unx     2367 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/sample_authentication.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/samples/async/authoring/
+-rw-rw-r--  2.0 unx     4862 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_conv_sentiment_async.py
+-rw-rw-r--  2.0 unx     4727 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_conv_summarization_async.py
+-rw-rw-r--  2.0 unx     3852 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_direct_target_async.py
+-rw-rw-r--  2.0 unx     3881 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_conversation_app_async.py
+-rw-rw-r--  2.0 unx     5328 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_conv_pii_transcript_input_async.py
+-rw-rw-r--  2.0 unx     3483 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_qna_response_async.py
+-rw-rw-r--  2.0 unx     2497 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_authentication_async.py
+-rw-rw-r--  2.0 unx     4656 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_conv_response_async.py
+-rw-rw-r--  2.0 unx     3543 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_luis_response_async.py
+-rw-rw-r--  2.0 unx     4230 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/authoring/sample_assign_deployment_resources_async.py
+-rw-rw-r--  2.0 unx     5456 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/async/authoring/sample_manage_projects_async.py
+-rw-rw-r--  2.0 unx     4982 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/authoring/sample_manage_projects.py
+-rw-rw-r--  2.0 unx     3811 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/samples/authoring/sample_assign_deployment_resources.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/
+-rw-rw-r--  2.0 unx       81 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/
+-rw-rw-r--  2.0 unx       81 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/
+-rw-rw-r--  2.0 unx       81 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/
+-rw-rw-r--  2.0 unx    77450 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_serialization.py
+-rw-rw-r--  2.0 unx     1012 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_vendor.py
+-rw-rw-r--  2.0 unx     4567 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_client.py
+-rw-rw-r--  2.0 unx     3789 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_configuration.py
+-rw-rw-r--  2.0 unx      488 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_version.py
+-rw-rw-r--  2.0 unx       26 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/py.typed
+-rw-rw-r--  2.0 unx     4812 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_patch.py
+-rw-rw-r--  2.0 unx      911 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/__init__.py
+-rw-rw-r--  2.0 unx      675 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/_patch.py
+-rw-rw-r--  2.0 unx      838 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/__init__.py
+-rw-rw-r--  2.0 unx    43787 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/
+-rw-rw-r--  2.0 unx    77450 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_serialization.py
+-rw-rw-r--  2.0 unx     1406 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_vendor.py
+-rw-rw-r--  2.0 unx     4355 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_client.py
+-rw-rw-r--  2.0 unx     3792 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_configuration.py
+-rw-rw-r--  2.0 unx      488 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_version.py
+-rw-rw-r--  2.0 unx       26 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/py.typed
+-rw-rw-r--  2.0 unx     3742 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_patch.py
+-rw-rw-r--  2.0 unx      913 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/__init__.py
+-rw-rw-r--  2.0 unx      675 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/_patch.py
+-rw-rw-r--  2.0 unx      840 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/__init__.py
+-rw-rw-r--  2.0 unx   389746 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/
+-rw-rw-r--  2.0 unx     1026 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_vendor.py
+-rw-rw-r--  2.0 unx     4423 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_client.py
+-rw-rw-r--  2.0 unx     3791 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_configuration.py
+-rw-rw-r--  2.0 unx     3833 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_patch.py
+-rw-rw-r--  2.0 unx      860 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/_patch.py
+-rw-rw-r--  2.0 unx      840 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/__init__.py
+-rw-rw-r--  2.0 unx   347480 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/
+-rw-rw-r--  2.0 unx     1023 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_vendor.py
+-rw-rw-r--  2.0 unx     4635 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_client.py
+-rw-rw-r--  2.0 unx     3788 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4903 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_patch.py
+-rw-rw-r--  2.0 unx      858 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/__init__.py
+-rw-rw-r--  2.0 unx      675 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/_patch.py
+-rw-rw-r--  2.0 unx      838 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/__init__.py
+-rw-rw-r--  2.0 unx    41832 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/_operations.py
+-rw-rw-r--  2.0 unx        6 b- defN 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx    33481 b- defN 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx     4619 b- defN 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        1 b- defN 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx       73 b- defN 22-Nov-10 18:32 azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/requires.txt
+-rw-rw-r--  2.0 unx      174 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/doc/azure.rst
+-rw-rw-r--  2.0 unx      322 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.conversations.authoring.rst
+-rw-rw-r--  2.0 unx      205 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.conversations.aio.rst
+-rw-rw-r--  2.0 unx      226 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.conversations.authoring.aio.rst
+-rw-rw-r--  2.0 unx      244 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.rst
+-rw-rw-r--  2.0 unx      333 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.conversations.rst
+-rw-rw-r--  2.0 unx      204 b- defN 22-Nov-10 18:30 azure-ai-language-conversations-1.1.0b3/doc/azure.ai.rst
+120 files, 1315748 bytes uncompressed, 180552 bytes compressed:  86.3%
```

## zipnote {}

```diff
@@ -1,346 +1,361 @@
-Filename: azure-ai-language-conversations-1.1.0b2/
+Filename: azure-ai-language-conversations-1.1.0b3/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/
+Filename: azure-ai-language-conversations-1.1.0b3/tests/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/
+Filename: azure-ai-language-conversations-1.1.0b3/samples/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/
+Filename: azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/doc/
+Filename: azure-ai-language-conversations-1.1.0b3/doc/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/setup.cfg
+Filename: azure-ai-language-conversations-1.1.0b3/CHANGELOG.md
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/CHANGELOG.md
+Filename: azure-ai-language-conversations-1.1.0b3/LICENSE
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/MANIFEST.in
+Filename: azure-ai-language-conversations-1.1.0b3/setup.cfg
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/README.md
+Filename: azure-ai-language-conversations-1.1.0b3/PKG-INFO
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/LICENSE
+Filename: azure-ai-language-conversations-1.1.0b3/MANIFEST.in
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/PKG-INFO
+Filename: azure-ai-language-conversations-1.1.0b3/README.md
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/setup.py
+Filename: azure-ai-language-conversations-1.1.0b3/setup.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/not-zip-safe
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_conv_pii_transcript_input_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/top_level.txt
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_conv_sentiment.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/SOURCES.txt
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_luis_response.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/requires.txt
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_conv_response.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/dependency_links.txt
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_authoring_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/PKG-INFO
+Filename: azure-ai-language-conversations-1.1.0b3/tests/conftest.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_conversation_app_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/authoring/
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_conv_summarization_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_qna_response.py
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_conv_response_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/sample_conv_pii_transcript_input.py
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_luis_response_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_conversation_app.py
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_qna_response_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/sample_conv_summarization.py
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_qna_response.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/README.md
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_conv_sentiment_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_luis_response.py
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_conv_pii_transcript_input.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/sample_authentication.py
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_conversation_app.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_direct_target.py
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_authoring.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_conv_response.py
+Filename: azure-ai-language-conversations-1.1.0b3/tests/test_conv_summarization.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/authoring/
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_conversation_app_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/authoring/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_direct_target_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_direct_target.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/sample_conv_summarization_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_qna_response.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/sample_authentication_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_conversation_app.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_conv_response_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_conv_summarization.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/sample_conv_pii_transcript_input_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/README.md
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_luis_response_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_conv_pii_transcript_input.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_qna_response_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_conv_response.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/async/authoring/sample_import_train_deploy_project_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_conv_sentiment.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/samples/authoring/sample_import_train_deploy_project.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_luis_response.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_conv_pii_transcript_input_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/sample_authentication.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_authoring.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/authoring/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_conversation_app.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_conv_sentiment_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_conv_response_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_conv_summarization_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_qna_response.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_direct_target_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_authoring_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_conversation_app_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_conv_summarization_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_conv_pii_transcript_input_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_luis_response.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_qna_response_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_conv_summarization.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_authentication_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_conversation_app_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_conv_response_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_conv_response.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_luis_response_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_luis_response_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/authoring/sample_assign_deployment_resources_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_conv_pii_transcript_input.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/async/authoring/sample_manage_projects_async.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_qna_response_async.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/authoring/sample_manage_projects.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/testcase.py
+Filename: azure-ai-language-conversations-1.1.0b3/samples/authoring/sample_assign_deployment_resources.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/tests/asynctestcase.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_serialization.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_serialization.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_vendor.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_version.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_client.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_configuration.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/py.typed
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_version.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_configuration.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/py.typed
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_client.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_patch.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_patch.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_vendor.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/_patch.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/_operations.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/_operations.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/_patch.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_serialization.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_serialization.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_vendor.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_version.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_client.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_configuration.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/py.typed
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_version.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_configuration.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/py.typed
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_client.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_patch.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_patch.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_vendor.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/_patch.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/_operations.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/_operations.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/_patch.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_vendor.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_client.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_configuration.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_configuration.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_client.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_patch.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_patch.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_vendor.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/_patch.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/_operations.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/_operations.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/_patch.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_vendor.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_client.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_configuration.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_configuration.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_client.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_patch.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_patch.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_vendor.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/_patch.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/__init__.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/__init__.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/_operations.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/_operations.py
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/_patch.py
+Filename: azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.conversations.aio.rst
+Filename: azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.rst
+Filename: azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.conversations.rst
+Filename: azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/doc/azure.rst
+Filename: azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.conversations.authoring.rst
+Filename: azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/requires.txt
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/doc/azure.ai.rst
+Filename: azure-ai-language-conversations-1.1.0b3/doc/azure.rst
 Comment: 
 
-Filename: azure-ai-language-conversations-1.1.0b2/doc/azure.ai.language.conversations.authoring.aio.rst
+Filename: azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.conversations.authoring.rst
+Comment: 
+
+Filename: azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.conversations.aio.rst
+Comment: 
+
+Filename: azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.conversations.authoring.aio.rst
+Comment: 
+
+Filename: azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.rst
+Comment: 
+
+Filename: azure-ai-language-conversations-1.1.0b3/doc/azure.ai.language.conversations.rst
+Comment: 
+
+Filename: azure-ai-language-conversations-1.1.0b3/doc/azure.ai.rst
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-ai-language-conversations-1.1.0b2/README.md` & `azure-ai-language-conversations-1.1.0b3/README.md`

 * *Files 2% similar despite different names*

```diff
@@ -1,41 +1,37 @@
 [![Build Status](https://dev.azure.com/azure-sdk/public/_apis/build/status/azure-sdk-for-python.client?branchName=main)](https://dev.azure.com/azure-sdk/public/_build/latest?definitionId=46?branchName=main)
 
 # Azure Conversational Language Understanding client library for Python
 Conversational Language Understanding - aka **CLU** for short - is a cloud-based conversational AI service which provides many language understanding capabilities like:
 - Conversation App: It's used in extracting intents and entities in conversations
 - Workflow app: Acts like an orchestrator to select the best candidate to analyze conversations to get best response from apps like Qna, Luis, and Conversation App
-- Conversational Summarization: Used to summarize conversations in the form of issues, and final resolutions
-- Conversational PII: Used to extract and redact personally-identifiable info (PII)
-
-[Source code][conversationallanguage_client_src] | [Package (PyPI)][conversationallanguage_pypi_package] | [API reference documentation][api_reference_documentation] | [Samples][conversationallanguage_samples] | [Product documentation][conversationallanguage_docs] | [Analysis REST API][conversationallanguage_restdocs] | [Authoring REST API][conversationallanguage_restdocs_authoring]
-
-## _Disclaimer_
-
-_Azure SDK Python packages support for Python 2.7 ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
+- Conversational Summarization: Used to analyze conversations in the form of issues/resolution, chapter title, and narrative summarizations
+- Conversational PII: Used to extract and redact personally-identifiable information (PII)
+- Conversational Sentiment Analysis: Used to analyze the sentiment of conversations
 
+[Source code][conversationallanguage_client_src] | [Package (PyPI)][conversationallanguage_pypi_package] | [API reference documentation][api_reference_documentation] | [Samples][conversationallanguage_samples] | [Product documentation][conversationallanguage_docs] | [Analysis REST API documentation][conversationanalysis_restdocs] | [Authoring REST API documentation][conversationanalysis_restdocs_authoring]
 
 ## Getting started
 
 ### Prerequisites
 
-* Python 3.6 or later is required to use this package.
+* Python 3.7 or later is required to use this package.
 * An [Azure subscription][azure_subscription]
 * An existing Azure Language Service Resource
 
 
 ### Install the package
 
 Install the Azure Conversations client library for Python with [pip][pip_link]:
 
 ```bash
 pip install azure-ai-language-conversations --pre
 ```
 
-> Note: This version of the client library defaults to the 2022-05-15-preview version of the service
+> Note: This version of the client library defaults to the 2022-10-01-preview version of the service
 
 ### Authenticate the client
 In order to interact with the CLU service, you'll need to create an instance of the [ConversationAnalysisClient][conversationanalysisclient_class] class, or [ConversationAuthoringClient][conversationauthoringclient_class] class. You will need an **endpoint**, and an **API key** to instantiate a client object. For more information regarding authenticating with Cognitive Services, see [Authenticate requests to Azure Cognitive Services][cognitive_auth].
 
 #### Get an API key
 You can get the **endpoint** and an **API key** from the Cognitive Services resource in the [Azure Portal][azure_portal].
 
@@ -90,15 +86,15 @@
 
 Set the values of the client ID, tenant ID, and client secret of the AAD application as environment variables:
 `AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_CLIENT_SECRET`
 
 Use the returned token credential to authenticate the client:
 
 ```python
-from azure.ai.textanalytics import ConversationAnalysisClient
+from azure.ai.language.conversations import ConversationAnalysisClient
 from azure.identity import DefaultAzureCredential
 
 credential = DefaultAzureCredential()
 client = ConversationAnalysisClient(endpoint="https://<my-custom-subdomain>.cognitiveservices.azure.com/", credential=credential)
 ```
 
 ## Key concepts
@@ -290,45 +286,52 @@
                         "id": "conversation1",
                         "language": "en"
                     },
                 ]
             },
             "tasks": [
                 {
-                    "taskName": "analyze 1",
+                    "taskName": "Issue task",
                     "kind": "ConversationalSummarizationTask",
                     "parameters": {
-                        "summaryAspects": ["Issue, Resolution"]
+                        "summaryAspects": ["issue"]
                     }
-                }
+                },
+                {
+                    "taskName": "Resolution task",
+                    "kind": "ConversationalSummarizationTask",
+                    "parameters": {
+                        "summaryAspects": ["resolution"]
+                    }
+                },
             ]
         }
     )
 
     # view result
     result = poller.result()
-    task_result = result["tasks"]["items"][0]
-    print("... view task status ...")
-    print("status: {}".format(task_result["status"]))
-    resolution_result = task_result["results"]
-    if resolution_result["errors"]:
-        print("... errors occured ...")
-        for error in resolution_result["errors"]:
-            print(error)
-    else:
-        conversation_result = resolution_result["conversations"][0]
-        if conversation_result["warnings"]:
-            print("... view warnings ...")
-            for warning in conversation_result["warnings"]:
-                print(warning)
+    task_results = result["tasks"]["items"]
+    for task in task_results:
+        print(f"\n{task['taskName']} status: {task['status']}")
+        task_result = task["results"]
+        if task_result["errors"]:
+            print("... errors occurred ...")
+            for error in task_result["errors"]:
+                print(error)
         else:
-            summaries = conversation_result["summaries"]
-            print("... view task result ...")
-            print("issue: {}".format(summaries[0]["text"]))
-            print("resolution: {}".format(summaries[1]["text"]))
+            conversation_result = task_result["conversations"][0]
+            if conversation_result["warnings"]:
+                print("... view warnings ...")
+                for warning in conversation_result["warnings"]:
+                    print(warning)
+            else:
+                summaries = conversation_result["summaries"]
+                print("... view task result ...")
+                for summary in summaries:
+                    print(f"{summary['aspect']}: {summary['text']}")
 ```
 
 ### Conversational PII
 
 You can use this sample if you need to extract and redact pii info from/in conversations
 
 ```python
@@ -399,15 +402,15 @@
     # view result
     result = poller.result()
     task_result = result["tasks"]["items"][0]
     print("... view task status ...")
     print("status: {}".format(task_result["status"]))
     conv_pii_result = task_result["results"]
     if conv_pii_result["errors"]:
-        print("... errors occured ...")
+        print("... errors occurred ...")
         for error in conv_pii_result["errors"]:
             print(error)
     else:
         conversation_result = conv_pii_result["conversations"][0]
         if conversation_result["warnings"]:
             print("... view warnings ...")
             for warning in conversation_result["warnings"]:
@@ -421,14 +424,88 @@
                     print("text: {}".format(entity["text"]))
                     print("category: {}".format(entity["category"]))
                     print("confidence: {}".format(entity["confidenceScore"]))
                     print("offset: {}".format(entity["offset"]))
                     print("length: {}".format(entity["length"]))
 ```
 
+
+### Conversational Sentiment Analysis
+
+Analyze sentiment in conversations.
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+# get secrets
+endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+key = os.environ["AZURE_CONVERSATIONS_KEY"]
+# analyze query
+client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
+
+with client:
+    poller = client.begin_conversation_analysis(
+        task={
+          "displayName": "Sentiment Analysis from a call center conversation",
+          "analysisInput": {
+            "conversations": [
+              {
+                "id": "1",
+                "language": "en",
+                "modality": "transcript",
+                "conversationItems": [
+                  {
+                    "participantId": "1",
+                    "id": "1",
+                    "text": "I like the service. I do not like the food",
+                    "lexical": "i like the service i do not like the food",
+                  }
+                ]
+              }
+            ]
+          },
+          "tasks": [
+            {
+              "taskName": "Conversation Sentiment Analysis",
+              "kind": "ConversationalSentimentTask",
+              "parameters": {
+                "modelVersion": "latest",
+                "predictionSource": "text"
+              }
+            }
+          ]
+        }
+    )
+
+    result = poller.result()
+    task_result = result["tasks"]["items"][0]
+    print("... view task status ...")
+    print(f"status: {task_result['status']}")
+    conv_sentiment_result = task_result["results"]
+    if conv_sentiment_result["errors"]:
+        print("... errors occurred ...")
+        for error in conv_sentiment_result["errors"]:
+            print(error)
+    else:
+        conversation_result = conv_sentiment_result["conversations"][0]
+        if conversation_result["warnings"]:
+            print("... view warnings ...")
+            for warning in conversation_result["warnings"]:
+                print(warning)
+        else:
+            print("... view task result ...")
+            for conversation in conversation_result["conversationItems"]:
+                print(f"Participant ID: {conversation['participantId']}")
+                print(f"Sentiment: {conversation['sentiment']}")
+                print(f"confidenceScores: {conversation['confidenceScores']}")
+```
+
+
 ### Import a Conversation Project
 This sample shows a common scenario for the authoring part of the SDK
 
 ```python
 import os
 from azure.core.credentials import AzureKeyCredential
 from azure.ai.language.conversations.authoring import ConversationAuthoringClient
@@ -566,22 +643,23 @@
 [pip_link]:https://pypi.org/project/pip/
 [conversationallanguage_client_src]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
 [conversationallanguage_pypi_package]: https://pypi.org/project/azure-ai-language-conversations/
 [api_reference_documentation]:https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html
 [conversationallanguage_refdocs]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
 [conversationallanguage_docs]: https://docs.microsoft.com/azure/cognitive-services/language-service/conversational-language-understanding/overview
 [conversationallanguage_samples]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/README.md
-[conversationallanguage_restdocs]: https://docs.microsoft.com/rest/api/language/conversation-analysis-runtime/
-[conversationallanguage_restdocs_authoring]: https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring
+[conversationallanguage_restdocs]: https://learn.microsoft.com/rest/api/language/
 [conversationanalysisclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAnalysisClient
 [conversationauthoringclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAuthoringClient
 [azure_core_exceptions]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
 [azure_language_portal]: https://language.cognitive.azure.com/home
 [cognitive_authentication_aad]: https://docs.microsoft.com/azure/cognitive-services/authentication#authenticate-with-azure-active-directory
 [azure_identity_credentials]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#credentials
 [custom_subdomain]: https://docs.microsoft.com/azure/cognitive-services/authentication#create-a-resource-with-a-custom-subdomain
 [install_azure_identity]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#install-the-package
 [register_aad_app]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
 [grant_role_access]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
 [default_azure_credential]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#defaultazurecredential
+[conversationanalysis_restdocs]: https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime
+[conversationanalysis_restdocs_authoring]: https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Ftemplate%2Fazure-template%2FREADME.png)
```

## Comparing `azure-ai-language-conversations-1.1.0b2/LICENSE` & `azure-ai-language-conversations-1.1.0b3/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-ai-language-conversations-1.1.0b2/PKG-INFO` & `azure-ai-language-conversations-1.1.0b3/PKG-INFO`

 * *Files 12% similar despite different names*

```diff
@@ -1,659 +1,758 @@
 Metadata-Version: 2.1
 Name: azure-ai-language-conversations
-Version: 1.1.0b2
+Version: 1.1.0b3
 Summary: Microsoft Azure Conversational Language Understanding Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Project-URL: Bug Reports, https://github.com/Azure/azure-sdk-for-python/issues
 Project-URL: Source, https://github.com/Azure/azure-sdk-python
-Description: [![Build Status](https://dev.azure.com/azure-sdk/public/_apis/build/status/azure-sdk-for-python.client?branchName=main)](https://dev.azure.com/azure-sdk/public/_build/latest?definitionId=46?branchName=main)
-        
-        # Azure Conversational Language Understanding client library for Python
-        Conversational Language Understanding - aka **CLU** for short - is a cloud-based conversational AI service which provides many language understanding capabilities like:
-        - Conversation App: It's used in extracting intents and entities in conversations
-        - Workflow app: Acts like an orchestrator to select the best candidate to analyze conversations to get best response from apps like Qna, Luis, and Conversation App
-        - Conversational Summarization: Used to summarize conversations in the form of issues, and final resolutions
-        - Conversational PII: Used to extract and redact personally-identifiable info (PII)
-        
-        [Source code][conversationallanguage_client_src] | [Package (PyPI)][conversationallanguage_pypi_package] | [API reference documentation][api_reference_documentation] | [Samples][conversationallanguage_samples] | [Product documentation][conversationallanguage_docs] | [Analysis REST API][conversationallanguage_restdocs] | [Authoring REST API][conversationallanguage_restdocs_authoring]
-        
-        ## _Disclaimer_
-        
-        _Azure SDK Python packages support for Python 2.7 ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
-        
-        
-        ## Getting started
-        
-        ### Prerequisites
-        
-        * Python 3.6 or later is required to use this package.
-        * An [Azure subscription][azure_subscription]
-        * An existing Azure Language Service Resource
-        
-        
-        ### Install the package
-        
-        Install the Azure Conversations client library for Python with [pip][pip_link]:
-        
-        ```bash
-        pip install azure-ai-language-conversations --pre
-        ```
-        
-        > Note: This version of the client library defaults to the 2022-05-15-preview version of the service
-        
-        ### Authenticate the client
-        In order to interact with the CLU service, you'll need to create an instance of the [ConversationAnalysisClient][conversationanalysisclient_class] class, or [ConversationAuthoringClient][conversationauthoringclient_class] class. You will need an **endpoint**, and an **API key** to instantiate a client object. For more information regarding authenticating with Cognitive Services, see [Authenticate requests to Azure Cognitive Services][cognitive_auth].
-        
-        #### Get an API key
-        You can get the **endpoint** and an **API key** from the Cognitive Services resource in the [Azure Portal][azure_portal].
-        
-        Alternatively, use the [Azure CLI][azure_cli] command shown below to get the API key from the Cognitive Service resource.
-        
-        ```powershell
-        az cognitiveservices account keys list --resource-group <resource-group-name> --name <resource-name>
-        ```
-        
-        
-        #### Create ConversationAnalysisClient
-        Once you've determined your **endpoint** and **API key** you can instantiate a `ConversationAnalysisClient`:
-        
-        ```python
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        
-        endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
-        credential = AzureKeyCredential("<api-key>")
-        client = ConversationAnalysisClient(endpoint, credential)
-        ```
-        
-        #### Create ConversationAuthoringClient
-        Once you've determined your **endpoint** and **API key** you can instantiate a `ConversationAuthoringClient`:
-        
-        ```python
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations.authoring import ConversationAuthoringClient
-        
-        endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
-        credential = AzureKeyCredential("<api-key>")
-        client = ConversationAuthoringClient(endpoint, credential)
-        ```
-        
-        #### Create a client with an Azure Active Directory Credential
-        
-        To use an [Azure Active Directory (AAD) token credential][cognitive_authentication_aad],
-        provide an instance of the desired credential type obtained from the
-        [azure-identity][azure_identity_credentials] library.
-        Note that regional endpoints do not support AAD authentication. Create a [custom subdomain][custom_subdomain]
-        name for your resource in order to use this type of authentication.
-        
-        Authentication with AAD requires some initial setup:
-        
-        - [Install azure-identity][install_azure_identity]
-        - [Register a new AAD application][register_aad_app]
-        - [Grant access][grant_role_access] to the Language service by assigning the "Cognitive Services Language Reader" role to your service principal.
-        
-        After setup, you can choose which type of [credential][azure_identity_credentials] from azure.identity to use.
-        As an example, [DefaultAzureCredential][default_azure_credential]
-        can be used to authenticate the client:
-        
-        Set the values of the client ID, tenant ID, and client secret of the AAD application as environment variables:
-        `AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_CLIENT_SECRET`
-        
-        Use the returned token credential to authenticate the client:
-        
-        ```python
-        from azure.ai.textanalytics import ConversationAnalysisClient
-        from azure.identity import DefaultAzureCredential
-        
-        credential = DefaultAzureCredential()
-        client = ConversationAnalysisClient(endpoint="https://<my-custom-subdomain>.cognitiveservices.azure.com/", credential=credential)
-        ```
-        
-        ## Key concepts
-        
-        ### ConversationAnalysisClient
-        The [ConversationAnalysisClient][conversationanalysisclient_class] is the primary interface for making predictions using your deployed Conversations models. For asynchronous operations, an async `ConversationAnalysisClient` is in the `azure.ai.language.conversation.aio` namespace.
-        
-        ### ConversationAuthoringClient
-        You can use the [ConversationAuthoringClient][conversationauthoringclient_class] to interface with the [Azure Language Portal][azure_language_portal] to carry out authoring operations on your language resource/project. For example, you can use it to create a project, populate with training data, train, test, and deploy. For asynchronous operations, an async `ConversationAuthoringClient` is in the `azure.ai.language.conversation.authoring.aio` namespace.
-        
-        ## Examples
-        The `azure-ai-language-conversation` client library provides both synchronous and asynchronous APIs.
-        
-        The following examples show common scenarios using the `client` [created above](#create-conversationanalysisclient).
-        
-        ### Analyze Text with a Conversation App
-        If you would like to extract custom intents and entities from a user utterance, you can call the `client.analyze_conversation()` method with your conversation's project name as follows:
-        
-        
-        ```python
-        # import libraries
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        
-        # get secrets
-        clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        project_name = os.environ["AZURE_CONVERSATIONS_PROJECT_NAME"]
-        deployment_name = os.environ["AZURE_CONVERSATIONS_DEPLOYMENT_NAME"]
-        
-        # analyze quey
-        client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
-        with client:
-            query = "Send an email to Carol about the tomorrow's demo"
-            result = client.analyze_conversation(
-                task={
-                    "kind": "Conversation",
-                    "analysisInput": {
-                        "conversationItem": {
-                            "participantId": "1",
-                            "id": "1",
-                            "modality": "text",
-                            "language": "en",
-                            "text": query
-                        },
-                        "isLoggingEnabled": False
+Classifier: Development Status :: 4 - Beta
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: License :: OSI Approved :: MIT License
+Requires-Python: >=3.7
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+[![Build Status](https://dev.azure.com/azure-sdk/public/_apis/build/status/azure-sdk-for-python.client?branchName=main)](https://dev.azure.com/azure-sdk/public/_build/latest?definitionId=46?branchName=main)
+
+# Azure Conversational Language Understanding client library for Python
+Conversational Language Understanding - aka **CLU** for short - is a cloud-based conversational AI service which provides many language understanding capabilities like:
+- Conversation App: It's used in extracting intents and entities in conversations
+- Workflow app: Acts like an orchestrator to select the best candidate to analyze conversations to get best response from apps like Qna, Luis, and Conversation App
+- Conversational Summarization: Used to analyze conversations in the form of issues/resolution, chapter title, and narrative summarizations
+- Conversational PII: Used to extract and redact personally-identifiable information (PII)
+- Conversational Sentiment Analysis: Used to analyze the sentiment of conversations
+
+[Source code][conversationallanguage_client_src] | [Package (PyPI)][conversationallanguage_pypi_package] | [API reference documentation][api_reference_documentation] | [Samples][conversationallanguage_samples] | [Product documentation][conversationallanguage_docs] | [Analysis REST API documentation][conversationanalysis_restdocs] | [Authoring REST API documentation][conversationanalysis_restdocs_authoring]
+
+## Getting started
+
+### Prerequisites
+
+* Python 3.7 or later is required to use this package.
+* An [Azure subscription][azure_subscription]
+* An existing Azure Language Service Resource
+
+
+### Install the package
+
+Install the Azure Conversations client library for Python with [pip][pip_link]:
+
+```bash
+pip install azure-ai-language-conversations --pre
+```
+
+> Note: This version of the client library defaults to the 2022-10-01-preview version of the service
+
+### Authenticate the client
+In order to interact with the CLU service, you'll need to create an instance of the [ConversationAnalysisClient][conversationanalysisclient_class] class, or [ConversationAuthoringClient][conversationauthoringclient_class] class. You will need an **endpoint**, and an **API key** to instantiate a client object. For more information regarding authenticating with Cognitive Services, see [Authenticate requests to Azure Cognitive Services][cognitive_auth].
+
+#### Get an API key
+You can get the **endpoint** and an **API key** from the Cognitive Services resource in the [Azure Portal][azure_portal].
+
+Alternatively, use the [Azure CLI][azure_cli] command shown below to get the API key from the Cognitive Service resource.
+
+```powershell
+az cognitiveservices account keys list --resource-group <resource-group-name> --name <resource-name>
+```
+
+
+#### Create ConversationAnalysisClient
+Once you've determined your **endpoint** and **API key** you can instantiate a `ConversationAnalysisClient`:
+
+```python
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+
+endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
+credential = AzureKeyCredential("<api-key>")
+client = ConversationAnalysisClient(endpoint, credential)
+```
+
+#### Create ConversationAuthoringClient
+Once you've determined your **endpoint** and **API key** you can instantiate a `ConversationAuthoringClient`:
+
+```python
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations.authoring import ConversationAuthoringClient
+
+endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
+credential = AzureKeyCredential("<api-key>")
+client = ConversationAuthoringClient(endpoint, credential)
+```
+
+#### Create a client with an Azure Active Directory Credential
+
+To use an [Azure Active Directory (AAD) token credential][cognitive_authentication_aad],
+provide an instance of the desired credential type obtained from the
+[azure-identity][azure_identity_credentials] library.
+Note that regional endpoints do not support AAD authentication. Create a [custom subdomain][custom_subdomain]
+name for your resource in order to use this type of authentication.
+
+Authentication with AAD requires some initial setup:
+
+- [Install azure-identity][install_azure_identity]
+- [Register a new AAD application][register_aad_app]
+- [Grant access][grant_role_access] to the Language service by assigning the "Cognitive Services Language Reader" role to your service principal.
+
+After setup, you can choose which type of [credential][azure_identity_credentials] from azure.identity to use.
+As an example, [DefaultAzureCredential][default_azure_credential]
+can be used to authenticate the client:
+
+Set the values of the client ID, tenant ID, and client secret of the AAD application as environment variables:
+`AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_CLIENT_SECRET`
+
+Use the returned token credential to authenticate the client:
+
+```python
+from azure.ai.language.conversations import ConversationAnalysisClient
+from azure.identity import DefaultAzureCredential
+
+credential = DefaultAzureCredential()
+client = ConversationAnalysisClient(endpoint="https://<my-custom-subdomain>.cognitiveservices.azure.com/", credential=credential)
+```
+
+## Key concepts
+
+### ConversationAnalysisClient
+The [ConversationAnalysisClient][conversationanalysisclient_class] is the primary interface for making predictions using your deployed Conversations models. For asynchronous operations, an async `ConversationAnalysisClient` is in the `azure.ai.language.conversation.aio` namespace.
+
+### ConversationAuthoringClient
+You can use the [ConversationAuthoringClient][conversationauthoringclient_class] to interface with the [Azure Language Portal][azure_language_portal] to carry out authoring operations on your language resource/project. For example, you can use it to create a project, populate with training data, train, test, and deploy. For asynchronous operations, an async `ConversationAuthoringClient` is in the `azure.ai.language.conversation.authoring.aio` namespace.
+
+## Examples
+The `azure-ai-language-conversation` client library provides both synchronous and asynchronous APIs.
+
+The following examples show common scenarios using the `client` [created above](#create-conversationanalysisclient).
+
+### Analyze Text with a Conversation App
+If you would like to extract custom intents and entities from a user utterance, you can call the `client.analyze_conversation()` method with your conversation's project name as follows:
+
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+
+# get secrets
+clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+project_name = os.environ["AZURE_CONVERSATIONS_PROJECT_NAME"]
+deployment_name = os.environ["AZURE_CONVERSATIONS_DEPLOYMENT_NAME"]
+
+# analyze quey
+client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
+with client:
+    query = "Send an email to Carol about the tomorrow's demo"
+    result = client.analyze_conversation(
+        task={
+            "kind": "Conversation",
+            "analysisInput": {
+                "conversationItem": {
+                    "participantId": "1",
+                    "id": "1",
+                    "modality": "text",
+                    "language": "en",
+                    "text": query
+                },
+                "isLoggingEnabled": False
+            },
+            "parameters": {
+                "projectName": project_name,
+                "deploymentName": deployment_name,
+                "verbose": True
+            }
+        }
+    )
+
+# view result
+print("query: {}".format(result["result"]["query"]))
+print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+
+print("top intent: {}".format(result["result"]["prediction"]["topIntent"]))
+print("category: {}".format(result["result"]["prediction"]["intents"][0]["category"]))
+print("confidence score: {}\n".format(result["result"]["prediction"]["intents"][0]["confidenceScore"]))
+
+print("entities:")
+for entity in result["result"]["prediction"]["entities"]:
+    print("\ncategory: {}".format(entity["category"]))
+    print("text: {}".format(entity["text"]))
+    print("confidence score: {}".format(entity["confidenceScore"]))
+    if "resolutions" in entity:
+        print("resolutions")
+        for resolution in entity["resolutions"]:
+            print("kind: {}".format(resolution["resolutionKind"]))
+            print("value: {}".format(resolution["value"]))
+    if "extraInformation" in entity:
+        print("extra info")
+        for data in entity["extraInformation"]:
+            print("kind: {}".format(data["extraInformationKind"]))
+            if data["extraInformationKind"] == "ListKey":
+                print("key: {}".format(data["key"]))
+            if data["extraInformationKind"] == "EntitySubtype":
+                print("value: {}".format(data["value"]))
+```
+
+### Analyze Text with an Orchestration App
+
+If you would like to pass the user utterance to your orchestrator (worflow) app, you can call the `client.analyze_conversation()` method with your orchestration's project name. The orchestrator project simply orchestrates the submitted user utterance between your language apps (Luis, Conversation, and Question Answering) to get the best response according to the user intent. See the next example:
+
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+
+# get secrets
+clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+project_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME"]
+deployment_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME"]
+
+# analyze query
+client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
+with client:
+    query = "Reserve a table for 2 at the Italian restaurant"
+    result = client.analyze_conversation(
+        task={
+            "kind": "Conversation",
+            "analysisInput": {
+                "conversationItem": {
+                    "participantId": "1",
+                    "id": "1",
+                    "modality": "text",
+                    "language": "en",
+                    "text": query
+                },
+                "isLoggingEnabled": False
+            },
+            "parameters": {
+                "projectName": project_name,
+                "deploymentName": deployment_name,
+                "verbose": True
+            }
+        }
+    )
+
+# view result
+print("query: {}".format(result["result"]["query"]))
+print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+
+# top intent
+top_intent = result["result"]["prediction"]["topIntent"]
+print("top intent: {}".format(top_intent))
+top_intent_object = result["result"]["prediction"]["intents"][top_intent]
+print("confidence score: {}".format(top_intent_object["confidenceScore"]))
+print("project kind: {}".format(top_intent_object["targetProjectKind"]))
+
+if top_intent_object["targetProjectKind"] == "Luis":
+    print("\nluis response:")
+    luis_response = top_intent_object["result"]["prediction"]
+    print("top intent: {}".format(luis_response["topIntent"]))
+    print("\nentities:")
+    for entity in luis_response["entities"]:
+        print("\n{}".format(entity))
+```
+
+### Conversational Summarization
+
+You can use this sample if you need to summarize a conversation in the form of an issue, and final resolution. For example, a dialog from tech support:
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+# get secrets
+endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+key = os.environ["AZURE_CONVERSATIONS_KEY"]
+# analyze query
+client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
+with client:
+    poller = client.begin_conversation_analysis(
+        task={
+            "displayName": "Analyze conversations from xxx",
+            "analysisInput": {
+                "conversations": [
+                    {
+                        "conversationItems": [
+                            {
+                                "text": "Hello, how can I help you?",
+                                "modality": "text",
+                                "id": "1",
+                                "participantId": "Agent"
+                            },
+                            {
+                                "text": "How to upgrade Office? I am getting error messages the whole day.",
+                                "modality": "text",
+                                "id": "2",
+                                "participantId": "Customer"
+                            },
+                            {
+                                "text": "Press the upgrade button please. Then sign in and follow the instructions.",
+                                "modality": "text",
+                                "id": "3",
+                                "participantId": "Agent"
+                            }
+                        ],
+                        "modality": "text",
+                        "id": "conversation1",
+                        "language": "en"
                     },
+                ]
+            },
+            "tasks": [
+                {
+                    "taskName": "Issue task",
+                    "kind": "ConversationalSummarizationTask",
                     "parameters": {
-                        "projectName": project_name,
-                        "deploymentName": deployment_name,
-                        "verbose": True
+                        "summaryAspects": ["issue"]
                     }
-                }
-            )
-        
-        # view result
-        print("query: {}".format(result["result"]["query"]))
-        print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
-        
-        print("top intent: {}".format(result["result"]["prediction"]["topIntent"]))
-        print("category: {}".format(result["result"]["prediction"]["intents"][0]["category"]))
-        print("confidence score: {}\n".format(result["result"]["prediction"]["intents"][0]["confidenceScore"]))
-        
-        print("entities:")
-        for entity in result["result"]["prediction"]["entities"]:
-            print("\ncategory: {}".format(entity["category"]))
-            print("text: {}".format(entity["text"]))
-            print("confidence score: {}".format(entity["confidenceScore"]))
-            if "resolutions" in entity:
-                print("resolutions")
-                for resolution in entity["resolutions"]:
-                    print("kind: {}".format(resolution["resolutionKind"]))
-                    print("value: {}".format(resolution["value"]))
-            if "extraInformation" in entity:
-                print("extra info")
-                for data in entity["extraInformation"]:
-                    print("kind: {}".format(data["extraInformationKind"]))
-                    if data["extraInformationKind"] == "ListKey":
-                        print("key: {}".format(data["key"]))
-                    if data["extraInformationKind"] == "EntitySubtype":
-                        print("value: {}".format(data["value"]))
-        ```
-        
-        ### Analyze Text with an Orchestration App
-        
-        If you would like to pass the user utterance to your orchestrator (worflow) app, you can call the `client.analyze_conversation()` method with your orchestration's project name. The orchestrator project simply orchestrates the submitted user utterance between your language apps (Luis, Conversation, and Question Answering) to get the best response according to the user intent. See the next example:
-        
-        
-        ```python
-        # import libraries
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        
-        # get secrets
-        clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        project_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME"]
-        deployment_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME"]
-        
-        # analyze query
-        client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
-        with client:
-            query = "Reserve a table for 2 at the Italian restaurant"
-            result = client.analyze_conversation(
-                task={
-                    "kind": "Conversation",
-                    "analysisInput": {
-                        "conversationItem": {
-                            "participantId": "1",
-                            "id": "1",
-                            "modality": "text",
-                            "language": "en",
-                            "text": query
-                        },
-                        "isLoggingEnabled": False
-                    },
+                },
+                {
+                    "taskName": "Resolution task",
+                    "kind": "ConversationalSummarizationTask",
                     "parameters": {
-                        "projectName": project_name,
-                        "deploymentName": deployment_name,
-                        "verbose": True
+                        "summaryAspects": ["resolution"]
                     }
-                }
-            )
-        
-        # view result
-        print("query: {}".format(result["result"]["query"]))
-        print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
-        
-        # top intent
-        top_intent = result["result"]["prediction"]["topIntent"]
-        print("top intent: {}".format(top_intent))
-        top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-        print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-        print("project kind: {}".format(top_intent_object["targetProjectKind"]))
-        
-        if top_intent_object["targetProjectKind"] == "Luis":
-            print("\nluis response:")
-            luis_response = top_intent_object["result"]["prediction"]
-            print("top intent: {}".format(luis_response["topIntent"]))
-            print("\nentities:")
-            for entity in luis_response["entities"]:
-                print("\n{}".format(entity))
-        ```
-        
-        ### Conversational Summarization
-        
-        You can use this sample if you need to summarize a conversation in the form of an issue, and final resolution. For example, a dialog from tech support:
-        
-        ```python
-        # import libraries
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        # get secrets
-        endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
-            poller = client.begin_conversation_analysis(
-                task={
-                    "displayName": "Analyze conversations from xxx",
-                    "analysisInput": {
-                        "conversations": [
+                },
+            ]
+        }
+    )
+
+    # view result
+    result = poller.result()
+    task_results = result["tasks"]["items"]
+    for task in task_results:
+        print(f"\n{task['taskName']} status: {task['status']}")
+        task_result = task["results"]
+        if task_result["errors"]:
+            print("... errors occurred ...")
+            for error in task_result["errors"]:
+                print(error)
+        else:
+            conversation_result = task_result["conversations"][0]
+            if conversation_result["warnings"]:
+                print("... view warnings ...")
+                for warning in conversation_result["warnings"]:
+                    print(warning)
+            else:
+                summaries = conversation_result["summaries"]
+                print("... view task result ...")
+                for summary in summaries:
+                    print(f"{summary['aspect']}: {summary['text']}")
+```
+
+### Conversational PII
+
+You can use this sample if you need to extract and redact pii info from/in conversations
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+# get secrets
+endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+key = os.environ["AZURE_CONVERSATIONS_KEY"]
+# analyze query
+client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
+with client:
+    poller = client.begin_conversation_analysis(
+        task={
+            "displayName": "Analyze PII in conversation",
+            "analysisInput": {
+                "conversations": [
+                    {
+                        "conversationItems": [
                             {
-                                "conversationItems": [
-                                    {
-                                        "text": "Hello, how can I help you?",
-                                        "modality": "text",
-                                        "id": "1",
-                                        "participantId": "Agent"
-                                    },
-                                    {
-                                        "text": "How to upgrade Office? I am getting error messages the whole day.",
-                                        "modality": "text",
-                                        "id": "2",
-                                        "participantId": "Customer"
-                                    },
-                                    {
-                                        "text": "Press the upgrade button please. Then sign in and follow the instructions.",
-                                        "modality": "text",
-                                        "id": "3",
-                                        "participantId": "Agent"
-                                    }
-                                ],
-                                "modality": "text",
-                                "id": "conversation1",
-                                "language": "en"
+                                "id": "1",
+                                "participantId": "0",
+                                "modality": "transcript",
+                                "text": "It is john doe.",
+                                "lexical": "It is john doe",
+                                "itn": "It is john doe",
+                                "maskedItn": "It is john doe"
                             },
-                        ]
-                    },
-                    "tasks": [
-                        {
-                            "taskName": "analyze 1",
-                            "kind": "ConversationalSummarizationTask",
-                            "parameters": {
-                                "summaryAspects": ["Issue, Resolution"]
-                            }
-                        }
-                    ]
-                }
-            )
-        
-            # view result
-            result = poller.result()
-            task_result = result["tasks"]["items"][0]
-            print("... view task status ...")
-            print("status: {}".format(task_result["status"]))
-            resolution_result = task_result["results"]
-            if resolution_result["errors"]:
-                print("... errors occured ...")
-                for error in resolution_result["errors"]:
-                    print(error)
-            else:
-                conversation_result = resolution_result["conversations"][0]
-                if conversation_result["warnings"]:
-                    print("... view warnings ...")
-                    for warning in conversation_result["warnings"]:
-                        print(warning)
-                else:
-                    summaries = conversation_result["summaries"]
-                    print("... view task result ...")
-                    print("issue: {}".format(summaries[0]["text"]))
-                    print("resolution: {}".format(summaries[1]["text"]))
-        ```
-        
-        ### Conversational PII
-        
-        You can use this sample if you need to extract and redact pii info from/in conversations
-        
-        ```python
-        # import libraries
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        # get secrets
-        endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
-            poller = client.begin_conversation_analysis(
-                task={
-                    "displayName": "Analyze PII in conversation",
-                    "analysisInput": {
-                        "conversations": [
                             {
-                                "conversationItems": [
-                                    {
-                                        "id": "1",
-                                        "participantId": "0",
-                                        "modality": "transcript",
-                                        "text": "It is john doe.",
-                                        "lexical": "It is john doe",
-                                        "itn": "It is john doe",
-                                        "maskedItn": "It is john doe"
-                                    },
-                                    {
-                                        "id": "2",
-                                        "participantId": "1",
-                                        "modality": "transcript",
-                                        "text": "Yes, 633-27-8199 is my phone",
-                                        "lexical": "yes six three three two seven eight one nine nine is my phone",
-                                        "itn": "yes 633278199 is my phone",
-                                        "maskedItn": "yes 633278199 is my phone",
-                                    },
-                                    {
-                                        "id": "3",
-                                        "participantId": "1",
-                                        "modality": "transcript",
-                                        "text": "j.doe@yahoo.com is my email",
-                                        "lexical": "j dot doe at yahoo dot com is my email",
-                                        "maskedItn": "j.doe@yahoo.com is my email",
-                                        "itn": "j.doe@yahoo.com is my email",
-                                    }
-                                ],
+                                "id": "2",
+                                "participantId": "1",
                                 "modality": "transcript",
-                                "id": "1",
-                                "language": "en"
+                                "text": "Yes, 633-27-8199 is my phone",
+                                "lexical": "yes six three three two seven eight one nine nine is my phone",
+                                "itn": "yes 633278199 is my phone",
+                                "maskedItn": "yes 633278199 is my phone",
+                            },
+                            {
+                                "id": "3",
+                                "participantId": "1",
+                                "modality": "transcript",
+                                "text": "j.doe@yahoo.com is my email",
+                                "lexical": "j dot doe at yahoo dot com is my email",
+                                "maskedItn": "j.doe@yahoo.com is my email",
+                                "itn": "j.doe@yahoo.com is my email",
                             }
+                        ],
+                        "modality": "transcript",
+                        "id": "1",
+                        "language": "en"
+                    }
+                ]
+            },
+            "tasks": [
+                {
+                    "kind": "ConversationalPIITask",
+                    "parameters": {
+                        "redactionSource": "lexical",
+                        "piiCategories": [
+                            "all"
                         ]
-                    },
-                    "tasks": [
-                        {
-                            "kind": "ConversationalPIITask",
-                            "parameters": {
-                                "redactionSource": "lexical",
-                                "piiCategories": [
-                                    "all"
-                                ]
-                            }
-                        }
-                    ]
+                    }
                 }
-            )
-            # view result
-            result = poller.result()
-            task_result = result["tasks"]["items"][0]
-            print("... view task status ...")
-            print("status: {}".format(task_result["status"]))
-            conv_pii_result = task_result["results"]
-            if conv_pii_result["errors"]:
-                print("... errors occured ...")
-                for error in conv_pii_result["errors"]:
-                    print(error)
-            else:
-                conversation_result = conv_pii_result["conversations"][0]
-                if conversation_result["warnings"]:
-                    print("... view warnings ...")
-                    for warning in conversation_result["warnings"]:
-                        print(warning)
-                else:
-                    print("... view task result ...")
-                    for conversation in conversation_result["conversationItems"]:
-                        print("conversation id: {}".format(conversation["id"]))
-                        print("... entities ...")
-                        for entity in conversation["entities"]:
-                            print("text: {}".format(entity["text"]))
-                            print("category: {}".format(entity["category"]))
-                            print("confidence: {}".format(entity["confidenceScore"]))
-                            print("offset: {}".format(entity["offset"]))
-                            print("length: {}".format(entity["length"]))
-        ```
-        
-        ### Import a Conversation Project
-        This sample shows a common scenario for the authoring part of the SDK
-        
-        ```python
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations.authoring import ConversationAuthoringClient
-        
-        clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        
-        project_name = "test_project"
-        
-        exported_project_assets = {
-            "projectKind": "Conversation",
-            "intents": [{"category": "Read"}, {"category": "Delete"}],
-            "entities": [{"category": "Sender"}],
-            "utterances": [
-                {
-                    "text": "Open Blake's email",
-                    "dataset": "Train",
-                    "intent": "Read",
-                    "entities": [{"category": "Sender", "offset": 5, "length": 5}],
-                },
-                {
-                    "text": "Delete last email",
-                    "language": "en-gb",
-                    "dataset": "Test",
-                    "intent": "Delete",
-                    "entities": [],
-                },
-            ],
+            ]
         }
-        
-        client = ConversationAuthoringClient(
-            clu_endpoint, AzureKeyCredential(clu_key)
-        )
-        poller = client.begin_import_project(
-            project_name=project_name,
-            project={
-                "assets": exported_project_assets,
-                "metadata": {
-                    "projectKind": "Conversation",
-                    "settings": {"confidenceThreshold": 0.7},
-                    "projectName": "EmailApp",
-                    "multilingual": True,
-                    "description": "Trying out CLU",
-                    "language": "en-us",
-                },
-                "projectFileVersion": "2022-05-01",
-            },
-        )
-        response = poller.result()
-        print(response)
-        
-        ```
-        
-        
-        ## Optional Configuration
-        
-        Optional keyword arguments can be passed in at the client and per-operation level. The azure-core [reference documentation][azure_core_ref_docs] describes available configurations for retries, logging, transport protocols, and more.
-        
-        ## Troubleshooting
-        
-        ### General
-        
-        The Conversations client will raise exceptions defined in [Azure Core][azure_core_exceptions].
-        
-        ### Logging
-        
-        This library uses the standard
-        [logging][python_logging] library for logging.
-        Basic information about HTTP sessions (URLs, headers, etc.) is logged at INFO
-        level.
-        
-        Detailed DEBUG level logging, including request/response bodies and unredacted
-        headers, can be enabled on a client with the `logging_enable` argument.
-        
-        See full SDK logging documentation with examples [here][sdk_logging_docs].
-        
-        ```python
-        import sys
-        import logging
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        
-        # Create a logger for the 'azure' SDK
-        logger = logging.getLogger('azure')
-        logger.setLevel(logging.DEBUG)
-        
-        # Configure a console output
-        handler = logging.StreamHandler(stream=sys.stdout)
-        logger.addHandler(handler)
-        
-        endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
-        credential = AzureKeyCredential("<my-api-key>")
-        
-        # This client will log detailed information about its HTTP sessions, at DEBUG level
-        client = ConversationAnalysisClient(endpoint, credential, logging_enable=True)
-        result = client.analyze_conversation(...)
-        ```
-        
-        Similarly, `logging_enable` can enable detailed logging for a single operation, even when it isn't enabled for the client:
-        
-        ```python
-        result = client.analyze_conversation(..., logging_enable=True)
-        ```
-        
-        ## Next steps
-        
-        ### More sample code
-        
-        See the [Sample README][conversationallanguage_samples] for several code snippets illustrating common patterns used in the CLU Python API.
-        
-        ## Contributing
-        
-        See the [CONTRIBUTING.md][contributing] for details on building, testing, and contributing to this library.
-        
-        This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit [cla.microsoft.com][cla].
-        
-        When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.
-        
-        This project has adopted the [Microsoft Open Source Code of Conduct][code_of_conduct]. For more information see the [Code of Conduct FAQ][coc_faq] or contact [opencode@microsoft.com][coc_contact] with any additional questions or comments.
-        
-        <!-- LINKS -->
-        [azure_cli]: https://docs.microsoft.com/cli/azure/
-        [azure_portal]: https://portal.azure.com/
-        [azure_subscription]: https://azure.microsoft.com/free/
-        [cla]: https://cla.microsoft.com
-        [coc_contact]: mailto:opencode@microsoft.com
-        [coc_faq]: https://opensource.microsoft.com/codeofconduct/faq/
-        [code_of_conduct]: https://opensource.microsoft.com/codeofconduct/
-        [cognitive_auth]: https://docs.microsoft.com/azure/cognitive-services/authentication/
-        [contributing]: https://github.com/Azure/azure-sdk-for-python/blob/main/CONTRIBUTING.md
-        [python_logging]: https://docs.python.org/3/library/logging.html
-        [sdk_logging_docs]: https://docs.microsoft.com/azure/developer/python/azure-sdk-logging
-        [azure_core_ref_docs]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-core/latest/azure.core.html
-        [azure_core_readme]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
-        [pip_link]:https://pypi.org/project/pip/
-        [conversationallanguage_client_src]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
-        [conversationallanguage_pypi_package]: https://pypi.org/project/azure-ai-language-conversations/
-        [api_reference_documentation]:https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html
-        [conversationallanguage_refdocs]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
-        [conversationallanguage_docs]: https://docs.microsoft.com/azure/cognitive-services/language-service/conversational-language-understanding/overview
-        [conversationallanguage_samples]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/README.md
-        [conversationallanguage_restdocs]: https://docs.microsoft.com/rest/api/language/conversation-analysis-runtime/
-        [conversationallanguage_restdocs_authoring]: https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring
-        [conversationanalysisclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAnalysisClient
-        [conversationauthoringclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAuthoringClient
-        [azure_core_exceptions]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
-        [azure_language_portal]: https://language.cognitive.azure.com/home
-        [cognitive_authentication_aad]: https://docs.microsoft.com/azure/cognitive-services/authentication#authenticate-with-azure-active-directory
-        [azure_identity_credentials]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#credentials
-        [custom_subdomain]: https://docs.microsoft.com/azure/cognitive-services/authentication#create-a-resource-with-a-custom-subdomain
-        [install_azure_identity]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#install-the-package
-        [register_aad_app]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
-        [grant_role_access]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
-        [default_azure_credential]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#defaultazurecredential
-        
-        ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Ftemplate%2Fazure-template%2FREADME.png)
-        
-        
-        # Release History
-        
-        ## 1.1.0b2 (2022-07-01)
-        
-        ### Features Added
-        * Added Azure Active Directory (AAD) authentication support
-        * Added support for authoring operations with `ConversationAuthoringClient` under the `azure.ai.language.conversations.authoring` namespace.
-        
-        ## 1.1.0b1 (2022-05-26)
-        
-        ### Features Added
-        * Conversation summarization task (Long-running operation)
-        * Conversation PII extraction task (Long-running operation)
-        
-        ### Breaking Changes
-        * Client now uses python dictionaries for method parameters and results instead of classes.
-        * Many input and result parameter name changes in `analyze_conversation()` method
-        
-        ## 1.0.0 (2022-06-27)
-        
-        ### Features Added
-        * Added Azure Active Directory (AAD) authentication support
-        * Added more resolution types for entities
-        * Added support for authoring operations with `ConversationAuthoringClient` under the `azure.ai.language.conversations.authoring` namespace.
-        
-        ### Breaking Changes
-        * Client now uses python dictionaries for method parameters and results instead of classes.
-        
-        ## 1.0.0b3 (2022-04-19)
-        
-        ### Features Added
-        * Entity resolutions
-        * Extra features
-        
-        ### Breaking Changes
-        * The `ConversationAnalysisOptions` model used as input to the `analyze_conversation` operation is now wrapped in a `CustomConversationalTask` which combines the analysis options with the project parameters into a single model.
-        * The `query` within the `ConversationAnalysisOptions` is now further qualified as a `TextConversationItem` with additional properties.
-        * The output `AnalyzeConversationResult` is now wrapped in a `CustomConversationalTaskResult` according to the input model.
-        
-        ### Other Changes
-        * Python 2.7 is no longer supported. Please use Python version 3.6 or later.
-        
-        ## 1.0.0b1 (2021-11-03)
-        
-        ### Features Added
-        * Initial release
-        
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.6
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: License :: OSI Approved :: MIT License
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
+    )
+    # view result
+    result = poller.result()
+    task_result = result["tasks"]["items"][0]
+    print("... view task status ...")
+    print("status: {}".format(task_result["status"]))
+    conv_pii_result = task_result["results"]
+    if conv_pii_result["errors"]:
+        print("... errors occurred ...")
+        for error in conv_pii_result["errors"]:
+            print(error)
+    else:
+        conversation_result = conv_pii_result["conversations"][0]
+        if conversation_result["warnings"]:
+            print("... view warnings ...")
+            for warning in conversation_result["warnings"]:
+                print(warning)
+        else:
+            print("... view task result ...")
+            for conversation in conversation_result["conversationItems"]:
+                print("conversation id: {}".format(conversation["id"]))
+                print("... entities ...")
+                for entity in conversation["entities"]:
+                    print("text: {}".format(entity["text"]))
+                    print("category: {}".format(entity["category"]))
+                    print("confidence: {}".format(entity["confidenceScore"]))
+                    print("offset: {}".format(entity["offset"]))
+                    print("length: {}".format(entity["length"]))
+```
+
+
+### Conversational Sentiment Analysis
+
+Analyze sentiment in conversations.
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+# get secrets
+endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+key = os.environ["AZURE_CONVERSATIONS_KEY"]
+# analyze query
+client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
+
+with client:
+    poller = client.begin_conversation_analysis(
+        task={
+          "displayName": "Sentiment Analysis from a call center conversation",
+          "analysisInput": {
+            "conversations": [
+              {
+                "id": "1",
+                "language": "en",
+                "modality": "transcript",
+                "conversationItems": [
+                  {
+                    "participantId": "1",
+                    "id": "1",
+                    "text": "I like the service. I do not like the food",
+                    "lexical": "i like the service i do not like the food",
+                  }
+                ]
+              }
+            ]
+          },
+          "tasks": [
+            {
+              "taskName": "Conversation Sentiment Analysis",
+              "kind": "ConversationalSentimentTask",
+              "parameters": {
+                "modelVersion": "latest",
+                "predictionSource": "text"
+              }
+            }
+          ]
+        }
+    )
+
+    result = poller.result()
+    task_result = result["tasks"]["items"][0]
+    print("... view task status ...")
+    print(f"status: {task_result['status']}")
+    conv_sentiment_result = task_result["results"]
+    if conv_sentiment_result["errors"]:
+        print("... errors occurred ...")
+        for error in conv_sentiment_result["errors"]:
+            print(error)
+    else:
+        conversation_result = conv_sentiment_result["conversations"][0]
+        if conversation_result["warnings"]:
+            print("... view warnings ...")
+            for warning in conversation_result["warnings"]:
+                print(warning)
+        else:
+            print("... view task result ...")
+            for conversation in conversation_result["conversationItems"]:
+                print(f"Participant ID: {conversation['participantId']}")
+                print(f"Sentiment: {conversation['sentiment']}")
+                print(f"confidenceScores: {conversation['confidenceScores']}")
+```
+
+
+### Import a Conversation Project
+This sample shows a common scenario for the authoring part of the SDK
+
+```python
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations.authoring import ConversationAuthoringClient
+
+clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+
+project_name = "test_project"
+
+exported_project_assets = {
+    "projectKind": "Conversation",
+    "intents": [{"category": "Read"}, {"category": "Delete"}],
+    "entities": [{"category": "Sender"}],
+    "utterances": [
+        {
+            "text": "Open Blake's email",
+            "dataset": "Train",
+            "intent": "Read",
+            "entities": [{"category": "Sender", "offset": 5, "length": 5}],
+        },
+        {
+            "text": "Delete last email",
+            "language": "en-gb",
+            "dataset": "Test",
+            "intent": "Delete",
+            "entities": [],
+        },
+    ],
+}
+
+client = ConversationAuthoringClient(
+    clu_endpoint, AzureKeyCredential(clu_key)
+)
+poller = client.begin_import_project(
+    project_name=project_name,
+    project={
+        "assets": exported_project_assets,
+        "metadata": {
+            "projectKind": "Conversation",
+            "settings": {"confidenceThreshold": 0.7},
+            "projectName": "EmailApp",
+            "multilingual": True,
+            "description": "Trying out CLU",
+            "language": "en-us",
+        },
+        "projectFileVersion": "2022-05-01",
+    },
+)
+response = poller.result()
+print(response)
+
+```
+
+
+## Optional Configuration
+
+Optional keyword arguments can be passed in at the client and per-operation level. The azure-core [reference documentation][azure_core_ref_docs] describes available configurations for retries, logging, transport protocols, and more.
+
+## Troubleshooting
+
+### General
+
+The Conversations client will raise exceptions defined in [Azure Core][azure_core_exceptions].
+
+### Logging
+
+This library uses the standard
+[logging][python_logging] library for logging.
+Basic information about HTTP sessions (URLs, headers, etc.) is logged at INFO
+level.
+
+Detailed DEBUG level logging, including request/response bodies and unredacted
+headers, can be enabled on a client with the `logging_enable` argument.
+
+See full SDK logging documentation with examples [here][sdk_logging_docs].
+
+```python
+import sys
+import logging
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+
+# Create a logger for the 'azure' SDK
+logger = logging.getLogger('azure')
+logger.setLevel(logging.DEBUG)
+
+# Configure a console output
+handler = logging.StreamHandler(stream=sys.stdout)
+logger.addHandler(handler)
+
+endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
+credential = AzureKeyCredential("<my-api-key>")
+
+# This client will log detailed information about its HTTP sessions, at DEBUG level
+client = ConversationAnalysisClient(endpoint, credential, logging_enable=True)
+result = client.analyze_conversation(...)
+```
+
+Similarly, `logging_enable` can enable detailed logging for a single operation, even when it isn't enabled for the client:
+
+```python
+result = client.analyze_conversation(..., logging_enable=True)
+```
+
+## Next steps
+
+### More sample code
+
+See the [Sample README][conversationallanguage_samples] for several code snippets illustrating common patterns used in the CLU Python API.
+
+## Contributing
+
+See the [CONTRIBUTING.md][contributing] for details on building, testing, and contributing to this library.
+
+This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit [cla.microsoft.com][cla].
+
+When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.
+
+This project has adopted the [Microsoft Open Source Code of Conduct][code_of_conduct]. For more information see the [Code of Conduct FAQ][coc_faq] or contact [opencode@microsoft.com][coc_contact] with any additional questions or comments.
+
+<!-- LINKS -->
+[azure_cli]: https://docs.microsoft.com/cli/azure/
+[azure_portal]: https://portal.azure.com/
+[azure_subscription]: https://azure.microsoft.com/free/
+[cla]: https://cla.microsoft.com
+[coc_contact]: mailto:opencode@microsoft.com
+[coc_faq]: https://opensource.microsoft.com/codeofconduct/faq/
+[code_of_conduct]: https://opensource.microsoft.com/codeofconduct/
+[cognitive_auth]: https://docs.microsoft.com/azure/cognitive-services/authentication/
+[contributing]: https://github.com/Azure/azure-sdk-for-python/blob/main/CONTRIBUTING.md
+[python_logging]: https://docs.python.org/3/library/logging.html
+[sdk_logging_docs]: https://docs.microsoft.com/azure/developer/python/azure-sdk-logging
+[azure_core_ref_docs]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-core/latest/azure.core.html
+[azure_core_readme]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
+[pip_link]:https://pypi.org/project/pip/
+[conversationallanguage_client_src]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
+[conversationallanguage_pypi_package]: https://pypi.org/project/azure-ai-language-conversations/
+[api_reference_documentation]:https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html
+[conversationallanguage_refdocs]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
+[conversationallanguage_docs]: https://docs.microsoft.com/azure/cognitive-services/language-service/conversational-language-understanding/overview
+[conversationallanguage_samples]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/README.md
+[conversationallanguage_restdocs]: https://learn.microsoft.com/rest/api/language/
+[conversationanalysisclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAnalysisClient
+[conversationauthoringclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAuthoringClient
+[azure_core_exceptions]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
+[azure_language_portal]: https://language.cognitive.azure.com/home
+[cognitive_authentication_aad]: https://docs.microsoft.com/azure/cognitive-services/authentication#authenticate-with-azure-active-directory
+[azure_identity_credentials]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#credentials
+[custom_subdomain]: https://docs.microsoft.com/azure/cognitive-services/authentication#create-a-resource-with-a-custom-subdomain
+[install_azure_identity]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#install-the-package
+[register_aad_app]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
+[grant_role_access]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
+[default_azure_credential]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#defaultazurecredential
+[conversationanalysis_restdocs]: https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime
+[conversationanalysis_restdocs_authoring]: https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring
+
+![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Ftemplate%2Fazure-template%2FREADME.png)
+
+
+# Release History
+
+## 1.1.0b3 (2022-11-10)
+
+### Features Added
+- Added support for the "ConversationalSentimentTask" kind with `begin_conversation_analysis`.
+- Added support for "chapterTitle" and "narrative" `summaryAspects` options for ConversationalSummarizationTasks.
+- Added methods to the `ConversationAuthoringClient` to manage deployment resources:
+  - `begin_assign_deployment_resources`
+  - `get_assign_deployment_resources_status`
+  - `begin_unassign_deployment_resources`
+  - `get_unassign_deployment_resources_status`
+  - `begin_delete_deployment_from_resources`
+  - `get_deployment_delete_from_resources_status`
+  - `begin_load_snapshot`
+  - `get_load_snapshot_status`
+  - `list_assigned_resource_deployments`
+  - `list_deployment_resources`
+- Added optional `trained_model_label` keyword argument to `begin_export_project`.
+
+### Other Changes
+* This version and all future versions will require Python 3.7+. Python 3.6 is no longer supported.
+
+## 1.1.0b2 (2022-07-01)
+
+### Features Added
+* Added Azure Active Directory (AAD) authentication support
+* Added support for authoring operations with `ConversationAuthoringClient` under the `azure.ai.language.conversations.authoring` namespace.
+
+## 1.0.0 (2022-06-27)
+
+### Features Added
+* Added Azure Active Directory (AAD) authentication support
+* Added more resolution types for entities
+* Added support for authoring operations with `ConversationAuthoringClient` under the `azure.ai.language.conversations.authoring` namespace.
+
+### Breaking Changes
+* Client now uses python dictionaries for method parameters and results instead of classes.
+
+## 1.1.0b1 (2022-05-26)
+
+### Features Added
+* Conversation summarization task (Long-running operation)
+* Conversation PII extraction task (Long-running operation)
+
+### Breaking Changes
+* Client now uses python dictionaries for method parameters and results instead of classes.
+* Many input and result parameter name changes in `analyze_conversation()` method
+
+## 1.0.0b3 (2022-04-19)
+
+### Features Added
+* Entity resolutions
+* Extra features
+
+### Breaking Changes
+* The `ConversationAnalysisOptions` model used as input to the `analyze_conversation` operation is now wrapped in a `CustomConversationalTask` which combines the analysis options with the project parameters into a single model.
+* The `query` within the `ConversationAnalysisOptions` is now further qualified as a `TextConversationItem` with additional properties.
+* The output `AnalyzeConversationResult` is now wrapped in a `CustomConversationalTaskResult` according to the input model.
+
+### Other Changes
+* Python 2.7 is no longer supported. Please use Python version 3.6 or later.
+
+## 1.0.0b1 (2021-11-03)
+
+### Features Added
+* Initial release
```

## Comparing `azure-ai-language-conversations-1.1.0b2/setup.py` & `azure-ai-language-conversations-1.1.0b3/setup.py`

 * *Files 6% similar despite different names*

```diff
@@ -46,38 +46,39 @@
     author_email='azpysdkhelp@microsoft.com',
     url='https://github.com/Azure/azure-sdk-for-python',
     classifiers=[
         "Development Status :: 4 - Beta",
         "Programming Language :: Python",
         "Programming Language :: Python :: 3 :: Only",
         "Programming Language :: Python :: 3",
-        "Programming Language :: Python :: 3.6",
         "Programming Language :: Python :: 3.7",
         "Programming Language :: Python :: 3.8",
         "Programming Language :: Python :: 3.9",
         "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
         "License :: OSI Approved :: MIT License",
     ],
-    python_requires=">=3.6",
+    python_requires=">=3.7",
     zip_safe=False,
     packages=find_packages(exclude=[
         'tests',
         # Exclude packages that will be covered by PEP420 or nspkg
         # This means any folder structure that only consists of a __init__.py.
         # For example, for storage, this would mean adding 'azure.storage'
         # in addition to the default 'azure' that is seen here.
         'azure',
         'azure.ai',
         'azure.ai.language',
     ]),
     package_data={
-        'pytyped': ['py.typed'],
+        'azure.ai.language.conversations': ['py.typed'],
     },
     install_requires=[
         "azure-core<2.0.0,>=1.24.0",
         "isodate<1.0.0,>=0.6.1",
+        "typing-extensions>=4.0.1",
     ],
     project_urls={
         'Bug Reports': 'https://github.com/Azure/azure-sdk-for-python/issues',
         'Source': 'https://github.com/Azure/azure-sdk-python',
     }
 )
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/SOURCES.txt` & `azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -61,34 +61,39 @@
 samples/sample_analyze_conversation_app.py
 samples/sample_analyze_orchestration_app_conv_response.py
 samples/sample_analyze_orchestration_app_luis_response.py
 samples/sample_analyze_orchestration_app_qna_response.py
 samples/sample_analyze_orchestration_direct_target.py
 samples/sample_authentication.py
 samples/sample_conv_pii_transcript_input.py
+samples/sample_conv_sentiment.py
 samples/sample_conv_summarization.py
 samples/async/sample_analyze_conversation_app_async.py
 samples/async/sample_analyze_orchestration_app_conv_response_async.py
 samples/async/sample_analyze_orchestration_app_luis_response_async.py
 samples/async/sample_analyze_orchestration_app_qna_response_async.py
 samples/async/sample_analyze_orchestration_direct_target_async.py
 samples/async/sample_authentication_async.py
 samples/async/sample_conv_pii_transcript_input_async.py
+samples/async/sample_conv_sentiment_async.py
 samples/async/sample_conv_summarization_async.py
-samples/async/authoring/sample_import_train_deploy_project_async.py
-samples/authoring/sample_import_train_deploy_project.py
-tests/asynctestcase.py
+samples/async/authoring/sample_assign_deployment_resources_async.py
+samples/async/authoring/sample_manage_projects_async.py
+samples/authoring/sample_assign_deployment_resources.py
+samples/authoring/sample_manage_projects.py
+tests/conftest.py
 tests/test_authoring.py
 tests/test_authoring_async.py
 tests/test_conv_pii_transcript_input.py
 tests/test_conv_pii_transcript_input_async.py
+tests/test_conv_sentiment.py
+tests/test_conv_sentiment_async.py
 tests/test_conv_summarization.py
 tests/test_conv_summarization_async.py
 tests/test_conversation_app.py
 tests/test_conversation_app_async.py
 tests/test_orchestration_app_conv_response.py
 tests/test_orchestration_app_conv_response_async.py
 tests/test_orchestration_app_luis_response.py
 tests/test_orchestration_app_luis_response_async.py
 tests/test_orchestration_app_qna_response.py
-tests/test_orchestration_app_qna_response_async.py
-tests/testcase.py
+tests/test_orchestration_app_qna_response_async.py
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure_ai_language_conversations.egg-info/PKG-INFO` & `azure-ai-language-conversations-1.1.0b3/azure_ai_language_conversations.egg-info/PKG-INFO`

 * *Files 12% similar despite different names*

```diff
@@ -1,659 +1,758 @@
 Metadata-Version: 2.1
 Name: azure-ai-language-conversations
-Version: 1.1.0b2
+Version: 1.1.0b3
 Summary: Microsoft Azure Conversational Language Understanding Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Project-URL: Bug Reports, https://github.com/Azure/azure-sdk-for-python/issues
 Project-URL: Source, https://github.com/Azure/azure-sdk-python
-Description: [![Build Status](https://dev.azure.com/azure-sdk/public/_apis/build/status/azure-sdk-for-python.client?branchName=main)](https://dev.azure.com/azure-sdk/public/_build/latest?definitionId=46?branchName=main)
-        
-        # Azure Conversational Language Understanding client library for Python
-        Conversational Language Understanding - aka **CLU** for short - is a cloud-based conversational AI service which provides many language understanding capabilities like:
-        - Conversation App: It's used in extracting intents and entities in conversations
-        - Workflow app: Acts like an orchestrator to select the best candidate to analyze conversations to get best response from apps like Qna, Luis, and Conversation App
-        - Conversational Summarization: Used to summarize conversations in the form of issues, and final resolutions
-        - Conversational PII: Used to extract and redact personally-identifiable info (PII)
-        
-        [Source code][conversationallanguage_client_src] | [Package (PyPI)][conversationallanguage_pypi_package] | [API reference documentation][api_reference_documentation] | [Samples][conversationallanguage_samples] | [Product documentation][conversationallanguage_docs] | [Analysis REST API][conversationallanguage_restdocs] | [Authoring REST API][conversationallanguage_restdocs_authoring]
-        
-        ## _Disclaimer_
-        
-        _Azure SDK Python packages support for Python 2.7 ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
-        
-        
-        ## Getting started
-        
-        ### Prerequisites
-        
-        * Python 3.6 or later is required to use this package.
-        * An [Azure subscription][azure_subscription]
-        * An existing Azure Language Service Resource
-        
-        
-        ### Install the package
-        
-        Install the Azure Conversations client library for Python with [pip][pip_link]:
-        
-        ```bash
-        pip install azure-ai-language-conversations --pre
-        ```
-        
-        > Note: This version of the client library defaults to the 2022-05-15-preview version of the service
-        
-        ### Authenticate the client
-        In order to interact with the CLU service, you'll need to create an instance of the [ConversationAnalysisClient][conversationanalysisclient_class] class, or [ConversationAuthoringClient][conversationauthoringclient_class] class. You will need an **endpoint**, and an **API key** to instantiate a client object. For more information regarding authenticating with Cognitive Services, see [Authenticate requests to Azure Cognitive Services][cognitive_auth].
-        
-        #### Get an API key
-        You can get the **endpoint** and an **API key** from the Cognitive Services resource in the [Azure Portal][azure_portal].
-        
-        Alternatively, use the [Azure CLI][azure_cli] command shown below to get the API key from the Cognitive Service resource.
-        
-        ```powershell
-        az cognitiveservices account keys list --resource-group <resource-group-name> --name <resource-name>
-        ```
-        
-        
-        #### Create ConversationAnalysisClient
-        Once you've determined your **endpoint** and **API key** you can instantiate a `ConversationAnalysisClient`:
-        
-        ```python
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        
-        endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
-        credential = AzureKeyCredential("<api-key>")
-        client = ConversationAnalysisClient(endpoint, credential)
-        ```
-        
-        #### Create ConversationAuthoringClient
-        Once you've determined your **endpoint** and **API key** you can instantiate a `ConversationAuthoringClient`:
-        
-        ```python
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations.authoring import ConversationAuthoringClient
-        
-        endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
-        credential = AzureKeyCredential("<api-key>")
-        client = ConversationAuthoringClient(endpoint, credential)
-        ```
-        
-        #### Create a client with an Azure Active Directory Credential
-        
-        To use an [Azure Active Directory (AAD) token credential][cognitive_authentication_aad],
-        provide an instance of the desired credential type obtained from the
-        [azure-identity][azure_identity_credentials] library.
-        Note that regional endpoints do not support AAD authentication. Create a [custom subdomain][custom_subdomain]
-        name for your resource in order to use this type of authentication.
-        
-        Authentication with AAD requires some initial setup:
-        
-        - [Install azure-identity][install_azure_identity]
-        - [Register a new AAD application][register_aad_app]
-        - [Grant access][grant_role_access] to the Language service by assigning the "Cognitive Services Language Reader" role to your service principal.
-        
-        After setup, you can choose which type of [credential][azure_identity_credentials] from azure.identity to use.
-        As an example, [DefaultAzureCredential][default_azure_credential]
-        can be used to authenticate the client:
-        
-        Set the values of the client ID, tenant ID, and client secret of the AAD application as environment variables:
-        `AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_CLIENT_SECRET`
-        
-        Use the returned token credential to authenticate the client:
-        
-        ```python
-        from azure.ai.textanalytics import ConversationAnalysisClient
-        from azure.identity import DefaultAzureCredential
-        
-        credential = DefaultAzureCredential()
-        client = ConversationAnalysisClient(endpoint="https://<my-custom-subdomain>.cognitiveservices.azure.com/", credential=credential)
-        ```
-        
-        ## Key concepts
-        
-        ### ConversationAnalysisClient
-        The [ConversationAnalysisClient][conversationanalysisclient_class] is the primary interface for making predictions using your deployed Conversations models. For asynchronous operations, an async `ConversationAnalysisClient` is in the `azure.ai.language.conversation.aio` namespace.
-        
-        ### ConversationAuthoringClient
-        You can use the [ConversationAuthoringClient][conversationauthoringclient_class] to interface with the [Azure Language Portal][azure_language_portal] to carry out authoring operations on your language resource/project. For example, you can use it to create a project, populate with training data, train, test, and deploy. For asynchronous operations, an async `ConversationAuthoringClient` is in the `azure.ai.language.conversation.authoring.aio` namespace.
-        
-        ## Examples
-        The `azure-ai-language-conversation` client library provides both synchronous and asynchronous APIs.
-        
-        The following examples show common scenarios using the `client` [created above](#create-conversationanalysisclient).
-        
-        ### Analyze Text with a Conversation App
-        If you would like to extract custom intents and entities from a user utterance, you can call the `client.analyze_conversation()` method with your conversation's project name as follows:
-        
-        
-        ```python
-        # import libraries
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        
-        # get secrets
-        clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        project_name = os.environ["AZURE_CONVERSATIONS_PROJECT_NAME"]
-        deployment_name = os.environ["AZURE_CONVERSATIONS_DEPLOYMENT_NAME"]
-        
-        # analyze quey
-        client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
-        with client:
-            query = "Send an email to Carol about the tomorrow's demo"
-            result = client.analyze_conversation(
-                task={
-                    "kind": "Conversation",
-                    "analysisInput": {
-                        "conversationItem": {
-                            "participantId": "1",
-                            "id": "1",
-                            "modality": "text",
-                            "language": "en",
-                            "text": query
-                        },
-                        "isLoggingEnabled": False
+Classifier: Development Status :: 4 - Beta
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: License :: OSI Approved :: MIT License
+Requires-Python: >=3.7
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+[![Build Status](https://dev.azure.com/azure-sdk/public/_apis/build/status/azure-sdk-for-python.client?branchName=main)](https://dev.azure.com/azure-sdk/public/_build/latest?definitionId=46?branchName=main)
+
+# Azure Conversational Language Understanding client library for Python
+Conversational Language Understanding - aka **CLU** for short - is a cloud-based conversational AI service which provides many language understanding capabilities like:
+- Conversation App: It's used in extracting intents and entities in conversations
+- Workflow app: Acts like an orchestrator to select the best candidate to analyze conversations to get best response from apps like Qna, Luis, and Conversation App
+- Conversational Summarization: Used to analyze conversations in the form of issues/resolution, chapter title, and narrative summarizations
+- Conversational PII: Used to extract and redact personally-identifiable information (PII)
+- Conversational Sentiment Analysis: Used to analyze the sentiment of conversations
+
+[Source code][conversationallanguage_client_src] | [Package (PyPI)][conversationallanguage_pypi_package] | [API reference documentation][api_reference_documentation] | [Samples][conversationallanguage_samples] | [Product documentation][conversationallanguage_docs] | [Analysis REST API documentation][conversationanalysis_restdocs] | [Authoring REST API documentation][conversationanalysis_restdocs_authoring]
+
+## Getting started
+
+### Prerequisites
+
+* Python 3.7 or later is required to use this package.
+* An [Azure subscription][azure_subscription]
+* An existing Azure Language Service Resource
+
+
+### Install the package
+
+Install the Azure Conversations client library for Python with [pip][pip_link]:
+
+```bash
+pip install azure-ai-language-conversations --pre
+```
+
+> Note: This version of the client library defaults to the 2022-10-01-preview version of the service
+
+### Authenticate the client
+In order to interact with the CLU service, you'll need to create an instance of the [ConversationAnalysisClient][conversationanalysisclient_class] class, or [ConversationAuthoringClient][conversationauthoringclient_class] class. You will need an **endpoint**, and an **API key** to instantiate a client object. For more information regarding authenticating with Cognitive Services, see [Authenticate requests to Azure Cognitive Services][cognitive_auth].
+
+#### Get an API key
+You can get the **endpoint** and an **API key** from the Cognitive Services resource in the [Azure Portal][azure_portal].
+
+Alternatively, use the [Azure CLI][azure_cli] command shown below to get the API key from the Cognitive Service resource.
+
+```powershell
+az cognitiveservices account keys list --resource-group <resource-group-name> --name <resource-name>
+```
+
+
+#### Create ConversationAnalysisClient
+Once you've determined your **endpoint** and **API key** you can instantiate a `ConversationAnalysisClient`:
+
+```python
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+
+endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
+credential = AzureKeyCredential("<api-key>")
+client = ConversationAnalysisClient(endpoint, credential)
+```
+
+#### Create ConversationAuthoringClient
+Once you've determined your **endpoint** and **API key** you can instantiate a `ConversationAuthoringClient`:
+
+```python
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations.authoring import ConversationAuthoringClient
+
+endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
+credential = AzureKeyCredential("<api-key>")
+client = ConversationAuthoringClient(endpoint, credential)
+```
+
+#### Create a client with an Azure Active Directory Credential
+
+To use an [Azure Active Directory (AAD) token credential][cognitive_authentication_aad],
+provide an instance of the desired credential type obtained from the
+[azure-identity][azure_identity_credentials] library.
+Note that regional endpoints do not support AAD authentication. Create a [custom subdomain][custom_subdomain]
+name for your resource in order to use this type of authentication.
+
+Authentication with AAD requires some initial setup:
+
+- [Install azure-identity][install_azure_identity]
+- [Register a new AAD application][register_aad_app]
+- [Grant access][grant_role_access] to the Language service by assigning the "Cognitive Services Language Reader" role to your service principal.
+
+After setup, you can choose which type of [credential][azure_identity_credentials] from azure.identity to use.
+As an example, [DefaultAzureCredential][default_azure_credential]
+can be used to authenticate the client:
+
+Set the values of the client ID, tenant ID, and client secret of the AAD application as environment variables:
+`AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_CLIENT_SECRET`
+
+Use the returned token credential to authenticate the client:
+
+```python
+from azure.ai.language.conversations import ConversationAnalysisClient
+from azure.identity import DefaultAzureCredential
+
+credential = DefaultAzureCredential()
+client = ConversationAnalysisClient(endpoint="https://<my-custom-subdomain>.cognitiveservices.azure.com/", credential=credential)
+```
+
+## Key concepts
+
+### ConversationAnalysisClient
+The [ConversationAnalysisClient][conversationanalysisclient_class] is the primary interface for making predictions using your deployed Conversations models. For asynchronous operations, an async `ConversationAnalysisClient` is in the `azure.ai.language.conversation.aio` namespace.
+
+### ConversationAuthoringClient
+You can use the [ConversationAuthoringClient][conversationauthoringclient_class] to interface with the [Azure Language Portal][azure_language_portal] to carry out authoring operations on your language resource/project. For example, you can use it to create a project, populate with training data, train, test, and deploy. For asynchronous operations, an async `ConversationAuthoringClient` is in the `azure.ai.language.conversation.authoring.aio` namespace.
+
+## Examples
+The `azure-ai-language-conversation` client library provides both synchronous and asynchronous APIs.
+
+The following examples show common scenarios using the `client` [created above](#create-conversationanalysisclient).
+
+### Analyze Text with a Conversation App
+If you would like to extract custom intents and entities from a user utterance, you can call the `client.analyze_conversation()` method with your conversation's project name as follows:
+
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+
+# get secrets
+clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+project_name = os.environ["AZURE_CONVERSATIONS_PROJECT_NAME"]
+deployment_name = os.environ["AZURE_CONVERSATIONS_DEPLOYMENT_NAME"]
+
+# analyze quey
+client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
+with client:
+    query = "Send an email to Carol about the tomorrow's demo"
+    result = client.analyze_conversation(
+        task={
+            "kind": "Conversation",
+            "analysisInput": {
+                "conversationItem": {
+                    "participantId": "1",
+                    "id": "1",
+                    "modality": "text",
+                    "language": "en",
+                    "text": query
+                },
+                "isLoggingEnabled": False
+            },
+            "parameters": {
+                "projectName": project_name,
+                "deploymentName": deployment_name,
+                "verbose": True
+            }
+        }
+    )
+
+# view result
+print("query: {}".format(result["result"]["query"]))
+print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+
+print("top intent: {}".format(result["result"]["prediction"]["topIntent"]))
+print("category: {}".format(result["result"]["prediction"]["intents"][0]["category"]))
+print("confidence score: {}\n".format(result["result"]["prediction"]["intents"][0]["confidenceScore"]))
+
+print("entities:")
+for entity in result["result"]["prediction"]["entities"]:
+    print("\ncategory: {}".format(entity["category"]))
+    print("text: {}".format(entity["text"]))
+    print("confidence score: {}".format(entity["confidenceScore"]))
+    if "resolutions" in entity:
+        print("resolutions")
+        for resolution in entity["resolutions"]:
+            print("kind: {}".format(resolution["resolutionKind"]))
+            print("value: {}".format(resolution["value"]))
+    if "extraInformation" in entity:
+        print("extra info")
+        for data in entity["extraInformation"]:
+            print("kind: {}".format(data["extraInformationKind"]))
+            if data["extraInformationKind"] == "ListKey":
+                print("key: {}".format(data["key"]))
+            if data["extraInformationKind"] == "EntitySubtype":
+                print("value: {}".format(data["value"]))
+```
+
+### Analyze Text with an Orchestration App
+
+If you would like to pass the user utterance to your orchestrator (worflow) app, you can call the `client.analyze_conversation()` method with your orchestration's project name. The orchestrator project simply orchestrates the submitted user utterance between your language apps (Luis, Conversation, and Question Answering) to get the best response according to the user intent. See the next example:
+
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+
+# get secrets
+clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+project_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME"]
+deployment_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME"]
+
+# analyze query
+client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
+with client:
+    query = "Reserve a table for 2 at the Italian restaurant"
+    result = client.analyze_conversation(
+        task={
+            "kind": "Conversation",
+            "analysisInput": {
+                "conversationItem": {
+                    "participantId": "1",
+                    "id": "1",
+                    "modality": "text",
+                    "language": "en",
+                    "text": query
+                },
+                "isLoggingEnabled": False
+            },
+            "parameters": {
+                "projectName": project_name,
+                "deploymentName": deployment_name,
+                "verbose": True
+            }
+        }
+    )
+
+# view result
+print("query: {}".format(result["result"]["query"]))
+print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+
+# top intent
+top_intent = result["result"]["prediction"]["topIntent"]
+print("top intent: {}".format(top_intent))
+top_intent_object = result["result"]["prediction"]["intents"][top_intent]
+print("confidence score: {}".format(top_intent_object["confidenceScore"]))
+print("project kind: {}".format(top_intent_object["targetProjectKind"]))
+
+if top_intent_object["targetProjectKind"] == "Luis":
+    print("\nluis response:")
+    luis_response = top_intent_object["result"]["prediction"]
+    print("top intent: {}".format(luis_response["topIntent"]))
+    print("\nentities:")
+    for entity in luis_response["entities"]:
+        print("\n{}".format(entity))
+```
+
+### Conversational Summarization
+
+You can use this sample if you need to summarize a conversation in the form of an issue, and final resolution. For example, a dialog from tech support:
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+# get secrets
+endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+key = os.environ["AZURE_CONVERSATIONS_KEY"]
+# analyze query
+client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
+with client:
+    poller = client.begin_conversation_analysis(
+        task={
+            "displayName": "Analyze conversations from xxx",
+            "analysisInput": {
+                "conversations": [
+                    {
+                        "conversationItems": [
+                            {
+                                "text": "Hello, how can I help you?",
+                                "modality": "text",
+                                "id": "1",
+                                "participantId": "Agent"
+                            },
+                            {
+                                "text": "How to upgrade Office? I am getting error messages the whole day.",
+                                "modality": "text",
+                                "id": "2",
+                                "participantId": "Customer"
+                            },
+                            {
+                                "text": "Press the upgrade button please. Then sign in and follow the instructions.",
+                                "modality": "text",
+                                "id": "3",
+                                "participantId": "Agent"
+                            }
+                        ],
+                        "modality": "text",
+                        "id": "conversation1",
+                        "language": "en"
                     },
+                ]
+            },
+            "tasks": [
+                {
+                    "taskName": "Issue task",
+                    "kind": "ConversationalSummarizationTask",
                     "parameters": {
-                        "projectName": project_name,
-                        "deploymentName": deployment_name,
-                        "verbose": True
+                        "summaryAspects": ["issue"]
                     }
-                }
-            )
-        
-        # view result
-        print("query: {}".format(result["result"]["query"]))
-        print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
-        
-        print("top intent: {}".format(result["result"]["prediction"]["topIntent"]))
-        print("category: {}".format(result["result"]["prediction"]["intents"][0]["category"]))
-        print("confidence score: {}\n".format(result["result"]["prediction"]["intents"][0]["confidenceScore"]))
-        
-        print("entities:")
-        for entity in result["result"]["prediction"]["entities"]:
-            print("\ncategory: {}".format(entity["category"]))
-            print("text: {}".format(entity["text"]))
-            print("confidence score: {}".format(entity["confidenceScore"]))
-            if "resolutions" in entity:
-                print("resolutions")
-                for resolution in entity["resolutions"]:
-                    print("kind: {}".format(resolution["resolutionKind"]))
-                    print("value: {}".format(resolution["value"]))
-            if "extraInformation" in entity:
-                print("extra info")
-                for data in entity["extraInformation"]:
-                    print("kind: {}".format(data["extraInformationKind"]))
-                    if data["extraInformationKind"] == "ListKey":
-                        print("key: {}".format(data["key"]))
-                    if data["extraInformationKind"] == "EntitySubtype":
-                        print("value: {}".format(data["value"]))
-        ```
-        
-        ### Analyze Text with an Orchestration App
-        
-        If you would like to pass the user utterance to your orchestrator (worflow) app, you can call the `client.analyze_conversation()` method with your orchestration's project name. The orchestrator project simply orchestrates the submitted user utterance between your language apps (Luis, Conversation, and Question Answering) to get the best response according to the user intent. See the next example:
-        
-        
-        ```python
-        # import libraries
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        
-        # get secrets
-        clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        project_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME"]
-        deployment_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME"]
-        
-        # analyze query
-        client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
-        with client:
-            query = "Reserve a table for 2 at the Italian restaurant"
-            result = client.analyze_conversation(
-                task={
-                    "kind": "Conversation",
-                    "analysisInput": {
-                        "conversationItem": {
-                            "participantId": "1",
-                            "id": "1",
-                            "modality": "text",
-                            "language": "en",
-                            "text": query
-                        },
-                        "isLoggingEnabled": False
-                    },
+                },
+                {
+                    "taskName": "Resolution task",
+                    "kind": "ConversationalSummarizationTask",
                     "parameters": {
-                        "projectName": project_name,
-                        "deploymentName": deployment_name,
-                        "verbose": True
+                        "summaryAspects": ["resolution"]
                     }
-                }
-            )
-        
-        # view result
-        print("query: {}".format(result["result"]["query"]))
-        print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
-        
-        # top intent
-        top_intent = result["result"]["prediction"]["topIntent"]
-        print("top intent: {}".format(top_intent))
-        top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-        print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-        print("project kind: {}".format(top_intent_object["targetProjectKind"]))
-        
-        if top_intent_object["targetProjectKind"] == "Luis":
-            print("\nluis response:")
-            luis_response = top_intent_object["result"]["prediction"]
-            print("top intent: {}".format(luis_response["topIntent"]))
-            print("\nentities:")
-            for entity in luis_response["entities"]:
-                print("\n{}".format(entity))
-        ```
-        
-        ### Conversational Summarization
-        
-        You can use this sample if you need to summarize a conversation in the form of an issue, and final resolution. For example, a dialog from tech support:
-        
-        ```python
-        # import libraries
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        # get secrets
-        endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
-            poller = client.begin_conversation_analysis(
-                task={
-                    "displayName": "Analyze conversations from xxx",
-                    "analysisInput": {
-                        "conversations": [
+                },
+            ]
+        }
+    )
+
+    # view result
+    result = poller.result()
+    task_results = result["tasks"]["items"]
+    for task in task_results:
+        print(f"\n{task['taskName']} status: {task['status']}")
+        task_result = task["results"]
+        if task_result["errors"]:
+            print("... errors occurred ...")
+            for error in task_result["errors"]:
+                print(error)
+        else:
+            conversation_result = task_result["conversations"][0]
+            if conversation_result["warnings"]:
+                print("... view warnings ...")
+                for warning in conversation_result["warnings"]:
+                    print(warning)
+            else:
+                summaries = conversation_result["summaries"]
+                print("... view task result ...")
+                for summary in summaries:
+                    print(f"{summary['aspect']}: {summary['text']}")
+```
+
+### Conversational PII
+
+You can use this sample if you need to extract and redact pii info from/in conversations
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+# get secrets
+endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+key = os.environ["AZURE_CONVERSATIONS_KEY"]
+# analyze query
+client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
+with client:
+    poller = client.begin_conversation_analysis(
+        task={
+            "displayName": "Analyze PII in conversation",
+            "analysisInput": {
+                "conversations": [
+                    {
+                        "conversationItems": [
                             {
-                                "conversationItems": [
-                                    {
-                                        "text": "Hello, how can I help you?",
-                                        "modality": "text",
-                                        "id": "1",
-                                        "participantId": "Agent"
-                                    },
-                                    {
-                                        "text": "How to upgrade Office? I am getting error messages the whole day.",
-                                        "modality": "text",
-                                        "id": "2",
-                                        "participantId": "Customer"
-                                    },
-                                    {
-                                        "text": "Press the upgrade button please. Then sign in and follow the instructions.",
-                                        "modality": "text",
-                                        "id": "3",
-                                        "participantId": "Agent"
-                                    }
-                                ],
-                                "modality": "text",
-                                "id": "conversation1",
-                                "language": "en"
+                                "id": "1",
+                                "participantId": "0",
+                                "modality": "transcript",
+                                "text": "It is john doe.",
+                                "lexical": "It is john doe",
+                                "itn": "It is john doe",
+                                "maskedItn": "It is john doe"
                             },
-                        ]
-                    },
-                    "tasks": [
-                        {
-                            "taskName": "analyze 1",
-                            "kind": "ConversationalSummarizationTask",
-                            "parameters": {
-                                "summaryAspects": ["Issue, Resolution"]
-                            }
-                        }
-                    ]
-                }
-            )
-        
-            # view result
-            result = poller.result()
-            task_result = result["tasks"]["items"][0]
-            print("... view task status ...")
-            print("status: {}".format(task_result["status"]))
-            resolution_result = task_result["results"]
-            if resolution_result["errors"]:
-                print("... errors occured ...")
-                for error in resolution_result["errors"]:
-                    print(error)
-            else:
-                conversation_result = resolution_result["conversations"][0]
-                if conversation_result["warnings"]:
-                    print("... view warnings ...")
-                    for warning in conversation_result["warnings"]:
-                        print(warning)
-                else:
-                    summaries = conversation_result["summaries"]
-                    print("... view task result ...")
-                    print("issue: {}".format(summaries[0]["text"]))
-                    print("resolution: {}".format(summaries[1]["text"]))
-        ```
-        
-        ### Conversational PII
-        
-        You can use this sample if you need to extract and redact pii info from/in conversations
-        
-        ```python
-        # import libraries
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        # get secrets
-        endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
-            poller = client.begin_conversation_analysis(
-                task={
-                    "displayName": "Analyze PII in conversation",
-                    "analysisInput": {
-                        "conversations": [
                             {
-                                "conversationItems": [
-                                    {
-                                        "id": "1",
-                                        "participantId": "0",
-                                        "modality": "transcript",
-                                        "text": "It is john doe.",
-                                        "lexical": "It is john doe",
-                                        "itn": "It is john doe",
-                                        "maskedItn": "It is john doe"
-                                    },
-                                    {
-                                        "id": "2",
-                                        "participantId": "1",
-                                        "modality": "transcript",
-                                        "text": "Yes, 633-27-8199 is my phone",
-                                        "lexical": "yes six three three two seven eight one nine nine is my phone",
-                                        "itn": "yes 633278199 is my phone",
-                                        "maskedItn": "yes 633278199 is my phone",
-                                    },
-                                    {
-                                        "id": "3",
-                                        "participantId": "1",
-                                        "modality": "transcript",
-                                        "text": "j.doe@yahoo.com is my email",
-                                        "lexical": "j dot doe at yahoo dot com is my email",
-                                        "maskedItn": "j.doe@yahoo.com is my email",
-                                        "itn": "j.doe@yahoo.com is my email",
-                                    }
-                                ],
+                                "id": "2",
+                                "participantId": "1",
                                 "modality": "transcript",
-                                "id": "1",
-                                "language": "en"
+                                "text": "Yes, 633-27-8199 is my phone",
+                                "lexical": "yes six three three two seven eight one nine nine is my phone",
+                                "itn": "yes 633278199 is my phone",
+                                "maskedItn": "yes 633278199 is my phone",
+                            },
+                            {
+                                "id": "3",
+                                "participantId": "1",
+                                "modality": "transcript",
+                                "text": "j.doe@yahoo.com is my email",
+                                "lexical": "j dot doe at yahoo dot com is my email",
+                                "maskedItn": "j.doe@yahoo.com is my email",
+                                "itn": "j.doe@yahoo.com is my email",
                             }
+                        ],
+                        "modality": "transcript",
+                        "id": "1",
+                        "language": "en"
+                    }
+                ]
+            },
+            "tasks": [
+                {
+                    "kind": "ConversationalPIITask",
+                    "parameters": {
+                        "redactionSource": "lexical",
+                        "piiCategories": [
+                            "all"
                         ]
-                    },
-                    "tasks": [
-                        {
-                            "kind": "ConversationalPIITask",
-                            "parameters": {
-                                "redactionSource": "lexical",
-                                "piiCategories": [
-                                    "all"
-                                ]
-                            }
-                        }
-                    ]
+                    }
                 }
-            )
-            # view result
-            result = poller.result()
-            task_result = result["tasks"]["items"][0]
-            print("... view task status ...")
-            print("status: {}".format(task_result["status"]))
-            conv_pii_result = task_result["results"]
-            if conv_pii_result["errors"]:
-                print("... errors occured ...")
-                for error in conv_pii_result["errors"]:
-                    print(error)
-            else:
-                conversation_result = conv_pii_result["conversations"][0]
-                if conversation_result["warnings"]:
-                    print("... view warnings ...")
-                    for warning in conversation_result["warnings"]:
-                        print(warning)
-                else:
-                    print("... view task result ...")
-                    for conversation in conversation_result["conversationItems"]:
-                        print("conversation id: {}".format(conversation["id"]))
-                        print("... entities ...")
-                        for entity in conversation["entities"]:
-                            print("text: {}".format(entity["text"]))
-                            print("category: {}".format(entity["category"]))
-                            print("confidence: {}".format(entity["confidenceScore"]))
-                            print("offset: {}".format(entity["offset"]))
-                            print("length: {}".format(entity["length"]))
-        ```
-        
-        ### Import a Conversation Project
-        This sample shows a common scenario for the authoring part of the SDK
-        
-        ```python
-        import os
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations.authoring import ConversationAuthoringClient
-        
-        clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
-        clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
-        
-        project_name = "test_project"
-        
-        exported_project_assets = {
-            "projectKind": "Conversation",
-            "intents": [{"category": "Read"}, {"category": "Delete"}],
-            "entities": [{"category": "Sender"}],
-            "utterances": [
-                {
-                    "text": "Open Blake's email",
-                    "dataset": "Train",
-                    "intent": "Read",
-                    "entities": [{"category": "Sender", "offset": 5, "length": 5}],
-                },
-                {
-                    "text": "Delete last email",
-                    "language": "en-gb",
-                    "dataset": "Test",
-                    "intent": "Delete",
-                    "entities": [],
-                },
-            ],
+            ]
         }
-        
-        client = ConversationAuthoringClient(
-            clu_endpoint, AzureKeyCredential(clu_key)
-        )
-        poller = client.begin_import_project(
-            project_name=project_name,
-            project={
-                "assets": exported_project_assets,
-                "metadata": {
-                    "projectKind": "Conversation",
-                    "settings": {"confidenceThreshold": 0.7},
-                    "projectName": "EmailApp",
-                    "multilingual": True,
-                    "description": "Trying out CLU",
-                    "language": "en-us",
-                },
-                "projectFileVersion": "2022-05-01",
-            },
-        )
-        response = poller.result()
-        print(response)
-        
-        ```
-        
-        
-        ## Optional Configuration
-        
-        Optional keyword arguments can be passed in at the client and per-operation level. The azure-core [reference documentation][azure_core_ref_docs] describes available configurations for retries, logging, transport protocols, and more.
-        
-        ## Troubleshooting
-        
-        ### General
-        
-        The Conversations client will raise exceptions defined in [Azure Core][azure_core_exceptions].
-        
-        ### Logging
-        
-        This library uses the standard
-        [logging][python_logging] library for logging.
-        Basic information about HTTP sessions (URLs, headers, etc.) is logged at INFO
-        level.
-        
-        Detailed DEBUG level logging, including request/response bodies and unredacted
-        headers, can be enabled on a client with the `logging_enable` argument.
-        
-        See full SDK logging documentation with examples [here][sdk_logging_docs].
-        
-        ```python
-        import sys
-        import logging
-        from azure.core.credentials import AzureKeyCredential
-        from azure.ai.language.conversations import ConversationAnalysisClient
-        
-        # Create a logger for the 'azure' SDK
-        logger = logging.getLogger('azure')
-        logger.setLevel(logging.DEBUG)
-        
-        # Configure a console output
-        handler = logging.StreamHandler(stream=sys.stdout)
-        logger.addHandler(handler)
-        
-        endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
-        credential = AzureKeyCredential("<my-api-key>")
-        
-        # This client will log detailed information about its HTTP sessions, at DEBUG level
-        client = ConversationAnalysisClient(endpoint, credential, logging_enable=True)
-        result = client.analyze_conversation(...)
-        ```
-        
-        Similarly, `logging_enable` can enable detailed logging for a single operation, even when it isn't enabled for the client:
-        
-        ```python
-        result = client.analyze_conversation(..., logging_enable=True)
-        ```
-        
-        ## Next steps
-        
-        ### More sample code
-        
-        See the [Sample README][conversationallanguage_samples] for several code snippets illustrating common patterns used in the CLU Python API.
-        
-        ## Contributing
-        
-        See the [CONTRIBUTING.md][contributing] for details on building, testing, and contributing to this library.
-        
-        This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit [cla.microsoft.com][cla].
-        
-        When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.
-        
-        This project has adopted the [Microsoft Open Source Code of Conduct][code_of_conduct]. For more information see the [Code of Conduct FAQ][coc_faq] or contact [opencode@microsoft.com][coc_contact] with any additional questions or comments.
-        
-        <!-- LINKS -->
-        [azure_cli]: https://docs.microsoft.com/cli/azure/
-        [azure_portal]: https://portal.azure.com/
-        [azure_subscription]: https://azure.microsoft.com/free/
-        [cla]: https://cla.microsoft.com
-        [coc_contact]: mailto:opencode@microsoft.com
-        [coc_faq]: https://opensource.microsoft.com/codeofconduct/faq/
-        [code_of_conduct]: https://opensource.microsoft.com/codeofconduct/
-        [cognitive_auth]: https://docs.microsoft.com/azure/cognitive-services/authentication/
-        [contributing]: https://github.com/Azure/azure-sdk-for-python/blob/main/CONTRIBUTING.md
-        [python_logging]: https://docs.python.org/3/library/logging.html
-        [sdk_logging_docs]: https://docs.microsoft.com/azure/developer/python/azure-sdk-logging
-        [azure_core_ref_docs]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-core/latest/azure.core.html
-        [azure_core_readme]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
-        [pip_link]:https://pypi.org/project/pip/
-        [conversationallanguage_client_src]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
-        [conversationallanguage_pypi_package]: https://pypi.org/project/azure-ai-language-conversations/
-        [api_reference_documentation]:https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html
-        [conversationallanguage_refdocs]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
-        [conversationallanguage_docs]: https://docs.microsoft.com/azure/cognitive-services/language-service/conversational-language-understanding/overview
-        [conversationallanguage_samples]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/README.md
-        [conversationallanguage_restdocs]: https://docs.microsoft.com/rest/api/language/conversation-analysis-runtime/
-        [conversationallanguage_restdocs_authoring]: https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring
-        [conversationanalysisclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAnalysisClient
-        [conversationauthoringclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAuthoringClient
-        [azure_core_exceptions]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
-        [azure_language_portal]: https://language.cognitive.azure.com/home
-        [cognitive_authentication_aad]: https://docs.microsoft.com/azure/cognitive-services/authentication#authenticate-with-azure-active-directory
-        [azure_identity_credentials]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#credentials
-        [custom_subdomain]: https://docs.microsoft.com/azure/cognitive-services/authentication#create-a-resource-with-a-custom-subdomain
-        [install_azure_identity]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#install-the-package
-        [register_aad_app]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
-        [grant_role_access]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
-        [default_azure_credential]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#defaultazurecredential
-        
-        ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Ftemplate%2Fazure-template%2FREADME.png)
-        
-        
-        # Release History
-        
-        ## 1.1.0b2 (2022-07-01)
-        
-        ### Features Added
-        * Added Azure Active Directory (AAD) authentication support
-        * Added support for authoring operations with `ConversationAuthoringClient` under the `azure.ai.language.conversations.authoring` namespace.
-        
-        ## 1.1.0b1 (2022-05-26)
-        
-        ### Features Added
-        * Conversation summarization task (Long-running operation)
-        * Conversation PII extraction task (Long-running operation)
-        
-        ### Breaking Changes
-        * Client now uses python dictionaries for method parameters and results instead of classes.
-        * Many input and result parameter name changes in `analyze_conversation()` method
-        
-        ## 1.0.0 (2022-06-27)
-        
-        ### Features Added
-        * Added Azure Active Directory (AAD) authentication support
-        * Added more resolution types for entities
-        * Added support for authoring operations with `ConversationAuthoringClient` under the `azure.ai.language.conversations.authoring` namespace.
-        
-        ### Breaking Changes
-        * Client now uses python dictionaries for method parameters and results instead of classes.
-        
-        ## 1.0.0b3 (2022-04-19)
-        
-        ### Features Added
-        * Entity resolutions
-        * Extra features
-        
-        ### Breaking Changes
-        * The `ConversationAnalysisOptions` model used as input to the `analyze_conversation` operation is now wrapped in a `CustomConversationalTask` which combines the analysis options with the project parameters into a single model.
-        * The `query` within the `ConversationAnalysisOptions` is now further qualified as a `TextConversationItem` with additional properties.
-        * The output `AnalyzeConversationResult` is now wrapped in a `CustomConversationalTaskResult` according to the input model.
-        
-        ### Other Changes
-        * Python 2.7 is no longer supported. Please use Python version 3.6 or later.
-        
-        ## 1.0.0b1 (2021-11-03)
-        
-        ### Features Added
-        * Initial release
-        
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.6
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: License :: OSI Approved :: MIT License
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
+    )
+    # view result
+    result = poller.result()
+    task_result = result["tasks"]["items"][0]
+    print("... view task status ...")
+    print("status: {}".format(task_result["status"]))
+    conv_pii_result = task_result["results"]
+    if conv_pii_result["errors"]:
+        print("... errors occurred ...")
+        for error in conv_pii_result["errors"]:
+            print(error)
+    else:
+        conversation_result = conv_pii_result["conversations"][0]
+        if conversation_result["warnings"]:
+            print("... view warnings ...")
+            for warning in conversation_result["warnings"]:
+                print(warning)
+        else:
+            print("... view task result ...")
+            for conversation in conversation_result["conversationItems"]:
+                print("conversation id: {}".format(conversation["id"]))
+                print("... entities ...")
+                for entity in conversation["entities"]:
+                    print("text: {}".format(entity["text"]))
+                    print("category: {}".format(entity["category"]))
+                    print("confidence: {}".format(entity["confidenceScore"]))
+                    print("offset: {}".format(entity["offset"]))
+                    print("length: {}".format(entity["length"]))
+```
+
+
+### Conversational Sentiment Analysis
+
+Analyze sentiment in conversations.
+
+```python
+# import libraries
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+# get secrets
+endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+key = os.environ["AZURE_CONVERSATIONS_KEY"]
+# analyze query
+client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
+
+with client:
+    poller = client.begin_conversation_analysis(
+        task={
+          "displayName": "Sentiment Analysis from a call center conversation",
+          "analysisInput": {
+            "conversations": [
+              {
+                "id": "1",
+                "language": "en",
+                "modality": "transcript",
+                "conversationItems": [
+                  {
+                    "participantId": "1",
+                    "id": "1",
+                    "text": "I like the service. I do not like the food",
+                    "lexical": "i like the service i do not like the food",
+                  }
+                ]
+              }
+            ]
+          },
+          "tasks": [
+            {
+              "taskName": "Conversation Sentiment Analysis",
+              "kind": "ConversationalSentimentTask",
+              "parameters": {
+                "modelVersion": "latest",
+                "predictionSource": "text"
+              }
+            }
+          ]
+        }
+    )
+
+    result = poller.result()
+    task_result = result["tasks"]["items"][0]
+    print("... view task status ...")
+    print(f"status: {task_result['status']}")
+    conv_sentiment_result = task_result["results"]
+    if conv_sentiment_result["errors"]:
+        print("... errors occurred ...")
+        for error in conv_sentiment_result["errors"]:
+            print(error)
+    else:
+        conversation_result = conv_sentiment_result["conversations"][0]
+        if conversation_result["warnings"]:
+            print("... view warnings ...")
+            for warning in conversation_result["warnings"]:
+                print(warning)
+        else:
+            print("... view task result ...")
+            for conversation in conversation_result["conversationItems"]:
+                print(f"Participant ID: {conversation['participantId']}")
+                print(f"Sentiment: {conversation['sentiment']}")
+                print(f"confidenceScores: {conversation['confidenceScores']}")
+```
+
+
+### Import a Conversation Project
+This sample shows a common scenario for the authoring part of the SDK
+
+```python
+import os
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations.authoring import ConversationAuthoringClient
+
+clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+
+project_name = "test_project"
+
+exported_project_assets = {
+    "projectKind": "Conversation",
+    "intents": [{"category": "Read"}, {"category": "Delete"}],
+    "entities": [{"category": "Sender"}],
+    "utterances": [
+        {
+            "text": "Open Blake's email",
+            "dataset": "Train",
+            "intent": "Read",
+            "entities": [{"category": "Sender", "offset": 5, "length": 5}],
+        },
+        {
+            "text": "Delete last email",
+            "language": "en-gb",
+            "dataset": "Test",
+            "intent": "Delete",
+            "entities": [],
+        },
+    ],
+}
+
+client = ConversationAuthoringClient(
+    clu_endpoint, AzureKeyCredential(clu_key)
+)
+poller = client.begin_import_project(
+    project_name=project_name,
+    project={
+        "assets": exported_project_assets,
+        "metadata": {
+            "projectKind": "Conversation",
+            "settings": {"confidenceThreshold": 0.7},
+            "projectName": "EmailApp",
+            "multilingual": True,
+            "description": "Trying out CLU",
+            "language": "en-us",
+        },
+        "projectFileVersion": "2022-05-01",
+    },
+)
+response = poller.result()
+print(response)
+
+```
+
+
+## Optional Configuration
+
+Optional keyword arguments can be passed in at the client and per-operation level. The azure-core [reference documentation][azure_core_ref_docs] describes available configurations for retries, logging, transport protocols, and more.
+
+## Troubleshooting
+
+### General
+
+The Conversations client will raise exceptions defined in [Azure Core][azure_core_exceptions].
+
+### Logging
+
+This library uses the standard
+[logging][python_logging] library for logging.
+Basic information about HTTP sessions (URLs, headers, etc.) is logged at INFO
+level.
+
+Detailed DEBUG level logging, including request/response bodies and unredacted
+headers, can be enabled on a client with the `logging_enable` argument.
+
+See full SDK logging documentation with examples [here][sdk_logging_docs].
+
+```python
+import sys
+import logging
+from azure.core.credentials import AzureKeyCredential
+from azure.ai.language.conversations import ConversationAnalysisClient
+
+# Create a logger for the 'azure' SDK
+logger = logging.getLogger('azure')
+logger.setLevel(logging.DEBUG)
+
+# Configure a console output
+handler = logging.StreamHandler(stream=sys.stdout)
+logger.addHandler(handler)
+
+endpoint = "https://<my-custom-subdomain>.cognitiveservices.azure.com/"
+credential = AzureKeyCredential("<my-api-key>")
+
+# This client will log detailed information about its HTTP sessions, at DEBUG level
+client = ConversationAnalysisClient(endpoint, credential, logging_enable=True)
+result = client.analyze_conversation(...)
+```
+
+Similarly, `logging_enable` can enable detailed logging for a single operation, even when it isn't enabled for the client:
+
+```python
+result = client.analyze_conversation(..., logging_enable=True)
+```
+
+## Next steps
+
+### More sample code
+
+See the [Sample README][conversationallanguage_samples] for several code snippets illustrating common patterns used in the CLU Python API.
+
+## Contributing
+
+See the [CONTRIBUTING.md][contributing] for details on building, testing, and contributing to this library.
+
+This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit [cla.microsoft.com][cla].
+
+When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.
+
+This project has adopted the [Microsoft Open Source Code of Conduct][code_of_conduct]. For more information see the [Code of Conduct FAQ][coc_faq] or contact [opencode@microsoft.com][coc_contact] with any additional questions or comments.
+
+<!-- LINKS -->
+[azure_cli]: https://docs.microsoft.com/cli/azure/
+[azure_portal]: https://portal.azure.com/
+[azure_subscription]: https://azure.microsoft.com/free/
+[cla]: https://cla.microsoft.com
+[coc_contact]: mailto:opencode@microsoft.com
+[coc_faq]: https://opensource.microsoft.com/codeofconduct/faq/
+[code_of_conduct]: https://opensource.microsoft.com/codeofconduct/
+[cognitive_auth]: https://docs.microsoft.com/azure/cognitive-services/authentication/
+[contributing]: https://github.com/Azure/azure-sdk-for-python/blob/main/CONTRIBUTING.md
+[python_logging]: https://docs.python.org/3/library/logging.html
+[sdk_logging_docs]: https://docs.microsoft.com/azure/developer/python/azure-sdk-logging
+[azure_core_ref_docs]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-core/latest/azure.core.html
+[azure_core_readme]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
+[pip_link]:https://pypi.org/project/pip/
+[conversationallanguage_client_src]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
+[conversationallanguage_pypi_package]: https://pypi.org/project/azure-ai-language-conversations/
+[api_reference_documentation]:https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html
+[conversationallanguage_refdocs]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations
+[conversationallanguage_docs]: https://docs.microsoft.com/azure/cognitive-services/language-service/conversational-language-understanding/overview
+[conversationallanguage_samples]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/README.md
+[conversationallanguage_restdocs]: https://learn.microsoft.com/rest/api/language/
+[conversationanalysisclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAnalysisClient
+[conversationauthoringclient_class]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html#azure.ai.language.conversations.ConversationAuthoringClient
+[azure_core_exceptions]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/README.md
+[azure_language_portal]: https://language.cognitive.azure.com/home
+[cognitive_authentication_aad]: https://docs.microsoft.com/azure/cognitive-services/authentication#authenticate-with-azure-active-directory
+[azure_identity_credentials]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#credentials
+[custom_subdomain]: https://docs.microsoft.com/azure/cognitive-services/authentication#create-a-resource-with-a-custom-subdomain
+[install_azure_identity]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#install-the-package
+[register_aad_app]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
+[grant_role_access]: https://docs.microsoft.com/azure/cognitive-services/authentication#assign-a-role-to-a-service-principal
+[default_azure_credential]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity#defaultazurecredential
+[conversationanalysis_restdocs]: https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime
+[conversationanalysis_restdocs_authoring]: https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring
+
+![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Ftemplate%2Fazure-template%2FREADME.png)
+
+
+# Release History
+
+## 1.1.0b3 (2022-11-10)
+
+### Features Added
+- Added support for the "ConversationalSentimentTask" kind with `begin_conversation_analysis`.
+- Added support for "chapterTitle" and "narrative" `summaryAspects` options for ConversationalSummarizationTasks.
+- Added methods to the `ConversationAuthoringClient` to manage deployment resources:
+  - `begin_assign_deployment_resources`
+  - `get_assign_deployment_resources_status`
+  - `begin_unassign_deployment_resources`
+  - `get_unassign_deployment_resources_status`
+  - `begin_delete_deployment_from_resources`
+  - `get_deployment_delete_from_resources_status`
+  - `begin_load_snapshot`
+  - `get_load_snapshot_status`
+  - `list_assigned_resource_deployments`
+  - `list_deployment_resources`
+- Added optional `trained_model_label` keyword argument to `begin_export_project`.
+
+### Other Changes
+* This version and all future versions will require Python 3.7+. Python 3.6 is no longer supported.
+
+## 1.1.0b2 (2022-07-01)
+
+### Features Added
+* Added Azure Active Directory (AAD) authentication support
+* Added support for authoring operations with `ConversationAuthoringClient` under the `azure.ai.language.conversations.authoring` namespace.
+
+## 1.0.0 (2022-06-27)
+
+### Features Added
+* Added Azure Active Directory (AAD) authentication support
+* Added more resolution types for entities
+* Added support for authoring operations with `ConversationAuthoringClient` under the `azure.ai.language.conversations.authoring` namespace.
+
+### Breaking Changes
+* Client now uses python dictionaries for method parameters and results instead of classes.
+
+## 1.1.0b1 (2022-05-26)
+
+### Features Added
+* Conversation summarization task (Long-running operation)
+* Conversation PII extraction task (Long-running operation)
+
+### Breaking Changes
+* Client now uses python dictionaries for method parameters and results instead of classes.
+* Many input and result parameter name changes in `analyze_conversation()` method
+
+## 1.0.0b3 (2022-04-19)
+
+### Features Added
+* Entity resolutions
+* Extra features
+
+### Breaking Changes
+* The `ConversationAnalysisOptions` model used as input to the `analyze_conversation` operation is now wrapped in a `CustomConversationalTask` which combines the analysis options with the project parameters into a single model.
+* The `query` within the `ConversationAnalysisOptions` is now further qualified as a `TextConversationItem` with additional properties.
+* The output `AnalyzeConversationResult` is now wrapped in a `CustomConversationalTaskResult` according to the input model.
+
+### Other Changes
+* Python 2.7 is no longer supported. Please use Python version 3.6 or later.
+
+## 1.0.0b1 (2021-11-03)
+
+### Features Added
+* Initial release
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_qna_response.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_qna_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -58,28 +58,28 @@
                     "deploymentName": deployment_name,
                     "verbose": True
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
     # top intent
     top_intent = result["result"]["prediction"]["topIntent"]
-    print("top intent: {}".format(top_intent))
+    print(f"top intent: {top_intent}")
     top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-    print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-    print("project kind: {}".format(top_intent_object["targetProjectKind"]))
+    print(f"confidence score: {top_intent_object['confidenceScore']}")
+    print(f"project kind: {top_intent_object['targetProjectKind']}")
 
     if top_intent_object["targetProjectKind"] == "QuestionAnswering":
         print("\nview qna result:")
         qna_result = top_intent_object["result"]
         for answer in qna_result["answers"]:
-            print("\nanswer: {}".format(answer["answer"]))
-            print("answer: {}".format(answer["confidenceScore"]))
+            print(f"\nanswer: {answer['answer']}")
+            print(f"answer: {answer['confidenceScore']}")
 
     # [END analyze_orchestration_app_qna_response]
 
 if __name__ == '__main__':
     sample_analyze_orchestration_app_qna_response()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/sample_conv_pii_transcript_input.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/sample_conv_pii_transcript_input_async.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,46 +1,48 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
 """
-FILE: sample_conv_pii_transcript_input.py
+FILE: sample_conv_pii_transcript_input_async.py
 
 DESCRIPTION:
     This sample demonstrates how to analyze a conversation for PII (personally identifiable information).
 
     For more info about how to setup a CLU conversation project, see the README.
 
 USAGE:
-    python sample_conv_pii_transcript_input.py
+    python sample_conv_pii_transcript_input_async.py
 
     Set the environment variables with your own values before running the sample:
     1) AZURE_CONVERSATIONS_ENDPOINT                       - endpoint for your CLU resource.
     2) AZURE_CONVERSATIONS_KEY                            - API key for your CLU resource.
 """
 
-def sample_conv_pii_transcript_input():
+import asyncio
+
+async def sample_conv_pii_transcript_input_async():
     # [START analyze_conversation_app]
     # import libraries
     import os
     from azure.core.credentials import AzureKeyCredential
 
-    from azure.ai.language.conversations import ConversationAnalysisClient
+    from azure.ai.language.conversations.aio import ConversationAnalysisClient
 
     # get secrets
     endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     key = os.environ["AZURE_CONVERSATIONS_KEY"]
 
     # analyze quey
     client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-    with client:
+    async with client:
 
-        poller = client.begin_conversation_analysis(
+        poller = await client.begin_conversation_analysis(
             task={
                 "displayName": "Analyze PII in conversation",
                 "analysisInput": {
                     "conversations": [
                         {
                             "conversationItems": [
                                 {
@@ -88,40 +90,43 @@
                         }
                     }
                 ]
             }
         )
 
         # view result
-        result = poller.result()
-        task_result = result["tasks"]["items"][0]
+        result = await poller.result()
+        task_result = result['tasks']['items'][0]
         print("... view task status ...")
-        print("status: {}".format(task_result["status"]))
-        conv_pii_result = task_result["results"]
-        if conv_pii_result["errors"]:
-            print("... errors occured ...")
-            for error in conv_pii_result["errors"]:
+        print(f"status: {task_result['status']}")
+        conv_pii_result = task_result['results']
+        if conv_pii_result['errors']:
+            print("... errors occurred ...")
+            for error in conv_pii_result['errors']:
                 print(error)
         else:
-            conversation_result = conv_pii_result["conversations"][0]
-            if conversation_result["warnings"]:
+            conversation_result = conv_pii_result['conversations'][0]
+            if conversation_result['warnings']:
                 print("... view warnings ...")
-                for warning in conversation_result["warnings"]:
+                for warning in conversation_result['warnings']:
                     print(warning)
             else:
                 print("... view task result ...")
-                for conversation in conversation_result["conversationItems"]:
-                    print("conversation id: {}".format(conversation["id"]))
+                for conversation in conversation_result['conversationItems']:
+                    print(f"conversation id: {conversation['id']}")
                     print("... entities ...")
-                    for entity in conversation["entities"]:
-                        print("text: {}".format(entity["text"]))
-                        print("category: {}".format(entity["category"]))
-                        print("confidence: {}".format(entity["confidenceScore"]))
-                        print("offset: {}".format(entity["offset"]))
-                        print("length: {}".format(entity["length"]))
+                    for entity in conversation['entities']:
+                        print(f"text: {entity['text']}")
+                        print(f"category: {entity['category']}")
+                        print(f"confidence: {entity['confidenceScore']}")
+                        print(f"offset: {entity['offset']}")
+                        print(f"length: {entity['length']}")
 
 
     # [END analyze_conversation_app]
 
 
+async def main():
+    await sample_conv_pii_transcript_input_async()
+
 if __name__ == '__main__':
-    sample_conv_pii_transcript_input()
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_conversation_app.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_conversation_app.py`

 * *Files 18% similar despite different names*

```diff
@@ -58,38 +58,38 @@
                     "deploymentName": deployment_name,
                     "verbose": True
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
-    print("top intent: {}".format(result["result"]["prediction"]["topIntent"]))
-    print("category: {}".format(result["result"]["prediction"]["intents"][0]["category"]))
-    print("confidence score: {}\n".format(result["result"]["prediction"]["intents"][0]["confidenceScore"]))
+    print(f"top intent: {result['result']['prediction']['topIntent']}")
+    print(f"category: {result['result']['prediction']['intents'][0]['category']}")
+    print(f"confidence score: {result['result']['prediction']['intents'][0]['confidenceScore']}\n")
 
     print("entities:")
-    for entity in result["result"]["prediction"]["entities"]:
-        print("\ncategory: {}".format(entity["category"]))
-        print("text: {}".format(entity["text"]))
-        print("confidence score: {}".format(entity["confidenceScore"]))
+    for entity in result['result']['prediction']['entities']:
+        print(f"\ncategory: {entity['category']}")
+        print(f"text: {entity['text']}")
+        print(f"confidence score: {entity['confidenceScore']}")
         if "resolutions" in entity:
             print("resolutions")
-            for resolution in entity["resolutions"]:
-                print("kind: {}".format(resolution["resolutionKind"]))
-                print("value: {}".format(resolution["value"]))
+            for resolution in entity['resolutions']:
+                print(f"kind: {resolution['resolutionKind']}")
+                print(f"value: {resolution['value']}")
         if "extraInformation" in entity:
             print("extra info")
-            for data in entity["extraInformation"]:
-                print("kind: {}".format(data["extraInformationKind"]))
-                if data["extraInformationKind"] == "ListKey":
-                    print("key: {}".format(data["key"]))
-                if data["extraInformationKind"] == "EntitySubtype":
-                    print("value: {}".format(data["value"]))
+            for data in entity['extraInformation']:
+                print(f"kind: {data['extraInformationKind']}")
+                if data['extraInformationKind'] == "ListKey":
+                    print(f"key: {data['key']}")
+                if data['extraInformationKind'] == "EntitySubtype":
+                    print(f"value: {data['value']}")
 
     # [END analyze_conversation_app]
 
 
 if __name__ == '__main__':
     sample_analyze_conversation_app()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/sample_conv_summarization.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_conv_summarization.py`

 * *Files 14% similar despite different names*

```diff
@@ -28,81 +28,91 @@
 
     from azure.ai.language.conversations import ConversationAnalysisClient
 
     # get secrets
     endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     key = os.environ["AZURE_CONVERSATIONS_KEY"]
 
-    # analyze quey
+    # analyze query
     client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
     with client:
         poller = client.begin_conversation_analysis(
             task={
                 "displayName": "Analyze conversations from xxx",
                 "analysisInput": {
                     "conversations": [
                         {
                             "conversationItems": [
                                 {
                                     "text": "Hello, how can I help you?",
                                     "modality": "text",
                                     "id": "1",
+                                    "role": "Agent",
                                     "participantId": "Agent"
                                 },
                                 {
                                     "text": "How to upgrade Office? I am getting error messages the whole day.",
                                     "modality": "text",
                                     "id": "2",
+                                    "role": "Customer",
                                     "participantId": "Customer"
                                 },
                                 {
                                     "text": "Press the upgrade button please. Then sign in and follow the instructions.",
                                     "modality": "text",
                                     "id": "3",
+                                    "role": "Agent",
                                     "participantId": "Agent"
                                 }
                             ],
                             "modality": "text",
                             "id": "conversation1",
                             "language": "en"
                         },
                     ]
                 },
                 "tasks": [
                     {
-                        "taskName": "analyze 1",
+                        "taskName": "Issue task",
                         "kind": "ConversationalSummarizationTask",
                         "parameters": {
-                            "summaryAspects": ["Issue, Resolution"]
+                            "summaryAspects": ["issue"]
                         }
-                    }
+                    },
+                    {
+                        "taskName": "Resolution task",
+                        "kind": "ConversationalSummarizationTask",
+                        "parameters": {
+                            "summaryAspects": ["resolution"]
+                        }
+                    },
                 ]
             }
         )
 
         # view result
         result = poller.result()
-        task_result = result["tasks"]["items"][0]
-        print("... view task status ...")
-        print("status: {}".format(task_result["status"]))
-        resolution_result = task_result["results"]
-        if resolution_result["errors"]:
-            print("... errors occured ...")
-            for error in resolution_result["errors"]:
-                print(error)
-        else:
-            conversation_result = resolution_result["conversations"][0]
-            if conversation_result["warnings"]:
-                print("... view warnings ...")
-                for warning in conversation_result["warnings"]:
-                    print(warning)
+        task_results = result["tasks"]["items"]
+        for task in task_results:
+            print(f"\n{task['taskName']} status: {task['status']}")
+            task_result = task["results"]
+            if task_result["errors"]:
+                print("... errors occurred ...")
+                for error in task_result["errors"]:
+                    print(error)
             else:
-                summaries = conversation_result["summaries"]
-                print("... view task result ...")
-                print("issue: {}".format(summaries[0]["text"]))
-                print("resolution: {}".format(summaries[1]["text"]))
+                conversation_result = task_result["conversations"][0]
+                if conversation_result["warnings"]:
+                    print("... view warnings ...")
+                    for warning in conversation_result["warnings"]:
+                        print(warning)
+                else:
+                    summaries = conversation_result["summaries"]
+                    print("... view task result ...")
+                    for summary in summaries:
+                        print(f"{summary['aspect']}: {summary['text']}")
 
     # [END analyze_conversation_app]
 
 
 if __name__ == '__main__':
     sample_conv_summarization()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/README.md` & `azure-ai-language-conversations-1.1.0b3/samples/README.md`

 * *Files 17% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 ---
 page_type: sample
 languages:
   - python
 products:
   - azure
   - azure-cognitive-services
-  - azure-language-service
+  - language-service
 urlFragment: conversationslanguageunderstanding-samples
 ---
 
 # Samples for Azure Conversational Language Understanding client library for Python
 
 These code samples show common scenario operations with the Azure Conversational Language Understanding client library.
 
@@ -23,19 +23,21 @@
 |-|-|
 |[sample_analyze_conversation_app.py][sample_analyze_conversation_app] and [sample_analyze_conversation_app_async.py][sample_analyze_conversation_app_async] | Analyze intents and entities in your utterance using a conversation project. |
 | [sample_analyze_orchestration_app_conv_response.py][sample_analyze_orchestration_app_conv_response] and [sample_analyze_orchestration_app_conv_response_async.py][sample_analyze_orchestration_app_conv_response_async]| Analyze user utterance using an orchestration project, which selects the best candidate from one of your different apps to analyze user query (ex: Qna, Conversation, and Luis). In this case, it uses a conversation project. |
 | [sample_analyze_orchestration_app_luis_response.py][sample_analyze_orchestration_app_luis_response] and [sample_analyze_orchestration_app_luis_response_async.py][sample_analyze_orchestration_app_luis_response_async]| Analyze user utterance using an orchestration project, which selects the best candidate from one of your different apps to analyze user query (ex: Qna, Conversation, and Luis). In this case, it uses a Luis project. |
 | [sample_analyze_orchestration_app_qna_response.py][sample_analyze_orchestration_app_qna_response] and [sample_analyze_orchestration_app_qna_response_async.py][sample_analyze_orchestration_app_qna_response_async]| Analyze user utterance using an orchestration project, which selects the best candidate from one of your different apps to analyze user query (ex: Qna, Conversation, and Luis). In this case, it uses a Qna project. |
 | [sample_conv_summarization.py][sample_conv_summarization] and [sample_conv_summarization_async.py][sample_conv_summarization_async]| Summarize conversation in the form of issues and resolutions (ex: tech support conversation) |
 | [sample_conv_pii_transcript_input.py][sample_conv_pii_transcript_input] and [sample_conv_pii_transcript_input_async.py][sample_conv_pii_transcript_input_async]| Extract and redact personally-identifiable info from/in conversations |
-
+| [sample_conv_sentiment.py][sample_conv_sentiment] and [sample_conv_sentiment_async.py][sample_conv_sentiment_async]| Analyze sentiment in conversations |
+| [sample_manage_projects.py][sample_manage_projects] and [sample_manage_projects_async.py][sample_manage_projects_async]| Shows common authoring operations on projects. |
+| [sample_assign_deployment_resources.py][sample_assign_deployment_resources] and [sample_assign_deployment_resources_async.py][sample_assign_deployment_resources_async]| Assign deployment resources to a project and deploy a project to specific deployment resources |
 
 ## Prerequisites
 
-- Python 3.6 or later is required to use this package.
+- Python 3.7 or later is required to use this package.
 - You must have an [Azure subscription][azure_subscription] and an
   [Azure CLU account][azure_clu_account] to run these samples.
 
 ## Setup
 
 1. Install the Azure Conversational Language Understanding client library for Python with [pip][pip]:
 
@@ -82,9 +84,18 @@
 
 [sample_conv_summarization]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/sample_conv_summarization.py
 [sample_conv_summarization_async]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/async/sample_conv_summarization_async.py
 
 [sample_conv_pii_transcript_input]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/sample_conv_pii_transcript_input.py
 [sample_conv_pii_transcript_input_async]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/async/sample_conv_pii_transcript_input_async.py
 
+[sample_assign_deployment_resources]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/authoring/sample_assign_deployment_resources.py
+[sample_assign_deployment_resources_async]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/async/authoring/sample_assign_deployment_resources_async.py
+
+[sample_conv_sentiment]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/sample_conv_sentiment.py
+[sample_conv_sentiment_async]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/async/sample_conv_sentiment_async.py
+
+[sample_manage_projects]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/authoring/sample_manage_projects.py
+[sample_manage_projects_async]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations/samples/async/authoring/sample_manage_projects_async.py
+
 [api_reference_documentation]: https://azuresdkdocs.blob.core.windows.net/$web/python/azure-ai-language-conversations/latest/azure.ai.language.conversations.html
 [versioning_story_readme]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/cognitivelanguage/azure-ai-language-conversations#install-the-package
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_luis_response.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_luis_response.py`

 * *Files 7% similar despite different names*

```diff
@@ -58,29 +58,29 @@
                     "deploymentName": deployment_name,
                     "verbose": True
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
     # top intent
     top_intent = result["result"]["prediction"]["topIntent"]
-    print("top intent: {}".format(top_intent))
+    print(f"top intent: {top_intent}")
     top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-    print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-    print("project kind: {}".format(top_intent_object["targetProjectKind"]))
+    print(f"confidence score: {top_intent_object['confidenceScore']}")
+    print(f"project kind: {top_intent_object['targetProjectKind']}")
 
     if top_intent_object["targetProjectKind"] == "Luis":
         print("\nluis response:")
         luis_response = top_intent_object["result"]["prediction"]
-        print("top intent: {}".format(luis_response["topIntent"]))
+        print(f"top intent: {luis_response['topIntent']}")
         print("\nentities:")
         for entity in luis_response["entities"]:
-            print("\n{}".format(entity))
+            print(f"\n{entity}")
 
     # [END analyze_orchestration_app_luis_response]
 
 if __name__ == '__main__':
     sample_analyze_orchestration_app_luis_response()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/sample_authentication.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_authentication.py`

 * *Files identical despite different names*

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_direct_target.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_direct_target.py`

 * *Files 26% similar despite different names*

```diff
@@ -68,28 +68,28 @@
                         }
                     }
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
     # top intent
     top_intent = result["result"]["prediction"]["topIntent"]
-    print("top intent: {}".format(top_intent))
+    print(f"top intent: {top_intent}")
     top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-    print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-    print("project kind: {}".format(top_intent_object["targetProjectKind"]))
+    print(f"confidence score: {top_intent_object['confidenceScore']}")
+    print(f"project kind: {top_intent_object['targetProjectKind']}")
 
     if top_intent_object["targetProjectKind"] == "QuestionAnswering":
         print("\nview qna result:")
         qna_result = top_intent_object["result"]
         for answer in qna_result["answers"]:
-            print("\nanswer: {}".format(answer["answer"]))
-            print("answer: {}".format(answer["confidenceScore"]))
+            print(f"\nanswer: {answer['answer']}")
+            print(f"answer: {answer['confidenceScore']}")
 
     # [END analyze_orchestration_app_qna_response]
 
 if __name__ == '__main__':
-    sample_analyze_orchestration_direct_target()
+    sample_analyze_orchestration_direct_target()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/sample_analyze_orchestration_app_conv_response.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_analyze_orchestration_app_conv_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -58,48 +58,48 @@
                     "deploymentName": deployment_name,
                     "verbose": True
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
     # top intent
     top_intent = result["result"]["prediction"]["topIntent"]
-    print("top intent: {}".format(top_intent))
+    print(f"top intent: {top_intent}")
     top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-    print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-    print("project kind: {}".format(top_intent_object["targetProjectKind"]))
+    print(f"confidence score: {top_intent_object['confidenceScore']}")
+    print(f"project kind: {top_intent_object['targetProjectKind']}")
 
     # conversation result
     if top_intent_object["targetProjectKind"] == "Conversation":
         print("\nview conversation result:")
 
-        print("\ntop intent: {}".format(top_intent_object["result"]["prediction"]["topIntent"]))
-        print("category: {}".format(top_intent_object["result"]["prediction"]["intents"][0]["category"]))
-        print("confidence score: {}\n".format(top_intent_object["result"]["prediction"]["intents"][0]["confidenceScore"]))
+        print(f"\ntop intent: {top_intent_object['result']['prediction']['topIntent']}")
+        print(f"category: {top_intent_object['result']['prediction']['intents'][0]['category']}")
+        print(f"confidence score: {top_intent_object['result']['prediction']['intents'][0]['confidenceScore']}\n")
 
         print("\nview entities:")
         for entity in top_intent_object["result"]["prediction"]["entities"]:
-            print("\ncategory: {}".format(entity["category"]))
-            print("text: {}".format(entity["text"]))
-            print("confidence score: {}".format(entity["confidenceScore"]))
+            print(f"\ncategory: {entity['category']}")
+            print(f"text: {entity['text']}")
+            print(f"confidence score: {entity['confidenceScore']}")
             if "resolutions" in entity:
                 print("resolutions")
                 for resolution in entity["resolutions"]:
-                    print("kind: {}".format(resolution["resolutionKind"]))
-                    print("value: {}".format(resolution["value"]))
+                    print(f"kind: {resolution['resolutionKind']}")
+                    print(f"value: {resolution['value']}")
             if "extraInformation" in entity:
                 print("extra info")
                 for data in entity["extraInformation"]:
-                    print("kind: {}".format(data["extraInformationKind"]))
+                    print(f"kind: {data['extraInformationKind']}")
                     if data["extraInformationKind"] == "ListKey":
-                        print("key: {}".format(data["key"]))
+                        print(f"key: {data['key']}")
                     if data["extraInformationKind"] == "EntitySubtype":
-                        print("value: {}".format(data["value"]))
+                        print(f"value: {data['value']}")
 
     # [END analyze_orchestration_app_conv_response]
 
 if __name__ == '__main__':
     sample_analyze_orchestration_app_conv_response()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_conversation_app_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_conversation_app_async.py`

 * *Files 16% similar despite different names*

```diff
@@ -60,42 +60,41 @@
                     "deploymentName": deployment_name,
                     "verbose": True
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
-    print("top intent: {}".format(result["result"]["prediction"]["topIntent"]))
-    print("category: {}".format(result["result"]["prediction"]["intents"][0]["category"]))
-    print("confidence score: {}\n".format(result["result"]["prediction"]["intents"][0]["confidenceScore"]))
+    print(f"top intent: {result['result']['prediction']['topIntent']}")
+    print(f"category: {result['result']['prediction']['intents'][0]['category']}")
+    print(f"confidence score: {result['result']['prediction']['intents'][0]['confidenceScore']}\n")
 
     print("entities:")
-    for entity in result["result"]["prediction"]["entities"]:
-        print("\ncategory: {}".format(entity["category"]))
-        print("text: {}".format(entity["text"]))
-        print("confidence score: {}".format(entity["confidenceScore"]))
+    for entity in result['result']['prediction']['entities']:
+        print(f"\ncategory: {entity['category']}")
+        print(f"text: {entity['text']}")
+        print(f"confidence score: {entity['confidenceScore']}")
         if "resolutions" in entity:
             print("resolutions")
-            for resolution in entity["resolutions"]:
-                print("kind: {}".format(resolution["resolutionKind"]))
-                print("value: {}".format(resolution["value"]))
+            for resolution in entity['resolutions']:
+                print(f"kind: {resolution['resolutionKind']}")
+                print(f"value: {resolution['value']}")
         if "extraInformation" in entity:
             print("extra info")
-            for data in entity["extraInformation"]:
-                print("kind: {}".format(data["extraInformationKind"]))
-                if data["extraInformationKind"] == "ListKey":
-                    print("key: {}".format(data["key"]))
-                if data["extraInformationKind"] == "EntitySubtype":
-                    print("value: {}".format(data["value"]))
+            for data in entity['extraInformation']:
+                print(f"kind: {data['extraInformationKind']}")
+                if data['extraInformationKind'] == "ListKey":
+                    print(f"key: {data['key']}")
+                if data['extraInformationKind'] == "EntitySubtype":
+                    print(f"value: {data['value']}")
 
     # [END analyze_conversation_app]
 
 
 async def main():
     await sample_analyze_conversation_app_async()
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_direct_target_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_qna_response_async.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,53 +1,51 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
 """
-FILE: sample_analyze_orchestration_direct_target_async.py
+FILE: sample_analyze_orchestration_app_qna_response_async.py
 
 DESCRIPTION:
     This sample demonstrates how to analyze user query using an orchestration project.
     In this sample, orchestration project's top intent will map to a Qna project.
 
     For more info about how to setup a CLU orchestration project, see the README.
 
 USAGE:
-    python sample_analyze_orchestration_direct_target_async.py
+    python sample_analyze_orchestration_app_qna_response_async.py
 
     Set the environment variables with your own values before running the sample:
     1) AZURE_CONVERSATIONS_ENDPOINT                       - endpoint for your CLU resource.
     2) AZURE_CONVERSATIONS_KEY                            - API key for your CLU resource.
     3) AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME     - project name for your CLU orchestration project.
     4) AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME  - deployment name for your CLU orchestration project.
 """
 
 import asyncio
 
-async def sample_analyze_orchestration_direct_target_async():
+async def sample_analyze_orchestration_app_qna_response_async():
     # [START analyze_orchestration_app_qna_response]
     # import libraries
     import os
     from azure.core.credentials import AzureKeyCredential
-
     from azure.ai.language.conversations.aio import ConversationAnalysisClient
 
     # get secrets
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
     project_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME"]
     deployment_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME"]
 
     # analyze query
     client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
     async with client:
         query = "How are you?"
-        qna_app = "ChitChat-QnA"
         result = await client.analyze_conversation(
             task={
                 "kind": "Conversation",
                 "analysisInput": {
                     "conversationItem": {
                         "participantId": "1",
                         "id": "1",
@@ -56,47 +54,37 @@
                         "text": query
                     },
                     "isLoggingEnabled": False
                 },
                 "parameters": {
                     "projectName": project_name,
                     "deploymentName": deployment_name,
-                    "directTarget": qna_app,
-                    "targetProjectParameters": {
-                        "ChitChat-QnA": {
-                            "targetProjectKind": "QuestionAnswering",
-                            "callingOptions": {
-                                "question": query
-                            }
-                        }
-                    }
+                    "verbose": True
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
     # top intent
-    top_intent = result["result"]["prediction"]["topIntent"]
-    print("top intent: {}".format(top_intent))
-    top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-    print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-    print("project kind: {}".format(top_intent_object["targetProjectKind"]))
+    top_intent = result['result']['prediction']['topIntent']
+    print(f"top intent: {top_intent}")
+    top_intent_object = result['result']['prediction']['intents'][top_intent]
+    print(f"confidence score: {top_intent_object['confidenceScore']}")
+    print(f"project kind: {top_intent_object['targetProjectKind']}")
 
-    if top_intent_object["targetProjectKind"] == "QuestionAnswering":
+    if top_intent_object['targetProjectKind'] == "QuestionAnswering":
         print("\nview qna result:")
-        qna_result = top_intent_object["result"]
-        for answer in qna_result["answers"]:
-            print("\nanswer: {}".format(answer["answer"]))
-            print("answer: {}".format(answer["confidenceScore"]))
+        qna_result = top_intent_object['result']
+        for answer in qna_result['answers']:
+            print(f"\nanswer: {answer['answer']}")
+            print(f"answer: {answer['confidenceScore']}")
 
     # [END analyze_orchestration_app_qna_response]
 
-
 async def main():
-    await sample_analyze_orchestration_direct_target_async()
+    await sample_analyze_orchestration_app_qna_response_async()
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/sample_conv_summarization_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/sample_conv_sentiment_async.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,114 +1,120 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
 """
-FILE: sample_conv_summarization_async.py
+FILE: sample_conv_sentiment_async.py
 
 DESCRIPTION:
-    This sample demonstrates how to analyze a conversation for issue resolution.
+    This sample demonstrates how to analyze a conversation for sentiment analysis.
 
     For more info about how to setup a CLU conversation project, see the README.
 
 USAGE:
-    python sample_conv_summarization_async.py
+    python sample_conv_sentiment_async.py
 
     Set the environment variables with your own values before running the sample:
     1) AZURE_CONVERSATIONS_ENDPOINT                       - endpoint for your CLU resource.
     2) AZURE_CONVERSATIONS_KEY                            - API key for your CLU resource.
 """
 
 import asyncio
 
-async def sample_conv_summarization_async():
-    # [START analyze_conversation_app]
+
+async def sample_conv_sentiment_async():
     # import libraries
     import os
     from azure.core.credentials import AzureKeyCredential
-
     from azure.ai.language.conversations.aio import ConversationAnalysisClient
 
     # get secrets
     endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     key = os.environ["AZURE_CONVERSATIONS_KEY"]
 
-    # analyze quey
+    # analyze query
     client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
     async with client:
+
         poller = await client.begin_conversation_analysis(
             task={
-                "displayName": "Analyze conversations from xxx",
+                "displayName": "Analyze sentiment in conversation",
                 "analysisInput": {
                     "conversations": [
                         {
                             "conversationItems": [
                                 {
-                                    "text": "Hello, how can I help you?",
-                                    "modality": "text",
                                     "id": "1",
-                                    "participantId": "Agent"
+                                    "participantId": "Customer",
+                                    "modality": "transcript",
+                                    "text": "My cat doesn't like the food, Can I get a refund?",
+                                    "lexical": "my cat doesn't like the food can i get a refund",
                                 },
                                 {
-                                    "text": "How to upgrade Office? I am getting error messages the whole day.",
-                                    "modality": "text",
                                     "id": "2",
-                                    "participantId": "Customer"
+                                    "participantId": "Agent",
+                                    "modality": "transcript",
+                                    "text": "Sure. You have been refunded. Have a nice day.",
+                                    "lexical": "sure you have been refunded have a nice day",
                                 },
                                 {
-                                    "text": "Press the upgrade button please. Then sign in and follow the instructions.",
-                                    "modality": "text",
                                     "id": "3",
-                                    "participantId": "Agent"
-                                }
+                                    "participantId": "Customer",
+                                    "modality": "transcript",
+                                    "text": "Thanks for your help",
+                                    "lexical": "thanks for your help",
+                                },
                             ],
-                            "modality": "text",
+                            "modality": "transcript",
                             "id": "conversation1",
-                            "language": "en"
-                        },
+                            "language": "en",
+                        }
                     ]
                 },
                 "tasks": [
                     {
-                        "taskName": "analyze 1",
-                        "kind": "ConversationalSummarizationTask",
+                        "kind": "ConversationalSentimentTask",
                         "parameters": {
-                            "summaryAspects": ["Issue, Resolution"]
-                        }
+                            "modelVersion": "2022-10-01-preview",
+                            "predictionSource": "text",
+                        },
                     }
-                ]
+                ],
             }
         )
 
         # view result
         result = await poller.result()
         task_result = result["tasks"]["items"][0]
         print("... view task status ...")
-        print("status: {}".format(task_result["status"]))
-        resolution_result = task_result["results"]
-        if resolution_result["errors"]:
-            print("... errors occured ...")
-            for error in resolution_result["errors"]:
+        print(f"status: {task_result['status']}")
+        conv_sentiment_result = task_result["results"]
+        if conv_sentiment_result["errors"]:
+            print("... errors occurred ...")
+            for error in conv_sentiment_result["errors"]:
                 print(error)
         else:
-            conversation_result = resolution_result["conversations"][0]
+            conversation_result = conv_sentiment_result["conversations"][0]
             if conversation_result["warnings"]:
                 print("... view warnings ...")
                 for warning in conversation_result["warnings"]:
                     print(warning)
             else:
-                summaries = conversation_result["summaries"]
                 print("... view task result ...")
-                print("issue: {}".format(summaries[0]["text"]))
-                print("resolution: {}".format(summaries[1]["text"]))
-
-    # [END analyze_conversation_app]
+                for conversation_item in conversation_result["conversationItems"]:
+                    confidence_score = conversation_item["confidenceScores"]
+                    print(f"id: {conversation_item['id']}")
+                    print(f"participantId: {conversation_item['participantId']}")
+                    print(f"sentiment: {conversation_item['sentiment']}")
+                    print(
+                        f"confidenceScores: positive={confidence_score['positive']}  "
+                        f"neutral={confidence_score['neutral']}  negative={confidence_score['negative']}"
+                    )
 
 
 async def main():
-    await sample_conv_summarization_async()
+    await sample_conv_sentiment_async()
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/sample_authentication_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/sample_authentication_async.py`

 * *Files 3% similar despite different names*

```diff
@@ -58,9 +58,8 @@
 
 
 async def main():
     await sample_authentication_api_key_async()
     await sample_authentication_with_azure_active_directory()
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_conv_response_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_conv_response_async.py`

 * *Files 12% similar despite different names*

```diff
@@ -60,52 +60,51 @@
                     "deploymentName": deployment_name,
                     "verbose": True
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
     # top intent
-    top_intent = result["result"]["prediction"]["topIntent"]
-    print("top intent: {}".format(top_intent))
-    top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-    print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-    print("project kind: {}".format(top_intent_object["targetProjectKind"]))
+    top_intent = result['result']['prediction']['topIntent']
+    print(f"top intent: {top_intent}")
+    top_intent_object = result['result']['prediction']['intents'][top_intent]
+    print(f"confidence score: {top_intent_object['confidenceScore']}")
+    print(f"project kind: {top_intent_object['targetProjectKind']}")
 
     # conversation result
-    if top_intent_object["targetProjectKind"] == "Conversation":
+    if top_intent_object['targetProjectKind'] == "Conversation":
         print("\nview conversation result:")
 
-        print("\ntop intent: {}".format(top_intent_object["result"]["prediction"]["topIntent"]))
-        print("category: {}".format(top_intent_object["result"]["prediction"]["intents"][0]["category"]))
-        print("confidence score: {}\n".format(top_intent_object["result"]["prediction"]["intents"][0]["confidenceScore"]))
+        print(f"\ntop intent: {top_intent_object['result']['prediction']['topIntent']}")
+        print(f"category: {top_intent_object['result']['prediction']['intents'][0]['category']}")
+        print(f"confidence score: {top_intent_object['result']['prediction']['intents'][0]['confidenceScore']}\n")
 
         print("\nview entities:")
-        for entity in top_intent_object["result"]["prediction"]["entities"]:
-            print("\ncategory: {}".format(entity["category"]))
-            print("text: {}".format(entity["text"]))
-            print("confidence score: {}".format(entity["confidenceScore"]))
+        for entity in top_intent_object['result']['prediction']['entities']:
+            print(f"\ncategory: {entity['category']}")
+            print(f"text: {entity['text']}")
+            print(f"confidence score: {entity['confidenceScore']}")
             if "resolutions" in entity:
                 print("resolutions")
-                for resolution in entity["resolutions"]:
-                    print("kind: {}".format(resolution["resolutionKind"]))
-                    print("value: {}".format(resolution["value"]))
+                for resolution in entity['resolutions']:
+                    print(f"kind: {resolution['resolutionKind']}")
+                    print(f"value: {resolution['value']}")
             if "extraInformation" in entity:
                 print("extra info")
-                for data in entity["extraInformation"]:
-                    print("kind: {}".format(data["extraInformationKind"]))
-                    if data["extraInformationKind"] == "ListKey":
-                        print("key: {}".format(data["key"]))
-                    if data["extraInformationKind"] == "EntitySubtype":
-                        print("value: {}".format(data["value"]))
+                for data in entity['extraInformation']:
+                    print(f"kind: {data['extraInformationKind']}")
+                    if data['extraInformationKind'] == "ListKey":
+                        print(f"key: {data['key']}")
+                    if data['extraInformationKind'] == "EntitySubtype":
+                        print(f"value: {data['value']}")
 
     # [END analyze_orchestration_app_conv_response]
 
 async def main():
     await sample_analyze_orchestration_app_conv_response_async()
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/sample_conv_pii_transcript_input_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_conv_sentiment.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,133 +1,115 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
 """
-FILE: sample_conv_pii_transcript_input_async.py
+FILE: sample_conv_sentiment.py
 
 DESCRIPTION:
-    This sample demonstrates how to analyze a conversation for PII (personally identifiable information).
+    This sample demonstrates how to analyze a conversation for sentiment analysis.
 
     For more info about how to setup a CLU conversation project, see the README.
 
 USAGE:
-    python sample_conv_pii_transcript_input_async.py
+    python sample_conv_sentiment.py
 
     Set the environment variables with your own values before running the sample:
     1) AZURE_CONVERSATIONS_ENDPOINT                       - endpoint for your CLU resource.
     2) AZURE_CONVERSATIONS_KEY                            - API key for your CLU resource.
 """
 
-import asyncio
 
-async def sample_conv_pii_transcript_input_async():
-    # [START analyze_conversation_app]
+def sample_conv_sentiment():
     # import libraries
     import os
     from azure.core.credentials import AzureKeyCredential
-
-    from azure.ai.language.conversations.aio import ConversationAnalysisClient
+    from azure.ai.language.conversations import ConversationAnalysisClient
 
     # get secrets
     endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     key = os.environ["AZURE_CONVERSATIONS_KEY"]
 
-    # analyze quey
+    # analyze query
     client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-    async with client:
+    with client:
 
-        poller = await client.begin_conversation_analysis(
+        poller = client.begin_conversation_analysis(
             task={
-                "displayName": "Analyze PII in conversation",
+                "displayName": "Analyze sentiment in conversation",
                 "analysisInput": {
                     "conversations": [
                         {
                             "conversationItems": [
                                 {
                                     "id": "1",
-                                    "participantId": "0",
+                                    "participantId": "Customer",
                                     "modality": "transcript",
-                                    "text": "It is john doe.",
-                                    "lexical": "It is john doe",
-                                    "itn": "It is john doe",
-                                    "maskedItn": "It is john doe"
+                                    "text": "My cat doesn't like the food, Can I get a refund?",
+                                    "lexical": "my cat doesn't like the food can i get a refund",
                                 },
                                 {
                                     "id": "2",
-                                    "participantId": "1",
+                                    "participantId": "Agent",
                                     "modality": "transcript",
-                                    "text": "Yes, 633-27-8199 is my phone",
-                                    "lexical": "yes six three three two seven eight one nine nine is my phone",
-                                    "itn": "yes 633278199 is my phone",
-                                    "maskedItn": "yes 633278199 is my phone",
+                                    "text": "Sure. You have been refunded. Have a nice day.",
+                                    "lexical": "sure you have been refunded have a nice day",
                                 },
                                 {
                                     "id": "3",
-                                    "participantId": "1",
+                                    "participantId": "Customer",
                                     "modality": "transcript",
-                                    "text": "j.doe@yahoo.com is my email",
-                                    "lexical": "j dot doe at yahoo dot com is my email",
-                                    "maskedItn": "j.doe@yahoo.com is my email",
-                                    "itn": "j.doe@yahoo.com is my email",
-                                }
+                                    "text": "Thanks for your help",
+                                    "lexical": "thanks for your help",
+                                },
                             ],
                             "modality": "transcript",
-                            "id": "1",
-                            "language": "en"
+                            "id": "conversation1",
+                            "language": "en",
                         }
                     ]
                 },
                 "tasks": [
                     {
-                        "kind": "ConversationalPIITask",
+                        "kind": "ConversationalSentimentTask",
                         "parameters": {
-                            "redactionSource": "lexical",
-                            "piiCategories": [
-                                "all"
-                            ]
-                        }
+                            "modelVersion": "2022-10-01-preview",
+                            "predictionSource": "text",
+                        },
                     }
-                ]
+                ],
             }
         )
 
         # view result
-        result = await poller.result()
+        result = poller.result()
         task_result = result["tasks"]["items"][0]
         print("... view task status ...")
-        print("status: {}".format(task_result["status"]))
-        conv_pii_result = task_result["results"]
-        if conv_pii_result["errors"]:
-            print("... errors occured ...")
-            for error in conv_pii_result["errors"]:
+        print(f"status: {task_result['status']}")
+        conv_sentiment_result = task_result["results"]
+        if conv_sentiment_result["errors"]:
+            print("... errors occurred ...")
+            for error in conv_sentiment_result["errors"]:
                 print(error)
         else:
-            conversation_result = conv_pii_result["conversations"][0]
+            conversation_result = conv_sentiment_result["conversations"][0]
             if conversation_result["warnings"]:
                 print("... view warnings ...")
                 for warning in conversation_result["warnings"]:
                     print(warning)
             else:
                 print("... view task result ...")
-                for conversation in conversation_result["conversationItems"]:
-                    print("conversation id: {}".format(conversation["id"]))
-                    print("... entities ...")
-                    for entity in conversation["entities"]:
-                        print("text: {}".format(entity["text"]))
-                        print("category: {}".format(entity["category"]))
-                        print("confidence: {}".format(entity["confidenceScore"]))
-                        print("offset: {}".format(entity["offset"]))
-                        print("length: {}".format(entity["length"]))
-
-
-    # [END analyze_conversation_app]
-
-
-async def main():
-    await sample_conv_pii_transcript_input_async()
-
-if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+                for conversation_item in conversation_result["conversationItems"]:
+                    confidence_score = conversation_item["confidenceScores"]
+                    print(f"id: {conversation_item['id']}")
+                    print(f"participantId: {conversation_item['participantId']}")
+                    print(f"sentiment: {conversation_item['sentiment']}")
+                    print(
+                        f"confidenceScores: positive={confidence_score['positive']}  "
+                        f"neutral={confidence_score['neutral']}  negative={confidence_score['negative']}"
+                    )
+
+
+if __name__ == "__main__":
+    sample_conv_sentiment()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_luis_response_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_direct_target_async.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,51 +1,53 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
 """
-FILE: sample_analyze_orchestration_app_luis_response_async.py
+FILE: sample_analyze_orchestration_direct_target_async.py
 
 DESCRIPTION:
     This sample demonstrates how to analyze user query using an orchestration project.
-    In this sample, orchestration project's top intent will map to a LUIS project.
+    In this sample, orchestration project's top intent will map to a Qna project.
 
     For more info about how to setup a CLU orchestration project, see the README.
 
 USAGE:
-    python sample_analyze_orchestration_app_luis_response_async.py
+    python sample_analyze_orchestration_direct_target_async.py
 
     Set the environment variables with your own values before running the sample:
     1) AZURE_CONVERSATIONS_ENDPOINT                       - endpoint for your CLU resource.
     2) AZURE_CONVERSATIONS_KEY                            - API key for your CLU resource.
     3) AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME     - project name for your CLU orchestration project.
     4) AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME  - deployment name for your CLU orchestration project.
 """
 
 import asyncio
 
-async def sample_analyze_orchestration_app_luis_response_async():
-    # [START analyze_orchestration_app_luis_response]
+async def sample_analyze_orchestration_direct_target_async():
+    # [START analyze_orchestration_app_qna_response]
     # import libraries
     import os
     from azure.core.credentials import AzureKeyCredential
+
     from azure.ai.language.conversations.aio import ConversationAnalysisClient
 
     # get secrets
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
     project_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME"]
     deployment_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME"]
 
     # analyze query
     client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
     async with client:
-        query = "Reserve a table for 2 at the Italian restaurant"
+        query = "How are you?"
+        qna_app = "ChitChat-QnA"
         result = await client.analyze_conversation(
             task={
                 "kind": "Conversation",
                 "analysisInput": {
                     "conversationItem": {
                         "participantId": "1",
                         "id": "1",
@@ -54,39 +56,46 @@
                         "text": query
                     },
                     "isLoggingEnabled": False
                 },
                 "parameters": {
                     "projectName": project_name,
                     "deploymentName": deployment_name,
-                    "verbose": True
+                    "directTarget": qna_app,
+                    "targetProjectParameters": {
+                        "ChitChat-QnA": {
+                            "targetProjectKind": "QuestionAnswering",
+                            "callingOptions": {
+                                "question": query
+                            }
+                        }
+                    }
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
     # top intent
-    top_intent = result["result"]["prediction"]["topIntent"]
-    print("top intent: {}".format(top_intent))
-    top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-    print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-    print("project kind: {}".format(top_intent_object["targetProjectKind"]))
-
-    if top_intent_object["targetProjectKind"] == "Luis":
-        print("\nluis response:")
-        luis_response = top_intent_object["result"]["prediction"]
-        print("top intent: {}".format(luis_response["topIntent"]))
-        print("\nentities:")
-        for entity in luis_response["entities"]:
-            print("\n{}".format(entity))
+    top_intent = result['result']['prediction']['topIntent']
+    print(f"top intent: {top_intent}")
+    top_intent_object = result['result']['prediction']['intents'][top_intent]
+    print(f"confidence score: {top_intent_object['confidenceScore']}")
+    print(f"project kind: {top_intent_object['targetProjectKind']}")
+
+    if top_intent_object['targetProjectKind'] == "QuestionAnswering":
+        print("\nview qna result:")
+        qna_result = top_intent_object['result']
+        for answer in qna_result['answers']:
+            print(f"\nanswer: {answer['answer']}")
+            print(f"answer: {answer['confidenceScore']}")
+
+    # [END analyze_orchestration_app_qna_response]
 
-    # [END analyze_orchestration_app_luis_response]
 
 async def main():
-    await sample_analyze_orchestration_app_luis_response_async()
+    await sample_analyze_orchestration_direct_target_async()
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/sample_analyze_orchestration_app_qna_response_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/sample_analyze_orchestration_app_luis_response_async.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
 """
-FILE: sample_analyze_orchestration_app_qna_response_async.py
+FILE: sample_analyze_orchestration_app_luis_response_async.py
 
 DESCRIPTION:
     This sample demonstrates how to analyze user query using an orchestration project.
-    In this sample, orchestration project's top intent will map to a Qna project.
+    In this sample, orchestration project's top intent will map to a LUIS project.
 
     For more info about how to setup a CLU orchestration project, see the README.
 
 USAGE:
-    python sample_analyze_orchestration_app_qna_response_async.py
+    python sample_analyze_orchestration_app_luis_response_async.py
 
     Set the environment variables with your own values before running the sample:
     1) AZURE_CONVERSATIONS_ENDPOINT                       - endpoint for your CLU resource.
     2) AZURE_CONVERSATIONS_KEY                            - API key for your CLU resource.
     3) AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME     - project name for your CLU orchestration project.
     4) AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME  - deployment name for your CLU orchestration project.
 """
 
 import asyncio
 
-async def sample_analyze_orchestration_app_qna_response_async():
-    # [START analyze_orchestration_app_qna_response]
+async def sample_analyze_orchestration_app_luis_response_async():
+    # [START analyze_orchestration_app_luis_response]
     # import libraries
     import os
     from azure.core.credentials import AzureKeyCredential
     from azure.ai.language.conversations.aio import ConversationAnalysisClient
 
     # get secrets
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
     project_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_PROJECT_NAME"]
     deployment_name = os.environ["AZURE_CONVERSATIONS_WORKFLOW_DEPLOYMENT_NAME"]
 
     # analyze query
     client = ConversationAnalysisClient(clu_endpoint, AzureKeyCredential(clu_key))
     async with client:
-        query = "How are you?"
+        query = "Reserve a table for 2 at the Italian restaurant"
         result = await client.analyze_conversation(
             task={
                 "kind": "Conversation",
                 "analysisInput": {
                     "conversationItem": {
                         "participantId": "1",
                         "id": "1",
@@ -60,32 +60,32 @@
                     "deploymentName": deployment_name,
                     "verbose": True
                 }
             }
         )
 
     # view result
-    print("query: {}".format(result["result"]["query"]))
-    print("project kind: {}\n".format(result["result"]["prediction"]["projectKind"]))
+    print(f"query: {result['result']['query']}")
+    print(f"project kind: {result['result']['prediction']['projectKind']}\n")
 
     # top intent
-    top_intent = result["result"]["prediction"]["topIntent"]
-    print("top intent: {}".format(top_intent))
-    top_intent_object = result["result"]["prediction"]["intents"][top_intent]
-    print("confidence score: {}".format(top_intent_object["confidenceScore"]))
-    print("project kind: {}".format(top_intent_object["targetProjectKind"]))
-
-    if top_intent_object["targetProjectKind"] == "QuestionAnswering":
-        print("\nview qna result:")
-        qna_result = top_intent_object["result"]
-        for answer in qna_result["answers"]:
-            print("\nanswer: {}".format(answer["answer"]))
-            print("answer: {}".format(answer["confidenceScore"]))
+    top_intent = result['result']['prediction']['topIntent']
+    print(f"top intent: {top_intent}")
+    top_intent_object = result['result']['prediction']['intents'][top_intent]
+    print(f"confidence score: {top_intent_object['confidenceScore']}")
+    print(f"project kind: {top_intent_object['targetProjectKind']}")
+
+    if top_intent_object['targetProjectKind'] == "Luis":
+        print("\nluis response:")
+        luis_response = top_intent_object['result']['prediction']
+        print(f"top intent: {luis_response['topIntent']}")
+        print("\nentities:")
+        for entity in luis_response['entities']:
+            print(f"\n{entity}")
 
-    # [END analyze_orchestration_app_qna_response]
+    # [END analyze_orchestration_app_luis_response]
 
 async def main():
-    await sample_analyze_orchestration_app_qna_response_async()
+    await sample_analyze_orchestration_app_luis_response_async()
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/async/authoring/sample_import_train_deploy_project_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/async/authoring/sample_manage_projects_async.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,131 +1,157 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
 """
-FILE: sample_import_train_deploy_project_async.py
+FILE: sample_manage_projects_async.py
 
 DESCRIPTION:
-    This sample demonstrates how to import a project.
+    This sample demonstrates some common authoring operation snippets with the ConversationAuthoringClient.
 
 USAGE:
-    python sample_import_train_deploy_project_async.py
+    python sample_manage_projects_async.py
 
     Set the environment variables with your own values before running the sample:
     1) AZURE_CONVERSATIONS_ENDPOINT             - endpoint for your CLU resource.
     2) AZURE_CONVERSATIONS_KEY                  - API key for your CLU resource.
-    3) AZURE_CONVERSATIONS_PROJECT_NAME         - project name for your CLU conversations project.
+    3) AZURE_CONVERSATIONS_PROJECT_NAME         - project name for your existing CLU conversations project
 """
 
 import asyncio
 
-async def sample_import_project():
+
+async def sample_export_project():
     import os
+    from azure.core.rest import HttpRequest
     from azure.core.credentials import AzureKeyCredential
     from azure.ai.language.conversations.authoring.aio import ConversationAuthoringClient
 
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
-
-    project_name = "test_project"
-
-    exported_project_assets = {
-        "projectKind": "Conversation",
-        "intents": [{"category": "Read"}, {"category": "Delete"}],
-        "entities": [{"category": "Sender"}],
-        "utterances": [
-            {
-                "text": "Open Blake's email",
-                "dataset": "Train",
-                "intent": "Read",
-                "entities": [{"category": "Sender", "offset": 5, "length": 5}],
-            },
-            {
-                "text": "Delete last email",
-                "language": "en-gb",
-                "dataset": "Test",
-                "intent": "Delete",
-                "entities": [],
-            },
-        ],
-    }
+    existing_project_name = os.environ["AZURE_CONVERSATIONS_PROJECT_NAME"]
 
     client = ConversationAuthoringClient(
         clu_endpoint, AzureKeyCredential(clu_key)
     )
-    poller = await client.begin_import_project(
-        project_name=project_name,
-        project={
-            "assets": exported_project_assets,
-            "metadata": {
-                "projectKind": "Conversation",
-                "settings": {"confidenceThreshold": 0.7},
-                "projectName": "EmailApp",
-                "multilingual": True,
-                "description": "Trying out CLU",
-                "language": "en-us",
-            },
-            "projectFileVersion": "2022-05-01",
-        },
-    )
-    response = await poller.result()
-    print(response)
+    async with client:
+        poller = await client.begin_export_project(
+            project_name=existing_project_name,
+            string_index_type="Utf16CodeUnit",
+            exported_project_format="Conversation"
+        )
+        job_state = await poller.result()
+        print(f"Export project status: {job_state['status']}")
+        request = HttpRequest("GET", job_state["resultUrl"])
+        response = await client.send_request(request)
+        exported_project = response.json()
+        return exported_project
 
 
-async def sample_train_model():
+async def sample_import_project(exported_project):
     import os
+    import uuid
     from azure.core.credentials import AzureKeyCredential
     from azure.ai.language.conversations.authoring.aio import ConversationAuthoringClient
 
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+    project_name = "test_project" + str(uuid.uuid4())
 
-    project_name = "test_project"
-
+    print(f"Importing project as '{project_name}'")
     client = ConversationAuthoringClient(
         clu_endpoint, AzureKeyCredential(clu_key)
     )
+    async with client:
+        poller = await client.begin_import_project(
+            project_name=project_name,
+            project=exported_project
+        )
+        response = await poller.result()
+        print(f"Import project status: {response['status']}")
+        return project_name
+
+
+async def sample_train_model(project_name):
+    import os
+    from azure.core.credentials import AzureKeyCredential
+    from azure.ai.language.conversations.authoring.aio import ConversationAuthoringClient
+
+    clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+    clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
 
-    poller = await client.begin_train(
-        project_name=project_name,
-        configuration={"modelLabel": "sample", "trainingMode": "standard"},
+    client = ConversationAuthoringClient(
+        clu_endpoint, AzureKeyCredential(clu_key)
     )
+    print(f"Training model under label 'sample'.")
+    async with client:
+        poller = await client.begin_train(
+            project_name=project_name,
+            configuration={"modelLabel": "sample", "trainingMode": "standard"},
+        )
 
-    response = await poller.result()
-    print(response)
+        response = await poller.result()
+        print(f"Train model status: {response['status']}")
 
 
-async def sample_deploy_model():
+async def sample_deploy_model(project_name):
     import os
     from azure.core.credentials import AzureKeyCredential
     from azure.ai.language.conversations.authoring.aio import ConversationAuthoringClient
 
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
 
-    project_name = "test_project"
     deployment_name = "production"
 
     client = ConversationAuthoringClient(
         clu_endpoint, AzureKeyCredential(clu_key)
     )
 
-    poller = await client.begin_deploy_project(
-        project_name=project_name,
-        deployment_name=deployment_name,
-        deployment={"trainedModelLabel": "sample"},
+    print(f"Deploying 'sample' model to 'production'.")
+    async with client:
+        poller = await client.begin_deploy_project(
+            project_name=project_name,
+            deployment_name=deployment_name,
+            deployment={"trainedModelLabel": "sample"},
+        )
+        response = await poller.result()
+        print(f"Model '{response['modelId']}' deployed to '{response['deploymentName']}'")
+
+
+async def sample_delete_project(project_name):
+    import os
+    from azure.core.credentials import AzureKeyCredential
+    from azure.ai.language.conversations.authoring.aio import ConversationAuthoringClient
+
+    clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+    clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+
+    client = ConversationAuthoringClient(
+        clu_endpoint, AzureKeyCredential(clu_key)
     )
-    response = await poller.result()
-    print(response)
+    async with client:
+        poller = await client.begin_delete_project(
+            project_name=project_name
+        )
+        await poller.result()
+        print(f"Deleted project {project_name}")
 
 
 async def main():
-    await sample_import_project()
-    await sample_train_model()
-    await sample_deploy_model()
+    try:
+        print("Exporting project...")
+        project = await sample_export_project()
+        print("Importing project...")
+        project_name = await sample_import_project(project)
+        print("Training model...")
+        await sample_train_model(project_name)
+        print("Deploying model...")
+        await sample_deploy_model(project_name)
+    finally:
+        print("Deleting project...")
+        await sample_delete_project(project_name)
 
 if __name__ == '__main__':
-    loop = asyncio.get_event_loop()
-    loop.run_until_complete(main())
+    asyncio.run(main())
```

## Comparing `azure-ai-language-conversations-1.1.0b2/samples/authoring/sample_import_train_deploy_project.py` & `azure-ai-language-conversations-1.1.0b3/samples/authoring/sample_manage_projects.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,125 +1,149 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
 """
-FILE: sample_import_train_deploy_project.py
+FILE: sample_manage_projects.py
 
 DESCRIPTION:
-    This sample demonstrates how to import a project.
+    This sample demonstrates some common authoring operation snippets with the ConversationAuthoringClient.
 
 USAGE:
-    python sample_import_train_deploy_project.py
+    python sample_manage_projects.py
 
     Set the environment variables with your own values before running the sample:
     1) AZURE_CONVERSATIONS_ENDPOINT             - endpoint for your CLU resource.
     2) AZURE_CONVERSATIONS_KEY                  - API key for your CLU resource.
-    3) AZURE_CONVERSATIONS_PROJECT_NAME         - project name for your CLU conversations project.
+    3) AZURE_CONVERSATIONS_PROJECT_NAME         - project name for your existing CLU conversations project
 """
 
-def sample_import_project():
+
+def sample_export_project():
     import os
+    from azure.core.rest import HttpRequest
     from azure.core.credentials import AzureKeyCredential
     from azure.ai.language.conversations.authoring import ConversationAuthoringClient
 
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+    existing_project_name = os.environ["AZURE_CONVERSATIONS_PROJECT_NAME"]
 
-    project_name = "test_project"
+    client = ConversationAuthoringClient(
+        clu_endpoint, AzureKeyCredential(clu_key)
+    )
+    poller = client.begin_export_project(
+        project_name=existing_project_name,
+        string_index_type="Utf16CodeUnit",
+        exported_project_format="Conversation"
+    )
+    job_state = poller.result()
+    print(f"Export project status: {job_state['status']}")
+    request = HttpRequest("GET", job_state["resultUrl"])
+    response = client.send_request(request)
+    exported_project = response.json()
+    return exported_project
 
-    exported_project_assets = {
-        "projectKind": "Conversation",
-        "intents": [{"category": "Read"}, {"category": "Delete"}],
-        "entities": [{"category": "Sender"}],
-        "utterances": [
-            {
-                "text": "Open Blake's email",
-                "dataset": "Train",
-                "intent": "Read",
-                "entities": [{"category": "Sender", "offset": 5, "length": 5}],
-            },
-            {
-                "text": "Delete last email",
-                "language": "en-gb",
-                "dataset": "Test",
-                "intent": "Delete",
-                "entities": [],
-            },
-        ],
-    }
 
+def sample_import_project(exported_project):
+    import os
+    import uuid
+    from azure.core.credentials import AzureKeyCredential
+    from azure.ai.language.conversations.authoring import ConversationAuthoringClient
+
+    clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+    clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+    project_name = "test_project" + str(uuid.uuid4())
+
+    print(f"Importing project as '{project_name}'")
     client = ConversationAuthoringClient(
         clu_endpoint, AzureKeyCredential(clu_key)
     )
     poller = client.begin_import_project(
         project_name=project_name,
-        project={
-            "assets": exported_project_assets,
-            "metadata": {
-                "projectKind": "Conversation",
-                "settings": {"confidenceThreshold": 0.7},
-                "projectName": "EmailApp",
-                "multilingual": True,
-                "description": "Trying out CLU",
-                "language": "en-us",
-            },
-            "projectFileVersion": "2022-05-01",
-        },
+        project=exported_project
     )
     response = poller.result()
-    print(response)
+    print(f"Import project status: {response['status']}")
+    return project_name
 
 
-def sample_train_model():
+def sample_train_model(project_name):
     import os
     from azure.core.credentials import AzureKeyCredential
     from azure.ai.language.conversations.authoring import ConversationAuthoringClient
 
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
 
-    project_name = "test_project"
-
     client = ConversationAuthoringClient(
         clu_endpoint, AzureKeyCredential(clu_key)
     )
+    print(f"Training model under label 'sample'.")
 
     poller = client.begin_train(
         project_name=project_name,
         configuration={"modelLabel": "sample", "trainingMode": "standard"},
     )
 
     response = poller.result()
-    print(response)
+    print(f"Train model status: {response['status']}")
 
 
-def sample_deploy_model():
+def sample_deploy_model(project_name):
     import os
     from azure.core.credentials import AzureKeyCredential
     from azure.ai.language.conversations.authoring import ConversationAuthoringClient
 
     clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
     clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
 
-    project_name = "test_project"
     deployment_name = "production"
 
     client = ConversationAuthoringClient(
         clu_endpoint, AzureKeyCredential(clu_key)
     )
 
+    print(f"Deploying 'sample' model to 'production'.")
     poller = client.begin_deploy_project(
         project_name=project_name,
         deployment_name=deployment_name,
         deployment={"trainedModelLabel": "sample"},
     )
     response = poller.result()
-    print(response)
+    print(f"Model '{response['modelId']}' deployed to '{response['deploymentName']}'")
+
+
+def sample_delete_project(project_name):
+    import os
+    from azure.core.credentials import AzureKeyCredential
+    from azure.ai.language.conversations.authoring import ConversationAuthoringClient
+
+    clu_endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+    clu_key = os.environ["AZURE_CONVERSATIONS_KEY"]
+
+    client = ConversationAuthoringClient(
+        clu_endpoint, AzureKeyCredential(clu_key)
+    )
+
+    poller = client.begin_delete_project(
+        project_name=project_name
+    )
+    poller.result()
+    print(f"Deleted project {project_name}")
 
 
-if __name__ == "__main__":
-    sample_import_project()
-    sample_train_model()
-    sample_deploy_model()
+if __name__ == '__main__':
+    try:
+        print("Exporting project...")
+        project = sample_export_project()
+        print("Importing project...")
+        project_name = sample_import_project(project)
+        print("Training model...")
+        sample_train_model(project_name)
+        print("Deploying model...")
+        sample_deploy_model(project_name)
+    finally:
+        print("Deleting project...")
+        sample_delete_project(project_name)
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_conv_pii_transcript_input_async.py` & `azure-ai-language-conversations-1.1.0b3/tests/test_conv_pii_transcript_input.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,31 +1,27 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
-import pytest
-
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
+from azure.ai.language.conversations import ConversationAnalysisClient
 from azure.core.credentials import AzureKeyCredential
-
-from testcase import GlobalConversationAccountPreparer
-from asynctestcase import AsyncConversationTest
-from azure.ai.language.conversations.aio import ConversationAnalysisClient
+from devtools_testutils import AzureRecordedTestCase
 
 
-class TestConversationalPiiAsyncTests(AsyncConversationTest):
+class TestConversationalPii(AzureRecordedTestCase):
 
-    @GlobalConversationAccountPreparer()
-    async def test_conversational_pii(self, endpoint, key):
+    def test_conversational_pii(self, recorded_test, conversation_creds):
         # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        async with client:
-            poller = await client.begin_conversation_analysis(
+        client = ConversationAnalysisClient(
+            conversation_creds["endpoint"],
+            AzureKeyCredential(conversation_creds["key"])
+        )
+        with client:
+            poller = client.begin_conversation_analysis(
                 task={
                     "displayName": "Analyze PII in conversation",
                     "analysisInput": {
                         "conversations": [
                             {
                                 "conversationItems": [
                                     {
@@ -73,15 +69,15 @@
                             }
                         }
                     ]
                 }
             )
 
             # assert - main object
-            result = await poller.result()
+            result = poller.result()
             assert not result is None
             assert result["status"] == "succeeded"
 
             # assert - task result
             task_result = result["tasks"]["items"][0]
             assert task_result["status"] == "succeeded"
             assert task_result["kind"] == "conversationalPIIResults"
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_conversation_app.py` & `azure-ai-language-conversations-1.1.0b3/tests/test_conversation_app_async.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,96 +1,95 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
 import pytest
 
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
+from azure.ai.language.conversations.aio import ConversationAnalysisClient
 from azure.core.credentials import AzureKeyCredential
-from testcase import (
-    ConversationTest,
-    GlobalConversationAccountPreparer
-)
-from azure.ai.language.conversations import ConversationAnalysisClient
+from devtools_testutils import AzureRecordedTestCase
+
 
-class TestConversationAppTests(ConversationTest):
+class TestConversationAppAsync(AzureRecordedTestCase):
 
-    @GlobalConversationAccountPreparer()
-    def test_conversation_app(self, endpoint, key, conv_project_name, conv_deployment_name):
+    @pytest.mark.asyncio
+    async def test_conversation_app(self, recorded_test, conversation_creds):
 
         # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
+        client = ConversationAnalysisClient(
+            conversation_creds["endpoint"],
+            AzureKeyCredential(conversation_creds["key"])
+        )
+        async with client:
             query = "Send an email to Carol about the tomorrow's demo"
-            result = client.analyze_conversation(
+            result = await client.analyze_conversation(
                 task={
                     "kind": "Conversation",
                     "analysisInput": {
                         "conversationItem": {
                             "participantId": "1",
                             "id": "1",
                             "modality": "text",
                             "language": "en",
                             "text": query
                         },
                         "isLoggingEnabled": False
                     },
                     "parameters": {
-                        "projectName": conv_project_name,
-                        "deploymentName": conv_deployment_name,
+                        "projectName": conversation_creds["conv_project_name"],
+                        "deploymentName": conversation_creds["conv_deployment_name"],
                         "verbose": True
                     }
                 }
             )
-        
+
             # assert - main object
             assert not result is None
             assert result["kind"] == "ConversationResult"
-            
+
             # assert - prediction type
             assert result["result"]["query"] == query
             assert result["result"]["prediction"]["projectKind"] == 'Conversation'
-            
+
             # assert - top intent
             assert result["result"]["prediction"]["topIntent"] == 'Send'
             assert len(result["result"]["prediction"]["intents"]) > 0
             assert result["result"]["prediction"]["intents"][0]["category"] == 'Send'
             assert result["result"]["prediction"]["intents"][0]["confidenceScore"] > 0
-            
+
             # assert - entities
             assert len(result["result"]["prediction"]["entities"]) > 0
             assert result["result"]["prediction"]["entities"][0]["category"] == 'Contact'
             assert result["result"]["prediction"]["entities"][0]["text"] == 'Carol'
             assert result["result"]["prediction"]["entities"][0]["confidenceScore"] > 0
 
-    @pytest.mark.live_test_only
-    @GlobalConversationAccountPreparer()
-    def test_conversation_app_aad_auth(self, endpoint, key, conv_project_name, conv_deployment_name):
-        token = self.get_credential(ConversationAnalysisClient)
-        client = ConversationAnalysisClient(endpoint, token, api_version="2022-05-01")
-        with client:
+    @pytest.mark.skip("no runtime AAD yet for 2022-10-01-preview")
+    @pytest.mark.asyncio
+    async def test_conversation_app_aad_auth(self, recorded_test, conversation_creds):
+        token = self.get_credential(ConversationAnalysisClient, is_async=True)
+        client = ConversationAnalysisClient(conversation_creds["endpoint"], token)
+        async with client:
             query = "Send an email to Carol about the tomorrow's demo"
-            result = client.analyze_conversation(
+            result = await client.analyze_conversation(
                 task={
                     "kind": "Conversation",
                     "analysisInput": {
                         "conversationItem": {
                             "participantId": "1",
                             "id": "1",
                             "modality": "text",
                             "language": "en",
                             "text": query
                         },
                         "isLoggingEnabled": False
                     },
                     "parameters": {
-                        "projectName": conv_project_name,
-                        "deploymentName": conv_deployment_name,
+                        "projectName": conversation_creds["conv_project_name"],
+                        "deploymentName": conversation_creds["conv_deployment_name"],
                         "verbose": True
                     }
                 }
             )
 
             # assert - main object
             assert not result is None
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_conv_response_async.py` & `azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_conv_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,70 +1,68 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
-import pytest
-
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
+from azure.ai.language.conversations import ConversationAnalysisClient
 from azure.core.credentials import AzureKeyCredential
-from testcase import GlobalConversationAccountPreparer
-from asynctestcase import AsyncConversationTest
-from azure.ai.language.conversations.aio import ConversationAnalysisClient
+from devtools_testutils import AzureRecordedTestCase
 
-class OrchestrationAppConvResponseAsyncTests(AsyncConversationTest):
 
-    @GlobalConversationAccountPreparer()
-    async def test_orchestration_app_conv_response(self, endpoint, key, orch_project_name, orch_deployment_name):
+class TestOrchestrationAppConvResponse(AzureRecordedTestCase):
+
+    def test_orchestration_app_conv_response(self, recorded_test, conversation_creds):
 
         # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        async with client:
+        client = ConversationAnalysisClient(
+            conversation_creds["endpoint"],
+            AzureKeyCredential(conversation_creds["key"])
+        )
+        with client:
             query = "Send an email to Carol about the tomorrow's demo"
-            result = await client.analyze_conversation(
+            result = client.analyze_conversation(
                 task={
                     "kind": "Conversation",
                     "analysisInput": {
                         "conversationItem": {
                             "participantId": "1",
                             "id": "1",
                             "modality": "text",
                             "language": "en",
                             "text": query
                         },
                         "isLoggingEnabled": False
                     },
                     "parameters": {
-                        "projectName": orch_project_name,
-                        "deploymentName": orch_deployment_name,
+                        "projectName": conversation_creds["orch_project_name"],
+                        "deploymentName": conversation_creds["orch_deployment_name"],
                         "verbose": True
                     }
                 }
             )
-        
+
             # assert - main object
             top_project = "EmailIntent"
             assert not result is None
             assert result["kind"] == "ConversationResult"
             assert result["result"]["query"] == query
-            
+
             # assert - prediction type
             assert result["result"]["prediction"]["projectKind"] == "Orchestration"
-            
+
             # assert - top matching project
             assert result["result"]["prediction"]["topIntent"] == top_project
             top_intent_object = result["result"]["prediction"]["intents"][top_project]
             assert top_intent_object["targetProjectKind"] == "Conversation"
-            
+
             # assert intent and entities
             conversation_result = top_intent_object["result"]["prediction"]
             assert conversation_result["topIntent"] == 'Send'
             assert len(conversation_result["intents"]) > 0
             assert conversation_result["intents"][0]["category"] == 'Send'
             assert conversation_result["intents"][0]["confidenceScore"] > 0
-            
+
             # assert - entities
             assert len(conversation_result["entities"]) > 0
             assert conversation_result["entities"][0]["category"] == 'Contact'
             assert conversation_result["entities"][0]["text"] == 'Carol'
-            assert conversation_result["entities"][0]["confidenceScore"] > 0
+            assert conversation_result["entities"][0]["confidenceScore"] > 0
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_qna_response.py` & `azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_qna_response_async.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,68 +1,64 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
 import pytest
 
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
+from azure.ai.language.conversations.aio import ConversationAnalysisClient
 from azure.core.credentials import AzureKeyCredential
+from devtools_testutils import AzureRecordedTestCase
 
-from testcase import (
-    ConversationTest,
-    GlobalConversationAccountPreparer
-)
-
-from azure.ai.language.conversations import ConversationAnalysisClient
 
-class OrchestrationAppQnaResponseTests(ConversationTest):
+class TestOrchestrationAppQnaResponseAsync(AzureRecordedTestCase):
 
-    @GlobalConversationAccountPreparer()
-    def test_orchestration_app_qna_response(self, endpoint, key, orch_project_name, orch_deployment_name):
+    @pytest.mark.asyncio
+    async def test_orchestration_app_qna_response(self, recorded_test, conversation_creds):
 
         # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
+        client = ConversationAnalysisClient(
+            conversation_creds["endpoint"],
+            AzureKeyCredential(conversation_creds["key"])
+        )
+        async with client:
             query = "How are you?"
-            result = client.analyze_conversation(
+            result = await client.analyze_conversation(
                 task={
                     "kind": "Conversation",
                     "analysisInput": {
                         "conversationItem": {
                             "participantId": "1",
                             "id": "1",
                             "modality": "text",
                             "language": "en",
                             "text": query
                         },
                         "isLoggingEnabled": False
                     },
                     "parameters": {
-                        "projectName": orch_project_name,
-                        "deploymentName": orch_deployment_name,
+                        "projectName": conversation_creds["orch_project_name"],
+                        "deploymentName": conversation_creds["orch_deployment_name"],
                         "verbose": True
                     }
                 }
             )
 
             # assert - main object
             top_project = 'ChitChat-QnA'
             assert not result is None
             assert result["kind"] == "ConversationResult"
             assert result["result"]["query"] == query
-            
+
             # assert - prediction type
             assert result["result"]["prediction"]["projectKind"] == "Orchestration"
-            
+
             # assert - top matching project
             assert result["result"]["prediction"]["topIntent"] == top_project
             top_intent_object = result["result"]["prediction"]["intents"][top_project]
             assert top_intent_object["targetProjectKind"] == "QuestionAnswering"
-            
+
             # assert intent and entities
             qna_result = top_intent_object["result"]
             answer = qna_result["answers"][0]["answer"]
             assert not answer is None
             assert qna_result["answers"][0]["confidenceScore"] >= 0
-
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_luis_response.py` & `azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_luis_response_async.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,73 +1,69 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
 import pytest
 
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
+from azure.ai.language.conversations.aio import ConversationAnalysisClient
 from azure.core.credentials import AzureKeyCredential
+from devtools_testutils import AzureRecordedTestCase
 
-from testcase import (
-    ConversationTest,
-    GlobalConversationAccountPreparer
-)
-
-from azure.ai.language.conversations import ConversationAnalysisClient
 
-class OrchestrationAppLuisResponseTests(ConversationTest):
+class TestOrchestrationAppLuisResponseAsync(AzureRecordedTestCase):
 
     @pytest.mark.skip("https://github.com/Azure/azure-sdk-for-python/issues/24962")
-    @GlobalConversationAccountPreparer()
-    def test_orchestration_app_luis_response(self, endpoint, key, orch_project_name, orch_deployment_name):
+    @pytest.mark.asyncio
+    async def test_orchestration_app_luis_response(self, recorded_test, conversation_creds):
 
         # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
+        client = ConversationAnalysisClient(
+            conversation_creds["endpoint"],
+            AzureKeyCredential(conversation_creds["key"])
+        )
+        async with client:
             query = "Reserve a table for 2 at the Italian restaurant"
-            result = client.analyze_conversation(
+            result = await client.analyze_conversation(
                 task={
                     "kind": "Conversation",
                     "analysisInput": {
                         "conversationItem": {
                             "participantId": "1",
                             "id": "1",
                             "modality": "text",
                             "language": "en",
                             "text": query
                         },
                         "isLoggingEnabled": False
                     },
                     "parameters": {
-                        "projectName": orch_project_name,
-                        "deploymentName": orch_deployment_name,
+                        "projectName": conversation_creds["orch_project_name"],
+                        "deploymentName": conversation_creds["orch_deployment_name"],
                         "verbose": True
                     }
                 }
             )
 
             # assert - main object
             top_project = "RestaurantIntent"
             assert not result is None
             assert result["kind"] == "ConversationResult"
             assert result["result"]["query"] == query
-            
+
             # assert - prediction type
             assert result["result"]["prediction"]["projectKind"] == "Orchestration"
-            
+
             # assert - top matching project
             assert result["result"]["prediction"]["topIntent"] == top_project
             top_intent_object = result["result"]["prediction"]["intents"][top_project]
             assert top_intent_object["targetProjectKind"] == "Luis"
-            
+
             # assert intent and entities
             top_intent = "Reserve"
             luis_result = top_intent_object["result"]["prediction"]
             assert luis_result["topIntent"] == top_intent
             assert len(luis_result["intents"]) > 0
             assert luis_result["intents"][top_intent]["score"] > 0
-            
+
             # assert - entities
             assert len(luis_result["entities"]) > 0
-
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_conversation_app_async.py` & `azure-ai-language-conversations-1.1.0b3/samples/sample_conv_pii_transcript_input.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,113 +1,127 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 
-import pytest
+"""
+FILE: sample_conv_pii_transcript_input.py
 
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
-from azure.core.credentials import AzureKeyCredential
+DESCRIPTION:
+    This sample demonstrates how to analyze a conversation for PII (personally identifiable information).
 
-from testcase import GlobalConversationAccountPreparer
-from asynctestcase import AsyncConversationTest
-from azure.ai.language.conversations.aio import ConversationAnalysisClient
-
-
-class ConversationAppAsyncTests(AsyncConversationTest):
-
-    @GlobalConversationAccountPreparer()
-    async def test_conversation_app(self, endpoint, key, conv_project_name, conv_deployment_name):
-
-        # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        async with client:
-            query = "Send an email to Carol about the tomorrow's demo"
-            result = await client.analyze_conversation(
-                task={
-                    "kind": "Conversation",
-                    "analysisInput": {
-                        "conversationItem": {
-                            "participantId": "1",
-                            "id": "1",
-                            "modality": "text",
-                            "language": "en",
-                            "text": query
-                        },
-                        "isLoggingEnabled": False
-                    },
-                    "parameters": {
-                        "projectName": conv_project_name,
-                        "deploymentName": conv_deployment_name,
-                        "verbose": True
-                    }
-                }
-            )
-        
-            # assert - main object
-            assert not result is None
-            assert result["kind"] == "ConversationResult"
-            
-            # assert - prediction type
-            assert result["result"]["query"] == query
-            assert result["result"]["prediction"]["projectKind"] == 'Conversation'
-            
-            # assert - top intent
-            assert result["result"]["prediction"]["topIntent"] == 'Send'
-            assert len(result["result"]["prediction"]["intents"]) > 0
-            assert result["result"]["prediction"]["intents"][0]["category"] == 'Send'
-            assert result["result"]["prediction"]["intents"][0]["confidenceScore"] > 0
-            
-            # assert - entities
-            assert len(result["result"]["prediction"]["entities"]) > 0
-            assert result["result"]["prediction"]["entities"][0]["category"] == 'Contact'
-            assert result["result"]["prediction"]["entities"][0]["text"] == 'Carol'
-            assert result["result"]["prediction"]["entities"][0]["confidenceScore"] > 0
-
-    @pytest.mark.live_test_only
-    @GlobalConversationAccountPreparer()
-    async def test_conversation_app_aad_auth(self, endpoint, conv_project_name, conv_deployment_name):
-        token = self.get_credential(ConversationAnalysisClient, is_async=True)
-        client = ConversationAnalysisClient(endpoint, token, api_version="2022-05-01")
-        async with client:
-            query = "Send an email to Carol about the tomorrow's demo"
-            result = await client.analyze_conversation(
-                task={
-                    "kind": "Conversation",
-                    "analysisInput": {
-                        "conversationItem": {
-                            "participantId": "1",
+    For more info about how to setup a CLU conversation project, see the README.
+
+USAGE:
+    python sample_conv_pii_transcript_input.py
+
+    Set the environment variables with your own values before running the sample:
+    1) AZURE_CONVERSATIONS_ENDPOINT                       - endpoint for your CLU resource.
+    2) AZURE_CONVERSATIONS_KEY                            - API key for your CLU resource.
+"""
+
+def sample_conv_pii_transcript_input():
+    # [START analyze_conversation_app]
+    # import libraries
+    import os
+    from azure.core.credentials import AzureKeyCredential
+
+    from azure.ai.language.conversations import ConversationAnalysisClient
+
+    # get secrets
+    endpoint = os.environ["AZURE_CONVERSATIONS_ENDPOINT"]
+    key = os.environ["AZURE_CONVERSATIONS_KEY"]
+
+    # analyze quey
+    client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
+    with client:
+
+        poller = client.begin_conversation_analysis(
+            task={
+                "displayName": "Analyze PII in conversation",
+                "analysisInput": {
+                    "conversations": [
+                        {
+                            "conversationItems": [
+                                {
+                                    "id": "1",
+                                    "participantId": "0",
+                                    "modality": "transcript",
+                                    "text": "It is john doe.",
+                                    "lexical": "It is john doe",
+                                    "itn": "It is john doe",
+                                    "maskedItn": "It is john doe"
+                                },
+                                {
+                                    "id": "2",
+                                    "participantId": "1",
+                                    "modality": "transcript",
+                                    "text": "Yes, 633-27-8199 is my phone",
+                                    "lexical": "yes six three three two seven eight one nine nine is my phone",
+                                    "itn": "yes 633278199 is my phone",
+                                    "maskedItn": "yes 633278199 is my phone",
+                                },
+                                {
+                                    "id": "3",
+                                    "participantId": "1",
+                                    "modality": "transcript",
+                                    "text": "j.doe@yahoo.com is my email",
+                                    "lexical": "j dot doe at yahoo dot com is my email",
+                                    "maskedItn": "j.doe@yahoo.com is my email",
+                                    "itn": "j.doe@yahoo.com is my email",
+                                }
+                            ],
+                            "modality": "transcript",
                             "id": "1",
-                            "modality": "text",
-                            "language": "en",
-                            "text": query
-                        },
-                        "isLoggingEnabled": False
-                    },
-                    "parameters": {
-                        "projectName": conv_project_name,
-                        "deploymentName": conv_deployment_name,
-                        "verbose": True
+                            "language": "en"
+                        }
+                    ]
+                },
+                "tasks": [
+                    {
+                        "kind": "ConversationalPIITask",
+                        "parameters": {
+                            "redactionSource": "lexical",
+                            "piiCategories": [
+                                "all"
+                            ]
+                        }
                     }
-                }
-            )
+                ]
+            }
+        )
+
+        # view result
+        result = poller.result()
+        task_result = result["tasks"]["items"][0]
+        print("... view task status ...")
+        print(f"status: {task_result['status']}")
+        conv_pii_result = task_result["results"]
+        if conv_pii_result["errors"]:
+            print("... errors occurred ...")
+            for error in conv_pii_result["errors"]:
+                print(error)
+        else:
+            conversation_result = conv_pii_result["conversations"][0]
+            if conversation_result["warnings"]:
+                print("... view warnings ...")
+                for warning in conversation_result["warnings"]:
+                    print(warning)
+            else:
+                print("... view task result ...")
+                for conversation in conversation_result["conversationItems"]:
+                    print(f"conversation id: {conversation['id']}")
+                    print("... entities ...")
+                    for entity in conversation["entities"]:
+                        print(f"text: {entity['text']}")
+                        print(f"category: {entity['category']}")
+                        print(f"confidence: {entity['confidenceScore']}")
+                        print(f"offset: {entity['offset']}")
+                        print(f"length: {entity['length']}")
+
+
+    # [END analyze_conversation_app]
+
 
-            # assert - main object
-            assert not result is None
-            assert result["kind"] == "ConversationResult"
-
-            # assert - prediction type
-            assert result["result"]["query"] == query
-            assert result["result"]["prediction"]["projectKind"] == 'Conversation'
-
-            # assert - top intent
-            assert result["result"]["prediction"]["topIntent"] == 'Send'
-            assert len(result["result"]["prediction"]["intents"]) > 0
-            assert result["result"]["prediction"]["intents"][0]["category"] == 'Send'
-            assert result["result"]["prediction"]["intents"][0]["confidenceScore"] > 0
-
-            # assert - entities
-            assert len(result["result"]["prediction"]["entities"]) > 0
-            assert result["result"]["prediction"]["entities"][0]["category"] == 'Contact'
-            assert result["result"]["prediction"]["entities"][0]["text"] == 'Carol'
-            assert result["result"]["prediction"]["entities"][0]["confidenceScore"] > 0
+if __name__ == '__main__':
+    sample_conv_pii_transcript_input()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_conv_response.py` & `azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_conv_response_async.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,75 +1,71 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
 import pytest
 
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
+from azure.ai.language.conversations.aio import ConversationAnalysisClient
 from azure.core.credentials import AzureKeyCredential
+from devtools_testutils import AzureRecordedTestCase
 
-from testcase import (
-    ConversationTest,
-    GlobalConversationAccountPreparer
-)
-
-from azure.ai.language.conversations import ConversationAnalysisClient
 
-class OrchestrationAppConvResponseTests(ConversationTest):
+class TestOrchestrationAppConvResponseAsync(AzureRecordedTestCase):
 
-    @GlobalConversationAccountPreparer()
-    def test_orchestration_app_conv_response(self, endpoint, key, orch_project_name, orch_deployment_name):
+    @pytest.mark.asyncio
+    async def test_orchestration_app_conv_response(self, recorded_test, conversation_creds):
 
         # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
+        client = ConversationAnalysisClient(
+            conversation_creds["endpoint"],
+            AzureKeyCredential(conversation_creds["key"])
+        )
+        async with client:
             query = "Send an email to Carol about the tomorrow's demo"
-            result = client.analyze_conversation(
+            result = await client.analyze_conversation(
                 task={
                     "kind": "Conversation",
                     "analysisInput": {
                         "conversationItem": {
                             "participantId": "1",
                             "id": "1",
                             "modality": "text",
                             "language": "en",
                             "text": query
                         },
                         "isLoggingEnabled": False
                     },
                     "parameters": {
-                        "projectName": orch_project_name,
-                        "deploymentName": orch_deployment_name,
+                        "projectName": conversation_creds["orch_project_name"],
+                        "deploymentName":conversation_creds["orch_deployment_name"],
                         "verbose": True
                     }
                 }
             )
-        
+
             # assert - main object
             top_project = "EmailIntent"
             assert not result is None
             assert result["kind"] == "ConversationResult"
             assert result["result"]["query"] == query
-            
+
             # assert - prediction type
             assert result["result"]["prediction"]["projectKind"] == "Orchestration"
-            
+
             # assert - top matching project
             assert result["result"]["prediction"]["topIntent"] == top_project
             top_intent_object = result["result"]["prediction"]["intents"][top_project]
             assert top_intent_object["targetProjectKind"] == "Conversation"
-            
+
             # assert intent and entities
             conversation_result = top_intent_object["result"]["prediction"]
             assert conversation_result["topIntent"] == 'Send'
             assert len(conversation_result["intents"]) > 0
             assert conversation_result["intents"][0]["category"] == 'Send'
             assert conversation_result["intents"][0]["confidenceScore"] > 0
-            
+
             # assert - entities
             assert len(conversation_result["entities"]) > 0
             assert conversation_result["entities"][0]["category"] == 'Contact'
             assert conversation_result["entities"][0]["text"] == 'Carol'
             assert conversation_result["entities"][0]["confidenceScore"] > 0
-
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_conv_pii_transcript_input.py` & `azure-ai-language-conversations-1.1.0b3/tests/test_conv_pii_transcript_input_async.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,30 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
 import pytest
 
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
+from azure.ai.language.conversations.aio import ConversationAnalysisClient
 from azure.core.credentials import AzureKeyCredential
-from testcase import (
-    ConversationTest,
-    GlobalConversationAccountPreparer
-)
-from azure.ai.language.conversations import ConversationAnalysisClient
+from devtools_testutils import AzureRecordedTestCase
 
 
-class TestConversationalPiiTests(ConversationTest):
+class TestConversationalPiiAsync(AzureRecordedTestCase):
 
-    @GlobalConversationAccountPreparer()
-    def test_conversational_pii(self, endpoint, key):
+    @pytest.mark.asyncio
+    async def test_conversational_pii(self, recorded_test, conversation_creds):
         # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        with client:
-            poller = client.begin_conversation_analysis(
+        client = ConversationAnalysisClient(
+            conversation_creds["endpoint"],
+            AzureKeyCredential(conversation_creds["key"])
+        )
+        async with client:
+            poller = await client.begin_conversation_analysis(
                 task={
                     "displayName": "Analyze PII in conversation",
                     "analysisInput": {
                         "conversations": [
                             {
                                 "conversationItems": [
                                     {
@@ -74,15 +72,15 @@
                             }
                         }
                     ]
                 }
             )
 
             # assert - main object
-            result = poller.result()
+            result = await poller.result()
             assert not result is None
             assert result["status"] == "succeeded"
 
             # assert - task result
             task_result = result["tasks"]["items"][0]
             assert task_result["status"] == "succeeded"
             assert task_result["kind"] == "conversationalPIIResults"
```

## Comparing `azure-ai-language-conversations-1.1.0b2/tests/test_orchestration_app_qna_response_async.py` & `azure-ai-language-conversations-1.1.0b3/tests/test_orchestration_app_qna_response.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,64 +1,60 @@
 # coding=utf-8
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
-import pytest
-
-from azure.core.exceptions import HttpResponseError, ClientAuthenticationError
+from azure.ai.language.conversations import ConversationAnalysisClient
 from azure.core.credentials import AzureKeyCredential
-from testcase import GlobalConversationAccountPreparer
-from asynctestcase import AsyncConversationTest
-from azure.ai.language.conversations.aio import ConversationAnalysisClient
-
+from devtools_testutils import AzureRecordedTestCase
 
-class OrchestrationAppQnaResponseAsyncTests(AsyncConversationTest):
+class TestOrchestrationAppQnaResponse(AzureRecordedTestCase):
 
-    @GlobalConversationAccountPreparer()
-    async def test_orchestration_app_qna_response(self, endpoint, key, orch_project_name, orch_deployment_name):
+    def test_orchestration_app_qna_response(self, recorded_test, conversation_creds):
 
         # analyze query
-        client = ConversationAnalysisClient(endpoint, AzureKeyCredential(key))
-        async with client:
+        client = ConversationAnalysisClient(
+            conversation_creds["endpoint"],
+            AzureKeyCredential(conversation_creds["key"])
+        )
+        with client:
             query = "How are you?"
-            result = await client.analyze_conversation(
+            result = client.analyze_conversation(
                 task={
                     "kind": "Conversation",
                     "analysisInput": {
                         "conversationItem": {
                             "participantId": "1",
                             "id": "1",
                             "modality": "text",
                             "language": "en",
                             "text": query
                         },
                         "isLoggingEnabled": False
                     },
                     "parameters": {
-                        "projectName": orch_project_name,
-                        "deploymentName": orch_deployment_name,
+                        "projectName": conversation_creds["orch_project_name"],
+                        "deploymentName": conversation_creds["orch_deployment_name"],
                         "verbose": True
                     }
                 }
             )
 
             # assert - main object
             top_project = 'ChitChat-QnA'
             assert not result is None
             assert result["kind"] == "ConversationResult"
             assert result["result"]["query"] == query
-            
+
             # assert - prediction type
             assert result["result"]["prediction"]["projectKind"] == "Orchestration"
-            
+
             # assert - top matching project
             assert result["result"]["prediction"]["topIntent"] == top_project
             top_intent_object = result["result"]["prediction"]["intents"][top_project]
             assert top_intent_object["targetProjectKind"] == "QuestionAnswering"
-            
+
             # assert intent and entities
             qna_result = top_intent_object["result"]
             answer = qna_result["answers"][0]["answer"]
             assert not answer is None
             assert qna_result["answers"][0]["confidenceScore"] >= 0
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_serialization.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_serialization.py`

 * *Files 0% similar despite different names*

```diff
@@ -1501,15 +1501,15 @@
         :param str target_obj: The target object type to deserialize to.
         :param str/dict data: The response data to deseralize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
-            _LOGGER.warning(
+            _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
             )
             return None
 
     @staticmethod
     def _unpack_content(raw_data, content_type=None):
         """Extract the correct structure for deserialization.
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/__init__.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,11 +14,13 @@
 try:
     from ._patch import __all__ as _patch_all
     from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
-__all__ = ["ConversationAnalysisClient"]
+__all__ = [
+    "ConversationAnalysisClient",
+]
 __all__.extend([p for p in _patch_all if p not in __all__])
 
 _patch_sdk()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_configuration.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_configuration.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,68 +2,71 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-from ._version import VERSION
+from .._version import VERSION
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class ConversationAnalysisClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for ConversationAnalysisClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
-    :keyword api_version: Api Version. Default value is "2022-05-15-preview". Note that overriding
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :keyword api_version: Api Version. Default value is "2022-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, endpoint: str, credential: "TokenCredential", **kwargs: Any) -> None:
+    def __init__(self, endpoint: str, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
         super(ConversationAnalysisClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "2022-05-15-preview")  # type: str
+        api_version = kwargs.pop("api_version", "2022-10-01-preview")  # type: Literal["2022-10-01-preview"]
 
         if endpoint is None:
             raise ValueError("Parameter 'endpoint' must not be None.")
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.endpoint = endpoint
         self.credential = credential
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://cognitiveservices.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "ai-language-conversations/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = policies.BearerTokenCredentialPolicy(
+            self.authentication_policy = policies.AsyncBearerTokenCredentialPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_client.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,16 +14,14 @@
 
 from ._configuration import ConversationAnalysisClientConfiguration
 from ._operations import ConversationAnalysisClientOperationsMixin
 from ._serialization import Deserializer, Serializer
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from typing import Dict
-
     from azure.core.credentials import TokenCredential
 
 
 class ConversationAnalysisClient(
     ConversationAnalysisClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The language service conversations API is a suite of natural language processing (NLP) skills
@@ -38,15 +36,15 @@
     Summarization and Conversational PII detection.
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
-    :keyword api_version: Api Version. Default value is "2022-05-15-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, endpoint: str, credential: "TokenCredential", **kwargs: Any) -> None:
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_patch.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_patch.py`

 * *Files 11% similar despite different names*

```diff
@@ -29,32 +29,32 @@
 # https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/customize_code/how-to-patch-sdk-code.md
 
 from typing import List, Union, Any
 from azure.core.credentials import AzureKeyCredential, TokenCredential
 from azure.core.pipeline.policies import AzureKeyCredentialPolicy
 from ._client import ConversationAnalysisClient as GeneratedConversationAnalysisClient
 
+POLLING_INTERVAL_DEFAULT = 5
+
 
 def _authentication_policy(credential):
     authentication_policy = None
     if credential is None:
         raise ValueError("Parameter 'credential' must not be None.")
     if isinstance(credential, AzureKeyCredential):
-        authentication_policy = AzureKeyCredentialPolicy(
-            name="Ocp-Apim-Subscription-Key", credential=credential
-        )
+        authentication_policy = AzureKeyCredentialPolicy(name="Ocp-Apim-Subscription-Key", credential=credential)
     elif credential is not None and not hasattr(credential, "get_token"):
         raise TypeError(
-            "Unsupported credential: {}. Use an instance of AzureKeyCredential "
-            "or a token credential from azure.identity".format(type(credential))
+            f"Unsupported credential: {type(credential)}. Use an instance of AzureKeyCredential "
+            "or a token credential from azure.identity"
         )
     return authentication_policy
 
 
-class ConversationAnalysisClient(GeneratedConversationAnalysisClient): # pylint: disable=client-accepts-api-version-keyword
+class ConversationAnalysisClient(GeneratedConversationAnalysisClient):
     """The language service conversations API is a suite of natural language processing (NLP) skills
     that can be used to analyze structured conversations (textual or spoken). The synchronous API
     in this suite accepts a request and mediates among multiple language projects, such as LUIS
     Generally Available, Question Answering, Conversational Language Understanding, and then calls
     the best candidate service to handle the request. At last, it returns a response with the
     candidate service's response as a payload.
 
@@ -64,27 +64,33 @@
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure.
         This can be the an instance of AzureKeyCredential if using a Language API key
         or a token credential from :mod:`azure.identity`.
     :type credential: ~azure.core.credentials.AzureKeyCredential or ~azure.core.credentials.TokenCredential
-    :keyword api_version: Api Version. Available values are "2022-05-15-preview" and "2022-05-01". Default
-     value is "2022-05-15-preview". Note that overriding this default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Available values are "2022-10-01-preview", "2022-05-15-preview",
+     "2022-05-01". Default value is "2022-10-01-preview". Note that overriding this default value may result in
+     unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, endpoint: str, credential: Union[AzureKeyCredential, TokenCredential], **kwargs: Any) -> None:
+        try:
+            endpoint = endpoint.rstrip("/")
+        except AttributeError:
+            raise ValueError("Parameter 'endpoint' must be a string.")
         super().__init__(
             endpoint=endpoint,
             credential=credential,  # type: ignore
             authentication_policy=kwargs.pop("authentication_policy", _authentication_policy(credential)),
-            **kwargs
+            polling_interval=kwargs.pop("polling_interval", POLLING_INTERVAL_DEFAULT),
+            **kwargs,
         )
 
 
 __all__: List[str] = ["ConversationAnalysisClient"]
 
 
 def patch_sdk():
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_vendor.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_vendor.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,14 +13,14 @@
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core import PipelineClient
 
     from ._serialization import Deserializer, Serializer
 
 
-class MixinABC(ABC):
+class ConversationAnalysisClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
 
     _client: "PipelineClient"
     _config: ConversationAnalysisClientConfiguration
     _serialize: "Serializer"
     _deserialize: "Deserializer"
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/__init__.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/_operations/_operations.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_operations/_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,45 +10,52 @@
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.polling.base_polling import LROBasePolling
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 
 from .._serialization import Serializer
-from .._vendor import MixinABC
+from .._vendor import ConversationAnalysisClientMixinABC
 
 if sys.version_info >= (3, 9):
     from collections.abc import MutableMapping
 else:
     from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_analyze_conversation_request(**kwargs: Any) -> HttpRequest:
+def build_conversation_analysis_analyze_conversation_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
     content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/:analyze-conversations"
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,20 +64,22 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_conversation_analysis_request(**kwargs: Any) -> HttpRequest:
+def build_conversation_analysis_conversation_analysis_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
     content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/analyze-conversations/jobs"
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -79,19 +88,23 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ConversationAnalysisClientOperationsMixin(MixinABC):
+class ConversationAnalysisClientOperationsMixin(ConversationAnalysisClientMixinABC):
     @overload
     def analyze_conversation(self, task: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
         """Analyzes the input conversation utterance.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis/analyze-conversation
+        for more information.
+
         :param task: A single conversational task to execute. Required.
         :type task: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :return: JSON object
         :rtype: JSON
@@ -104,33 +117,33 @@
                   discriminator "kind":
 
                 # JSON input template for discriminator value "Conversation":
                 analyze_conversation_task = {
                     "analysisInput": {
                         "conversationItem": {
                             "id": "str",  # The ID of a conversation item. Required.
+                            "participantId": "str",  # The participant ID of a
+                              conversation item. Required.
                             "language": "str",  # Optional. The override language of a
                               conversation item in BCP 47 language representation.
                             "modality": "str",  # Optional. Enumeration of supported
                               conversational modalities. Known values are: "transcript" and "text".
-                            "participantId": "str",  # The participant ID of a
-                              conversation item. Required.
                             "role": "str"  # Optional. The role of the participant. Known
                               values are: "agent", "customer", and "generic".
                         }
                     },
                     "kind": "Conversation",
                     "parameters": {
                         "deploymentName": "str",  # The name of the deployment to use.
                           Required.
+                        "projectName": "str",  # The name of the project to use. Required.
                         "directTarget": "str",  # Optional. The name of a target project to
                           forward the request to.
                         "isLoggingEnabled": bool,  # Optional. If true, the service will keep
                           the query for further review.
-                        "projectName": "str",  # The name of the project to use. Required.
                         "stringIndexType": "TextElements_v8",  # Optional. Default value is
                           "TextElements_v8". Specifies the method used to interpret string offsets. Set
                           to "UnicodeCodePoint" for Python strings. Known values are:
                           "TextElements_v8", "UnicodeCodePoint", and "Utf16CodeUnit".
                         "targetProjectParameters": {
                             "str": analysis_parameters
                         },
@@ -144,95 +157,227 @@
                 # The response is polymorphic. The following are possible polymorphic responses based
                   off discriminator "kind":
 
                 # JSON input template for discriminator value "ConversationResult":
                 analyze_conversation_task_result = {
                     "kind": "ConversationResult",
                     "result": {
-                        "detectedLanguage": "str",  # Optional. The system detected language
-                          for the query in BCP 47 language representation..
                         "prediction": base_prediction,
-                        "query": "str"  # The conversation utterance given by the caller.
+                        "query": "str",  # The conversation utterance given by the caller.
                           Required.
+                        "detectedLanguage": "str"  # Optional. The system detected language
+                          for the query in BCP 47 language representation..
                     }
                 }
 
+                # JSON input template for discriminator value "Conversation":
+                base_prediction = {
+                    "entities": [
+                        {
+                            "category": "str",  # The entity category. Required.
+                            "confidenceScore": 0.0,  # The entity confidence score.
+                              Required.
+                            "length": 0,  # The length of the text. Required.
+                            "offset": 0,  # The starting index of this entity in the
+                              query. Required.
+                            "text": "str",  # The predicted entity text. Required.
+                            "extraInformation": [
+                                base_extra_information
+                            ],
+                            "resolutions": [
+                                base_resolution
+                            ]
+                        }
+                    ],
+                    "intents": [
+                        {
+                            "category": "str",  # A predicted class. Required.
+                            "confidenceScore": 0.0  # The confidence score of the class
+                              from 0.0 to 1.0. Required.
+                        }
+                    ],
+                    "projectKind": "Conversation",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
+                # JSON input template for discriminator value "Orchestration":
+                base_prediction = {
+                    "intents": {
+                        "str": target_intent_result
+                    },
+                    "projectKind": "Orchestration",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
                 # response body for status code(s): 200
                 response == analyze_conversation_task_result
         """
 
     @overload
     def analyze_conversation(self, task: IO, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
         """Analyzes the input conversation utterance.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis/analyze-conversation
+        for more information.
+
         :param task: A single conversational task to execute. Required.
         :type task: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
+
                 # The response is polymorphic. The following are possible polymorphic responses based
                   off discriminator "kind":
 
                 # JSON input template for discriminator value "ConversationResult":
                 analyze_conversation_task_result = {
                     "kind": "ConversationResult",
                     "result": {
-                        "detectedLanguage": "str",  # Optional. The system detected language
-                          for the query in BCP 47 language representation..
                         "prediction": base_prediction,
-                        "query": "str"  # The conversation utterance given by the caller.
+                        "query": "str",  # The conversation utterance given by the caller.
                           Required.
+                        "detectedLanguage": "str"  # Optional. The system detected language
+                          for the query in BCP 47 language representation..
                     }
                 }
 
+                # JSON input template for discriminator value "Conversation":
+                base_prediction = {
+                    "entities": [
+                        {
+                            "category": "str",  # The entity category. Required.
+                            "confidenceScore": 0.0,  # The entity confidence score.
+                              Required.
+                            "length": 0,  # The length of the text. Required.
+                            "offset": 0,  # The starting index of this entity in the
+                              query. Required.
+                            "text": "str",  # The predicted entity text. Required.
+                            "extraInformation": [
+                                base_extra_information
+                            ],
+                            "resolutions": [
+                                base_resolution
+                            ]
+                        }
+                    ],
+                    "intents": [
+                        {
+                            "category": "str",  # A predicted class. Required.
+                            "confidenceScore": 0.0  # The confidence score of the class
+                              from 0.0 to 1.0. Required.
+                        }
+                    ],
+                    "projectKind": "Conversation",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
+                # JSON input template for discriminator value "Orchestration":
+                base_prediction = {
+                    "intents": {
+                        "str": target_intent_result
+                    },
+                    "projectKind": "Orchestration",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
                 # response body for status code(s): 200
                 response == analyze_conversation_task_result
         """
 
     @distributed_trace
     def analyze_conversation(self, task: Union[JSON, IO], **kwargs: Any) -> JSON:
         """Analyzes the input conversation utterance.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis/analyze-conversation
+        for more information.
+
         :param task: A single conversational task to execute. Is either a model type or a IO type.
          Required.
         :type task: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
+
                 # The response is polymorphic. The following are possible polymorphic responses based
                   off discriminator "kind":
 
                 # JSON input template for discriminator value "ConversationResult":
                 analyze_conversation_task_result = {
                     "kind": "ConversationResult",
                     "result": {
-                        "detectedLanguage": "str",  # Optional. The system detected language
-                          for the query in BCP 47 language representation..
                         "prediction": base_prediction,
-                        "query": "str"  # The conversation utterance given by the caller.
+                        "query": "str",  # The conversation utterance given by the caller.
                           Required.
+                        "detectedLanguage": "str"  # Optional. The system detected language
+                          for the query in BCP 47 language representation..
                     }
                 }
 
+                # JSON input template for discriminator value "Conversation":
+                base_prediction = {
+                    "entities": [
+                        {
+                            "category": "str",  # The entity category. Required.
+                            "confidenceScore": 0.0,  # The entity confidence score.
+                              Required.
+                            "length": 0,  # The length of the text. Required.
+                            "offset": 0,  # The starting index of this entity in the
+                              query. Required.
+                            "text": "str",  # The predicted entity text. Required.
+                            "extraInformation": [
+                                base_extra_information
+                            ],
+                            "resolutions": [
+                                base_resolution
+                            ]
+                        }
+                    ],
+                    "intents": [
+                        {
+                            "category": "str",  # A predicted class. Required.
+                            "confidenceScore": 0.0  # The confidence score of the class
+                              from 0.0 to 1.0. Required.
+                        }
+                    ],
+                    "projectKind": "Conversation",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
+                # JSON input template for discriminator value "Orchestration":
+                base_prediction = {
+                    "intents": {
+                        "str": target_intent_result
+                    },
+                    "projectKind": "Orchestration",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
                 # response body for status code(s): 200
                 response == analyze_conversation_task_result
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
@@ -241,15 +386,15 @@
         _json = None
         _content = None
         if isinstance(task, (IO, bytes)):
             _content = task
         else:
             _json = task
 
-        request = build_analyze_conversation_request(
+        request = build_conversation_analysis_analyze_conversation_request(
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
         )
@@ -275,15 +420,20 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     def _conversation_analysis_initial(self, task: Union[JSON, IO], **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -292,15 +442,15 @@
         _json = None
         _content = None
         if isinstance(task, (IO, bytes)):
             _content = task
         else:
             _json = task
 
-        request = build_conversation_analysis_request(
+        request = build_conversation_analysis_conversation_analysis_request(
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
         )
@@ -342,14 +492,18 @@
         self, task: JSON, *, content_type: str = "application/json", **kwargs: Any
     ) -> LROPoller[JSON]:
         """Submit analysis job for conversations.
 
         Submit a collection of conversations for analysis. Specify one or more unique tasks to be
         executed.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime/submit-job
+        for more information.
+
         :param task: The collection of conversations to analyze and one or more tasks to execute.
          Required.
         :type task: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -369,100 +523,111 @@
                 # JSON input template you can fill out and use as your body input.
                 task = {
                     "analysisInput": {
                         "conversations": [
                             conversation
                         ]
                     },
-                    "displayName": "str",  # Optional. Optional display name for the analysis
-                      job.
                     "tasks": [
                         analyze_conversation_lro_task
-                    ]
+                    ],
+                    "displayName": "str"  # Optional. Optional display name for the analysis job.
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Required.
+                    "jobId": "str",  # Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
+                    "status": "str",  # The status of the task at the mentioned last update time.
+                      Required. Known values are: "notStarted", "running", "succeeded", "failed",
+                      "cancelled", "cancelling", and "partiallyCompleted".
+                    "tasks": {
+                        "completed": 0,  # Count of tasks completed successfully. Required.
+                        "failed": 0,  # Count of tasks that failed. Required.
+                        "inProgress": 0,  # Count of tasks in progress currently. Required.
+                        "total": 0,  # Total count of tasks submitted as part of the job.
+                          Required.
+                        "items": [
+                            analyze_conversation_job_result
+                        ]
+                    },
                     "displayName": "str",  # Optional.
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional.
-                    "jobId": "str",  # Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
                     "nextLink": "str",  # Optional.
                     "statistics": {
                         "conversationsCount": 0,  # Number of conversations submitted in the
                           request. Required.
+                        "documentsCount": 0,  # Number of documents submitted in the request.
+                          Required.
                         "erroneousConversationsCount": 0,  # Number of invalid documents.
                           This includes empty, over-size limit or non-supported languages documents.
                           Required.
+                        "erroneousDocumentsCount": 0,  # Number of invalid documents. This
+                          includes empty, over-size limit or non-supported languages documents.
+                          Required.
                         "transactionsCount": 0,  # Number of transactions for the request.
                           Required.
-                        "validConversationsCount": 0  # Number of conversations documents.
+                        "validConversationsCount": 0,  # Number of conversations documents.
                           This excludes empty, over-size limit or non-supported languages documents.
                           Required.
-                    },
-                    "status": "str",  # Required. Known values are: "notStarted", "running",
-                      "succeeded", "partiallyCompleted", "failed", "cancelled", and "cancelling".
-                    "tasks": {
-                        "completed": 0,  # Count of tasks completed successfully. Required.
-                        "failed": 0,  # Count of tasks that failed. Required.
-                        "inProgress": 0,  # Count of tasks in progress currently. Required.
-                        "items": [
-                            analyze_conversation_job_result
-                        ],
-                        "total": 0  # Total count of tasks submitted as part of the job.
-                          Required.
+                        "validDocumentsCount": 0  # Number of valid documents. This excludes
+                          empty, over-size limit or non-supported languages documents. Required.
                     }
                 }
         """
 
     @overload
     def begin_conversation_analysis(
         self, task: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> LROPoller[JSON]:
         """Submit analysis job for conversations.
 
         Submit a collection of conversations for analysis. Specify one or more unique tasks to be
         executed.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime/submit-job
+        for more information.
+
         :param task: The collection of conversations to analyze and one or more tasks to execute.
          Required.
         :type task: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -478,88 +643,100 @@
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Required.
+                    "jobId": "str",  # Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
+                    "status": "str",  # The status of the task at the mentioned last update time.
+                      Required. Known values are: "notStarted", "running", "succeeded", "failed",
+                      "cancelled", "cancelling", and "partiallyCompleted".
+                    "tasks": {
+                        "completed": 0,  # Count of tasks completed successfully. Required.
+                        "failed": 0,  # Count of tasks that failed. Required.
+                        "inProgress": 0,  # Count of tasks in progress currently. Required.
+                        "total": 0,  # Total count of tasks submitted as part of the job.
+                          Required.
+                        "items": [
+                            analyze_conversation_job_result
+                        ]
+                    },
                     "displayName": "str",  # Optional.
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional.
-                    "jobId": "str",  # Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
                     "nextLink": "str",  # Optional.
                     "statistics": {
                         "conversationsCount": 0,  # Number of conversations submitted in the
                           request. Required.
+                        "documentsCount": 0,  # Number of documents submitted in the request.
+                          Required.
                         "erroneousConversationsCount": 0,  # Number of invalid documents.
                           This includes empty, over-size limit or non-supported languages documents.
                           Required.
+                        "erroneousDocumentsCount": 0,  # Number of invalid documents. This
+                          includes empty, over-size limit or non-supported languages documents.
+                          Required.
                         "transactionsCount": 0,  # Number of transactions for the request.
                           Required.
-                        "validConversationsCount": 0  # Number of conversations documents.
+                        "validConversationsCount": 0,  # Number of conversations documents.
                           This excludes empty, over-size limit or non-supported languages documents.
                           Required.
-                    },
-                    "status": "str",  # Required. Known values are: "notStarted", "running",
-                      "succeeded", "partiallyCompleted", "failed", "cancelled", and "cancelling".
-                    "tasks": {
-                        "completed": 0,  # Count of tasks completed successfully. Required.
-                        "failed": 0,  # Count of tasks that failed. Required.
-                        "inProgress": 0,  # Count of tasks in progress currently. Required.
-                        "items": [
-                            analyze_conversation_job_result
-                        ],
-                        "total": 0  # Total count of tasks submitted as part of the job.
-                          Required.
+                        "validDocumentsCount": 0  # Number of valid documents. This excludes
+                          empty, over-size limit or non-supported languages documents. Required.
                     }
                 }
         """
 
     @distributed_trace
     def begin_conversation_analysis(self, task: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
         """Submit analysis job for conversations.
 
         Submit a collection of conversations for analysis. Specify one or more unique tasks to be
         executed.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime/submit-job
+        for more information.
+
         :param task: The collection of conversations to analyze and one or more tasks to execute. Is
          either a model type or a IO type. Required.
         :type task: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -575,77 +752,85 @@
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Required.
+                    "jobId": "str",  # Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
+                    "status": "str",  # The status of the task at the mentioned last update time.
+                      Required. Known values are: "notStarted", "running", "succeeded", "failed",
+                      "cancelled", "cancelling", and "partiallyCompleted".
+                    "tasks": {
+                        "completed": 0,  # Count of tasks completed successfully. Required.
+                        "failed": 0,  # Count of tasks that failed. Required.
+                        "inProgress": 0,  # Count of tasks in progress currently. Required.
+                        "total": 0,  # Total count of tasks submitted as part of the job.
+                          Required.
+                        "items": [
+                            analyze_conversation_job_result
+                        ]
+                    },
                     "displayName": "str",  # Optional.
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional.
-                    "jobId": "str",  # Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
                     "nextLink": "str",  # Optional.
                     "statistics": {
                         "conversationsCount": 0,  # Number of conversations submitted in the
                           request. Required.
+                        "documentsCount": 0,  # Number of documents submitted in the request.
+                          Required.
                         "erroneousConversationsCount": 0,  # Number of invalid documents.
                           This includes empty, over-size limit or non-supported languages documents.
                           Required.
+                        "erroneousDocumentsCount": 0,  # Number of invalid documents. This
+                          includes empty, over-size limit or non-supported languages documents.
+                          Required.
                         "transactionsCount": 0,  # Number of transactions for the request.
                           Required.
-                        "validConversationsCount": 0  # Number of conversations documents.
+                        "validConversationsCount": 0,  # Number of conversations documents.
                           This excludes empty, over-size limit or non-supported languages documents.
                           Required.
-                    },
-                    "status": "str",  # Required. Known values are: "notStarted", "running",
-                      "succeeded", "partiallyCompleted", "failed", "cancelled", and "cancelling".
-                    "tasks": {
-                        "completed": 0,  # Count of tasks completed successfully. Required.
-                        "failed": 0,  # Count of tasks that failed. Required.
-                        "inProgress": 0,  # Count of tasks in progress currently. Required.
-                        "items": [
-                            analyze_conversation_job_result
-                        ],
-                        "total": 0  # Total count of tasks submitted as part of the job.
-                          Required.
+                        "validDocumentsCount": 0  # Number of valid documents. This excludes
+                          empty, over-size limit or non-supported languages documents. Required.
                     }
                 }
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_serialization.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_serialization.py`

 * *Files 0% similar despite different names*

```diff
@@ -1501,15 +1501,15 @@
         :param str target_obj: The target object type to deserialize to.
         :param str/dict data: The response data to deseralize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
-            _LOGGER.warning(
+            _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
             )
             return None
 
     @staticmethod
     def _unpack_content(raw_data, content_type=None):
         """Extract the correct structure for deserialization.
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/__init__.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,22 +3,21 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._client import ConversationAuthoringClient
-from ._version import VERSION
-
-__version__ = VERSION
 
 try:
     from ._patch import __all__ as _patch_all
     from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
-__all__ = ["ConversationAuthoringClient"]
+__all__ = [
+    "ConversationAuthoringClient",
+]
 __all__.extend([p for p in _patch_all if p not in __all__])
 
 _patch_sdk()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_configuration.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_configuration.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,21 +2,27 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class ConversationAuthoringClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for ConversationAuthoringClient.
@@ -25,22 +31,22 @@
     attributes.
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
-    :keyword api_version: Api Version. Default value is "2022-05-15-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, endpoint: str, credential: "TokenCredential", **kwargs: Any) -> None:
         super(ConversationAuthoringClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "2022-05-15-preview")  # type: str
+        api_version = kwargs.pop("api_version", "2022-10-01-preview")  # type: Literal["2022-10-01-preview"]
 
         if endpoint is None:
             raise ValueError("Parameter 'endpoint' must not be None.")
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.endpoint = endpoint
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_client.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,34 +14,33 @@
 
 from ._configuration import ConversationAuthoringClientConfiguration
 from ._operations import ConversationAuthoringClientOperationsMixin
 from ._serialization import Deserializer, Serializer
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from typing import Dict
-
     from azure.core.credentials import TokenCredential
 
 
 class ConversationAuthoringClient(
     ConversationAuthoringClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The language service API is a suite of natural language processing (NLP) skills built with
     best-in-class Microsoft machine learning algorithms. The API can be used to analyze
     unstructured text for tasks such as sentiment analysis, key phrase extraction, language
     detection and question answering. Further documentation can be found in :code:`<a
-    href="https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview">https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview</a>`.
+    href="https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview">
+    https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview</a>`.
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
-    :keyword api_version: Api Version. Default value is "2022-05-15-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, endpoint: str, credential: "TokenCredential", **kwargs: Any) -> None:
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_patch.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_patch.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,36 +3,36 @@
 # Licensed under the MIT License.
 # ------------------------------------
 """Customize generated code here.
 
 Follow our quickstart for examples: https://aka.ms/azsdk/python/dpcodegen/python/customize
 """
 from typing import List, Union, Any
-from azure.core.credentials import AzureKeyCredential, TokenCredential
+from azure.core.credentials import AzureKeyCredential
+from azure.core.credentials_async import AsyncTokenCredential
 from azure.core.pipeline.policies import AzureKeyCredentialPolicy
 from ._client import ConversationAuthoringClient as GeneratedConversationAuthoringClient
+from .._patch import POLLING_INTERVAL_DEFAULT
 
 
 def _authentication_policy(credential):
     authentication_policy = None
     if credential is None:
         raise ValueError("Parameter 'credential' must not be None.")
     if isinstance(credential, AzureKeyCredential):
-        authentication_policy = AzureKeyCredentialPolicy(
-            name="Ocp-Apim-Subscription-Key", credential=credential
-        )
+        authentication_policy = AzureKeyCredentialPolicy(name="Ocp-Apim-Subscription-Key", credential=credential)
     elif credential is not None and not hasattr(credential, "get_token"):
         raise TypeError(
-            "Unsupported credential: {}. Use an instance of AzureKeyCredential "
-            "or a token credential from azure.identity".format(type(credential))
+            f"Unsupported credential: {type(credential)}. Use an instance of AzureKeyCredential "
+            "or a token credential from azure.identity"
         )
     return authentication_policy
 
 
-class ConversationAuthoringClient(GeneratedConversationAuthoringClient): # pylint: disable=client-accepts-api-version-keyword
+class ConversationAuthoringClient(GeneratedConversationAuthoringClient):
     """The language service API is a suite of natural language processing (NLP) skills built with
     best-in-class Microsoft machine learning algorithms. The API can be used to analyze
     unstructured text for tasks such as sentiment analysis, key phrase extraction, language
     detection and question answering. Further documentation can be found in
     https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview.
 
     See https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring for more information about
@@ -40,28 +40,36 @@
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure.
         This can be the an instance of AzureKeyCredential if using a Language API key
         or a token credential from :mod:`azure.identity`.
-    :type credential: ~azure.core.credentials.AzureKeyCredential or ~azure.core.credentials.TokenCredential
-    :keyword api_version: Api Version. Available values are "2022-05-15-preview" and "2022-05-01". Default
-     value is "2022-05-15-preview". Note that overriding this default value may result in unsupported behavior.
+    :type credential: ~azure.core.credentials.AzureKeyCredential or ~azure.core.credentials_async.AsyncTokenCredential
+    :keyword api_version: Api Version. Available values are "2022-10-01-preview", "2022-05-15-preview",
+     "2022-05-01". Default value is "2022-10-01-preview". Note that overriding this default value may result in
+     unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
-    def __init__(self, endpoint: str, credential: Union[AzureKeyCredential, TokenCredential], **kwargs: Any) -> None:
+    def __init__(
+        self, endpoint: str, credential: Union[AzureKeyCredential, AsyncTokenCredential], **kwargs: Any
+    ) -> None:
+        try:
+            endpoint = endpoint.rstrip("/")
+        except AttributeError:
+            raise ValueError("Parameter 'endpoint' must be a string.")
         super().__init__(
             endpoint=endpoint,
             credential=credential,  # type: ignore
             authentication_policy=kwargs.pop("authentication_policy", _authentication_policy(credential)),
-            **kwargs
+            polling_interval=kwargs.pop("polling_interval", POLLING_INTERVAL_DEFAULT),
+            **kwargs,
         )
 
 
 __all__: List[str] = ["ConversationAuthoringClient"]
 
 
 def patch_sdk():
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_vendor.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_vendor.py`

 * *Files 4% similar despite different names*

```diff
@@ -24,14 +24,14 @@
             return template.format(**kwargs)
         except KeyError as key:
             formatted_components = template.split("/")
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
-class MixinABC(ABC):
+class ConversationAuthoringClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
 
     _client: "PipelineClient"
     _config: ConversationAuthoringClientConfiguration
     _serialize: "Serializer"
     _deserialize: "Deserializer"
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/__init__.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/_operations/_operations.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_operations/_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,52 +4,61 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
-from urllib.parse import parse_qs, urljoin, urlparse
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.polling.base_polling import LROBasePolling
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 
 from .._serialization import Serializer
-from .._vendor import MixinABC, _format_url_section
+from .._vendor import ConversationAuthoringClientMixinABC, _format_url_section
 
 if sys.version_info >= (3, 9):
     from collections.abc import MutableMapping
 else:
     from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_projects_request(*, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_list_projects_request(
+    *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects"
 
     # Construct parameters
     if top is not None:
@@ -60,20 +69,22 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_create_project_request(project_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_create_project_request(project_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
     content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -87,19 +98,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_project_request(project_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_get_project_request(project_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -111,19 +124,21 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_delete_project_request(project_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_delete_project_request(project_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -135,26 +150,29 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_export_project_request(
+def build_conversation_authoring_export_project_request(
     project_name: str,
     *,
     string_index_type: str,
     exported_project_format: Optional[str] = None,
     asset_kind: Optional[str] = None,
+    trained_model_label: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/:export"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -163,29 +181,34 @@
 
     # Construct parameters
     if exported_project_format is not None:
         _params["format"] = _SERIALIZER.query("exported_project_format", exported_project_format, "str")
     _params["stringIndexType"] = _SERIALIZER.query("string_index_type", string_index_type, "str")
     if asset_kind is not None:
         _params["assetKind"] = _SERIALIZER.query("asset_kind", asset_kind, "str")
+    if trained_model_label is not None:
+        _params["trainedModelLabel"] = _SERIALIZER.query("trained_model_label", trained_model_label, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_import_project_request(project_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_import_project_request(
+    project_name: str, *, exported_project_format: Optional[str] = None, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    exported_project_format = kwargs.pop("exported_project_format", _params.pop("format", None))  # type: Optional[str]
     content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/:import"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -201,20 +224,22 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_train_request(project_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_train_request(project_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
     content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/:train"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -228,21 +253,23 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_deployments_request(
+def build_conversation_authoring_list_deployments_request(
     project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/deployments"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -258,20 +285,22 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_swap_deployments_request(project_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_swap_deployments_request(project_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
     content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/deployments/:swap"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -285,19 +314,23 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_deployment_request(project_name: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_get_deployment_request(
+    project_name: str, deployment_name: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/deployments/{deploymentName}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "deploymentName": _SERIALIZER.url("deployment_name", deployment_name, "str"),
@@ -310,20 +343,24 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_deploy_project_request(project_name: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_deploy_project_request(
+    project_name: str, deployment_name: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
     content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/deployments/{deploymentName}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "deploymentName": _SERIALIZER.url("deployment_name", deployment_name, "str"),
@@ -338,19 +375,23 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_delete_deployment_request(project_name: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_delete_deployment_request(
+    project_name: str, deployment_name: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/deployments/{deploymentName}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "deploymentName": _SERIALIZER.url("deployment_name", deployment_name, "str"),
@@ -363,21 +404,85 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_deployment_job_status_request(
+def build_conversation_authoring_delete_deployment_from_resources_request(
+    project_name: str, deployment_name: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/{projectName}/deployments/{deploymentName}/:delete-from-resources"
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+        "deploymentName": _SERIALIZER.url("deployment_name", deployment_name, "str"),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_get_deployment_delete_from_resources_status_request(
     project_name: str, deployment_name: str, job_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/{projectName}/deployments/{deploymentName}/delete-from-resources/jobs/{jobId}"  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+        "deploymentName": _SERIALIZER.url("deployment_name", deployment_name, "str"),
+        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_get_deployment_job_status_request(
+    project_name: str, deployment_name: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/deployments/{deploymentName}/jobs/{jobId}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "deploymentName": _SERIALIZER.url("deployment_name", deployment_name, "str"),
@@ -391,19 +496,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_swap_deployments_job_status_request(project_name: str, job_id: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_get_swap_deployments_job_status_request(
+    project_name: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/deployments/swap/jobs/{jobId}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
@@ -416,19 +525,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_export_project_job_status_request(project_name: str, job_id: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_get_export_project_job_status_request(
+    project_name: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/export/jobs/{jobId}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
@@ -441,19 +554,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_import_project_job_status_request(project_name: str, job_id: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_get_import_project_job_status_request(
+    project_name: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/import/jobs/{jobId}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
@@ -466,21 +583,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_trained_models_request(
+def build_conversation_authoring_list_trained_models_request(
     project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/models"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -496,19 +615,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_trained_model_request(project_name: str, trained_model_label: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_get_trained_model_request(
+    project_name: str, trained_model_label: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/models/{trainedModelLabel}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "trainedModelLabel": _SERIALIZER.url("trained_model_label", trained_model_label, "str"),
@@ -521,19 +644,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_delete_trained_model_request(project_name: str, trained_model_label: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_delete_trained_model_request(
+    project_name: str, trained_model_label: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/models/{trainedModelLabel}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "trainedModelLabel": _SERIALIZER.url("trained_model_label", trained_model_label, "str"),
@@ -546,27 +673,58 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_model_evaluation_results_request(
+def build_conversation_authoring_load_snapshot_request(
+    project_name: str, trained_model_label: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/{projectName}/models/{trainedModelLabel}/:load-snapshot"
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+        "trainedModelLabel": _SERIALIZER.url("trained_model_label", trained_model_label, "str"),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_list_model_evaluation_results_request(
     project_name: str,
     trained_model_label: str,
     *,
     string_index_type: str,
     top: Optional[int] = None,
     skip: Optional[int] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/models/{trainedModelLabel}/evaluation/result"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "trainedModelLabel": _SERIALIZER.url("trained_model_label", trained_model_label, "str"),
@@ -584,21 +742,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_model_evaluation_summary_request(
+def build_conversation_authoring_get_model_evaluation_summary_request(
     project_name: str, trained_model_label: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = (
         "/authoring/analyze-conversations/projects/{projectName}/models/{trainedModelLabel}/evaluation/summary-result"
     )
     path_format_arguments = {
@@ -613,21 +773,203 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_training_jobs_request(
+def build_conversation_authoring_get_load_snapshot_status_request(
+    project_name: str, trained_model_label: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = (
+        "/authoring/analyze-conversations/projects/{projectName}/models/{trainedModelLabel}/load-snapshot/jobs/{jobId}"
+    )
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+        "trainedModelLabel": _SERIALIZER.url("trained_model_label", trained_model_label, "str"),
+        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_list_deployment_resources_request(
+    project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/{projectName}/resources"
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    if top is not None:
+        _params["top"] = _SERIALIZER.query("top", top, "int")
+    if skip is not None:
+        _params["skip"] = _SERIALIZER.query("skip", skip, "int")
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_assign_deployment_resources_request(project_name: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/{projectName}/resources/:assign"
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_unassign_deployment_resources_request(project_name: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/{projectName}/resources/:unassign"
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_get_assign_deployment_resources_status_request(
+    project_name: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/{projectName}/resources/assign/jobs/{jobId}"
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_get_unassign_deployment_resources_status_request(
+    project_name: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/{projectName}/resources/unassign/jobs/{jobId}"
+    path_format_arguments = {
+        "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
+        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
+    }
+
+    _url = _format_url_section(_url, **path_format_arguments)
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_list_training_jobs_request(
     project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/train/jobs"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
     }
@@ -643,19 +985,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_training_job_status_request(project_name: str, job_id: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_get_training_job_status_request(
+    project_name: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/train/jobs/{jobId}"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
@@ -668,19 +1014,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_cancel_training_job_request(project_name: str, job_id: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_cancel_training_job_request(
+    project_name: str, job_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/{projectName}/train/jobs/{jobId}/:cancel"
     path_format_arguments = {
         "projectName": _SERIALIZER.url("project_name", project_name, "str", max_length=100),
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
@@ -693,19 +1043,21 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_project_deletion_job_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
+def build_conversation_authoring_get_project_deletion_job_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/global/deletion-jobs/{jobId}"
     path_format_arguments = {
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
     }
@@ -717,21 +1069,50 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_supported_languages_request(
+def build_conversation_authoring_list_assigned_resource_deployments_request(
+    *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = "/authoring/analyze-conversations/projects/global/deployments/resources"
+
+    # Construct parameters
+    if top is not None:
+        _params["top"] = _SERIALIZER.query("top", top, "int")
+    if skip is not None:
+        _params["skip"] = _SERIALIZER.query("skip", skip, "int")
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_conversation_authoring_list_supported_languages_request(
     *, project_kind: str, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/global/languages"
 
     # Construct parameters
     _params["projectKind"] = _SERIALIZER.query("project_kind", project_kind, "str")
@@ -743,26 +1124,28 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_supported_prebuilt_entities_request(
+def build_conversation_authoring_list_supported_prebuilt_entities_request(
     *,
     language: Optional[str] = None,
     multilingual: Optional[bool] = None,
     top: Optional[int] = None,
     skip: Optional[int] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/global/prebuilt-entities"
 
     # Construct parameters
     if language is not None:
@@ -777,21 +1160,23 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_training_config_versions_request(
+def build_conversation_authoring_list_training_config_versions_request(
     *, project_kind: str, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-15-preview"))  # type: str
+    api_version = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-10-01-preview")
+    )  # type: Literal["2022-10-01-preview"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = "/authoring/analyze-conversations/projects/global/training-config-versions"
 
     # Construct parameters
     _params["projectKind"] = _SERIALIZER.query("project_kind", project_kind, "str")
@@ -803,19 +1188,25 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ConversationAuthoringClientOperationsMixin(MixinABC):  # pylint: disable=too-many-public-methods
+class ConversationAuthoringClientOperationsMixin(
+    ConversationAuthoringClientMixinABC
+):  # pylint: disable=too-many-public-methods
     @distributed_trace
     def list_projects(self, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any) -> Iterable[JSON]:
         """Lists the existing projects.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-projects
+        for more information.
+
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
         :paramtype skip: int
         :return: An iterator like instance of JSON object
@@ -825,48 +1216,56 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_projects_request(
+                request = build_conversation_authoring_list_projects_request(
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
                 path_format_arguments = {
@@ -874,18 +1273,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -916,14 +1322,18 @@
 
     @overload
     def create_project(
         self, project_name: str, project: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
     ) -> JSON:
         """Creates a new project or updates an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/create-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project parameters. Required.
         :type project: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/merge-patch+json".
         :paramtype content_type: str
@@ -932,63 +1342,73 @@
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # JSON input template you can fill out and use as your body input.
                 project = {
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "multilingual": bool,  # Optional. Whether the project would be used for
-                      multiple languages or not.
                     "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
                     "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "multilingual": bool,  # Optional. Whether the project would be used for
+                      multiple languages or not.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
 
                 # response body for status code(s): 200, 201
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
 
     @overload
     def create_project(
         self, project_name: str, project: IO, *, content_type: str = "application/merge-patch+json", **kwargs: Any
     ) -> JSON:
         """Creates a new project or updates an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/create-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project parameters. Required.
         :type project: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/merge-patch+json".
         :paramtype content_type: str
@@ -999,41 +1419,48 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200, 201
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
 
     @distributed_trace
     def create_project(self, project_name: str, project: Union[JSON, IO], **kwargs: Any) -> JSON:
         """Creates a new project or updates an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/create-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project parameters. Is either a model type or a IO type. Required.
         :type project: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are:
          'application/merge-patch+json'. Default value is None.
         :paramtype content_type: str
@@ -1044,37 +1471,45 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200, 201
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
@@ -1083,15 +1518,15 @@
         _json = None
         _content = None
         if isinstance(project, (IO, bytes)):
             _content = project
         else:
             _json = project
 
-        request = build_create_project_request(
+        request = build_conversation_authoring_create_project_request(
             project_name=project_name,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
@@ -1128,58 +1563,70 @@
 
         return cast(JSON, deserialized)
 
     @distributed_trace
     def get_project(self, project_name: str, **kwargs: Any) -> JSON:
         """Gets the details of a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_project_request(
+        request = build_conversation_authoring_get_project_request(
             project_name=project_name,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
@@ -1203,23 +1650,28 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     def _delete_project_initial(self, project_name: str, **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
 
-        request = build_delete_project_request(
+        request = build_conversation_authoring_delete_project_request(
             project_name=project_name,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
@@ -1254,14 +1706,18 @@
 
         return deserialized
 
     @distributed_trace
     def begin_delete_project(self, project_name: str, **kwargs: Any) -> LROPoller[JSON]:
         """Deletes a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
@@ -1274,57 +1730,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1376,29 +1832,36 @@
     def _export_project_initial(
         self,
         project_name: str,
         *,
         string_index_type: str,
         exported_project_format: Optional[str] = None,
         asset_kind: Optional[str] = None,
+        trained_model_label: Optional[str] = None,
         **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
 
-        request = build_export_project_request(
+        request = build_conversation_authoring_export_project_request(
             project_name=project_name,
             string_index_type=string_index_type,
             exported_project_format=exported_project_format,
             asset_kind=asset_kind,
+            trained_model_label=trained_model_label,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
         }
@@ -1436,28 +1899,36 @@
     def begin_export_project(
         self,
         project_name: str,
         *,
         string_index_type: str,
         exported_project_format: Optional[str] = None,
         asset_kind: Optional[str] = None,
+        trained_model_label: Optional[str] = None,
         **kwargs: Any
     ) -> LROPoller[JSON]:
         """Triggers a job to export a project's data.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/export
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword string_index_type: Specifies the method used to interpret string offsets. For
          additional information see https://aka.ms/text-analytics-offsets. "Utf16CodeUnit" Required.
         :paramtype string_index_type: str
         :keyword exported_project_format: The format of the exported project file to use. Known values
          are: "Conversation" and "Luis". Default value is None.
         :paramtype exported_project_format: str
         :keyword asset_kind: Kind of asset to export. Default value is None.
         :paramtype asset_kind: str
+        :keyword trained_model_label: Trained model label to export. If the trainedModelLabel is null,
+         the default behavior is to export the current working copy. Default value is None.
+        :paramtype trained_model_label: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
@@ -1468,59 +1939,59 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
                     "resultUrl": "str",  # Optional. The URL to use in order to download the
                       exported project.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1534,14 +2005,15 @@
         cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
             raw_result = self._export_project_initial(  # type: ignore
                 project_name=project_name,
                 string_index_type=string_index_type,
                 exported_project_format=exported_project_format,
                 asset_kind=asset_kind,
+                trained_model_label=trained_model_label,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
@@ -1580,15 +2052,20 @@
         self,
         project_name: str,
         project: Union[JSON, IO],
         *,
         exported_project_format: Optional[str] = None,
         **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -1597,15 +2074,15 @@
         _json = None
         _content = None
         if isinstance(project, (IO, bytes)):
             _content = project
         else:
             _json = project
 
-        request = build_import_project_request(
+        request = build_conversation_authoring_import_project_request(
             project_name=project_name,
             exported_project_format=exported_project_format,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
@@ -1653,14 +2130,18 @@
         exported_project_format: Optional[str] = None,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[JSON]:
         """Triggers a job to import a project. If a project with the same name already exists, the data of
         that project is replaced.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/import
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project data to import. Required.
         :type project: JSON
         :keyword exported_project_format: The format of the exported project file to use. Known values
          are: "Conversation" and "Luis". Default value is None.
         :paramtype exported_project_format: str
@@ -1677,86 +2158,200 @@
         :return: An instance of LROPoller that returns JSON object
         :rtype: ~azure.core.polling.LROPoller[JSON]
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
+                # The input is polymorphic. The following are possible polymorphic inputs based off
+                  discriminator "projectKind":
+
+                # JSON input template for discriminator value "Conversation":
+                exported_project_assets = {
+                    "projectKind": "Conversation",
+                    "entities": [
+                        {
+                            "category": "str",  # The category of the entity. Required.
+                            "compositionSetting": "str",  # Optional. The behavior to
+                              follow when the entity's components overlap with each other. Known values
+                              are: "returnLongestOverlap", "requireExactOverlap", "separateComponents",
+                              and "combineComponents".
+                            "list": {
+                                "sublists": [
+                                    {
+                                        "listKey": "str",  # Optional. The
+                                          key of the sub-list.
+                                        "synonyms": [
+                                            {
+                                                "language": "str",  #
+                                                  Optional. Represents the language of the synonyms.
+                                                  This is BCP-47 representation of a language. For
+                                                  example, use "en" for English, "en-gb" for English
+                                                  (UK), "es" for Spanish etc.
+                                                "values": [
+                                                    "str"  #
+                                                      Optional. The list of synonyms.
+                                                ]
+                                            }
+                                        ]
+                                    }
+                                ]
+                            },
+                            "prebuilts": [
+                                {
+                                    "category": "str"  # The prebuilt entity
+                                      category. Required.
+                                }
+                            ],
+                            "regex": {
+                                "expressions": [
+                                    {
+                                        "language": "str",  # Optional.
+                                          Represents the language of the regex expression. This is
+                                          BCP-47 representation of a language. For example, use "en"
+                                          for English, "en-gb" for English (UK), "es" for Spanish etc.
+                                        "regexKey": "str",  # Optional. The
+                                          key of the regex expression.
+                                        "regexPattern": "str"  # Optional.
+                                          The regex pattern.
+                                    }
+                                ]
+                            },
+                            "requiredComponents": [
+                                "str"  # Optional. The required components. Allowed
+                                  values are 'learned', 'list', 'prebuilts' and 'regex'.
+                            ]
+                        }
+                    ],
+                    "intents": [
+                        {
+                            "category": "str"  # The intent category. Required.
+                        }
+                    ],
+                    "utterances": [
+                        {
+                            "intent": "str",  # The intent of the utterance. Required.
+                            "text": "str",  # The utterance text. Required.
+                            "dataset": "str",  # Optional. The dataset for this
+                              utterance. Allowed values are 'Train' and 'Test'.
+                            "entities": [
+                                {
+                                    "category": "str",  # The category of the
+                                      entity label. Required.
+                                    "length": 0,  # Length for the entity text.
+                                      Required.
+                                    "offset": 0  # Start position for the entity
+                                      text. Required.
+                                }
+                            ],
+                            "language": "str"  # Optional. Represents the utterance's
+                              language. This is BCP-47 representation of a language. For example, use
+                              "en" for English, "en-gb" for English (UK), "es" for Spanish etc.
+                        }
+                    ]
+                }
+
+                # JSON input template for discriminator value "Orchestration":
+                exported_project_assets = {
+                    "projectKind": "Orchestration",
+                    "intents": [
+                        {
+                            "category": "str",  # The intent category. Required.
+                            "orchestration": exported_orchestration_options
+                        }
+                    ],
+                    "utterances": [
+                        {
+                            "intent": "str",  # The intent of the utterance. Required.
+                            "text": "str",  # The utterance text. Required.
+                            "dataset": "str",  # Optional. The dataset for this
+                              utterance. Allowed values are 'Train' and 'Test'.
+                            "language": "str"  # Optional. Represents the utterance's
+                              language. This is BCP-47 representation of a language. For example, use
+                              "en" for English, "en-gb" for English (UK), "es" for Spanish etc.
+                        }
+                    ]
+                }
+
                 # JSON input template you can fill out and use as your body input.
                 project = {
-                    "assets": exported_project_assets,
                     "metadata": {
-                        "description": "str",  # Optional. The project description.
                         "language": "str",  # The project language. This is BCP-47
                           representation of a language. For example, use "en" for English, "en-gb" for
                           English (UK), "es" for Spanish etc. Required.
-                        "multilingual": bool,  # Optional. Whether the project would be used
-                          for multiple languages or not.
                         "projectKind": "str",  # Represents the project kind. Required. Known
-                          values are: "Conversation" and "Orchestration".
+                          values are: "Conversation", "Orchestration", and
+                          "CustomConversationSummarization".
                         "projectName": "str",  # The new project name. Required.
+                        "description": "str",  # Optional. The project description.
+                        "multilingual": bool,  # Optional. Whether the project would be used
+                          for multiple languages or not.
                         "settings": {
                             "confidenceThreshold": 0.0  # The threshold of the intent
                               with the highest confidence, at which the prediction will automatically
-                              be changed to "None". Required.
-                        }
+                              be changed to "None". The value of the threshold should be between 0 and
+                              1 inclusive. Required.
+                        },
+                        "storageInputContainerName": "str"  # Optional. The storage container
+                          name in case of conversation summarization.
                     },
                     "projectFileVersion": "str",  # The version of the exported file. Required.
-                    "stringIndexType": "str"  # Specifies the method used to interpret string
+                    "stringIndexType": "str",  # Specifies the method used to interpret string
                       offsets. For additional information see https://aka.ms/text-analytics-offsets.
                       Required. "Utf16CodeUnit"
+                    "assets": exported_project_assets
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1771,14 +2366,18 @@
         exported_project_format: Optional[str] = None,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[JSON]:
         """Triggers a job to import a project. If a project with the same name already exists, the data of
         that project is replaced.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/import
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project data to import. Required.
         :type project: IO
         :keyword exported_project_format: The format of the exported project file to use. Known values
          are: "Conversation" and "Luis". Default value is None.
         :paramtype exported_project_format: str
@@ -1799,57 +2398,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1863,14 +2462,18 @@
         *,
         exported_project_format: Optional[str] = None,
         **kwargs: Any
     ) -> LROPoller[JSON]:
         """Triggers a job to import a project. If a project with the same name already exists, the data of
         that project is replaced.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/import
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project data to import. Is either a model type or a IO type. Required.
         :type project: JSON or IO
         :keyword exported_project_format: The format of the exported project file to use. Known values
          are: "Conversation" and "Luis". Default value is None.
         :paramtype exported_project_format: str
@@ -1891,57 +2494,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1995,15 +2598,20 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
     def _train_initial(self, project_name: str, configuration: Union[JSON, IO], **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -2012,15 +2620,15 @@
         _json = None
         _content = None
         if isinstance(configuration, (IO, bytes)):
             _content = configuration
         else:
             _json = configuration
 
-        request = build_train_request(
+        request = build_conversation_authoring_train_request(
             project_name=project_name,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
@@ -2060,14 +2668,18 @@
 
     @overload
     def begin_train(
         self, project_name: str, configuration: JSON, *, content_type: str = "application/json", **kwargs: Any
     ) -> LROPoller[JSON]:
         """Triggers a training job for a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/train
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param configuration: The training input parameters. Required.
         :type configuration: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -2083,113 +2695,113 @@
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # JSON input template you can fill out and use as your body input.
                 configuration = {
+                    "modelLabel": "str",  # Represents the output model label. Required.
+                    "trainingMode": "str",  # Represents the mode of the training operation.
+                      Required. Known values are: "advanced" and "standard".
                     "evaluationOptions": {
                         "kind": "str",  # Optional. Represents the evaluation kind. By
                           default, the evaluation kind is set to percentage. Known values are:
                           "percentage" and "manual".
                         "testingSplitPercentage": 0,  # Optional. Represents the testing
                           dataset split percentage. Only needed in case the evaluation kind is
                           percentage.
                         "trainingSplitPercentage": 0  # Optional. Represents the training
                           dataset split percentage. Only needed in case the evaluation kind is
                           percentage.
                     },
-                    "modelLabel": "str",  # Represents the output model label. Required.
-                    "trainingConfigVersion": "str",  # Optional. Represents training config
+                    "trainingConfigVersion": "str"  # Optional. Represents training config
                       version. By default, "latest" value is used which uses the latest released
                       training config version.
-                    "trainingMode": "str"  # Represents the mode of the training operation.
-                      Required. Known values are: "advanced" and "standard".
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -2197,14 +2809,18 @@
 
     @overload
     def begin_train(
         self, project_name: str, configuration: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> LROPoller[JSON]:
         """Triggers a training job for a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/train
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param configuration: The training input parameters. Required.
         :type configuration: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -2222,103 +2838,107 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
 
     @distributed_trace
     def begin_train(self, project_name: str, configuration: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
         """Triggers a training job for a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/train
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param configuration: The training input parameters. Is either a model type or a IO type.
          Required.
         :type configuration: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -2337,90 +2957,90 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -2478,14 +3098,18 @@
 
     @distributed_trace
     def list_deployments(
         self, project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> Iterable[JSON]:
         """Lists the deployments belonging to a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-deployments
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
@@ -2503,30 +3127,42 @@
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_deployments_request(
+                request = build_conversation_authoring_list_deployments_request(
                     project_name=project_name,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -2535,18 +3171,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -2574,15 +3217,20 @@
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     def _swap_deployments_initial(
         self, project_name: str, deployments: Union[JSON, IO], **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -2591,15 +3239,15 @@
         _json = None
         _content = None
         if isinstance(deployments, (IO, bytes)):
             _content = deployments
         else:
             _json = deployments
 
-        request = build_swap_deployments_request(
+        request = build_conversation_authoring_swap_deployments_request(
             project_name=project_name,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
@@ -2639,14 +3287,18 @@
 
     @overload
     def begin_swap_deployments(
         self, project_name: str, deployments: JSON, *, content_type: str = "application/json", **kwargs: Any
     ) -> LROPoller[JSON]:
         """Swaps two existing deployments with each other.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/swap-deployments
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployments: The job object to swap two deployments. Required.
         :type deployments: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -2672,57 +3324,57 @@
                       Required.
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -2730,14 +3382,18 @@
 
     @overload
     def begin_swap_deployments(
         self, project_name: str, deployments: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> LROPoller[JSON]:
         """Swaps two existing deployments with each other.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/swap-deployments
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployments: The job object to swap two deployments. Required.
         :type deployments: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -2755,70 +3411,74 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
 
     @distributed_trace
     def begin_swap_deployments(self, project_name: str, deployments: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
         """Swaps two existing deployments with each other.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/swap-deployments
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployments: The job object to swap two deployments. Is either a model type or a IO
          type. Required.
         :type deployments: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -2837,57 +3497,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -2943,14 +3603,18 @@
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
     @distributed_trace
     def get_deployment(self, project_name: str, deployment_name: str, **kwargs: Any) -> JSON:
         """Gets the details of a deployment.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-deployment
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -2964,27 +3628,39 @@
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_deployment_request(
+        request = build_conversation_authoring_get_deployment_request(
             project_name=project_name,
             deployment_name=deployment_name,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3011,15 +3687,20 @@
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     def _deploy_project_initial(
         self, project_name: str, deployment_name: str, deployment: Union[JSON, IO], **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -3028,15 +3709,15 @@
         _json = None
         _content = None
         if isinstance(deployment, (IO, bytes)):
             _content = deployment
         else:
             _json = deployment
 
-        request = build_deploy_project_request(
+        request = build_conversation_authoring_deploy_project_request(
             project_name=project_name,
             deployment_name=deployment_name,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
@@ -3083,14 +3764,18 @@
         deployment: JSON,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[JSON]:
         """Creates a new deployment or replaces an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/deploy-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :param deployment: The new deployment info. Required.
         :type deployment: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -3108,29 +3793,42 @@
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # JSON input template you can fill out and use as your body input.
                 deployment = {
-                    "trainedModelLabel": "str"  # Represents the trained model label. Required.
+                    "trainedModelLabel": "str",  # Represents the trained model label. Required.
+                    "assignedResourceIds": [
+                        "str"  # Optional. Represents the resource IDs to be assigned to the
+                          deployment."n            If provided, the deployment will be rolled out to
+                          the resources provided here as well as the original resource in which the
+                          project is created.
+                    ]
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "deploymentExpirationDate": "2020-02-20",  # Represents deployment expiration
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
 
     @overload
     def begin_deploy_project(
         self,
         project_name: str,
@@ -3138,14 +3836,18 @@
         deployment: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[JSON]:
         """Creates a new deployment or replaces an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/deploy-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :param deployment: The new deployment info. Required.
         :type deployment: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -3171,25 +3873,36 @@
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
 
     @distributed_trace
     def begin_deploy_project(
         self, project_name: str, deployment_name: str, deployment: Union[JSON, IO], **kwargs: Any
     ) -> LROPoller[JSON]:
         """Creates a new deployment or replaces an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/deploy-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :param deployment: The new deployment info. Is either a model type or a IO type. Required.
         :type deployment: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
@@ -3215,16 +3928,23 @@
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
@@ -3272,23 +3992,28 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
     def _delete_deployment_initial(self, project_name: str, deployment_name: str, **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
 
-        request = build_delete_deployment_request(
+        request = build_conversation_authoring_delete_deployment_request(
             project_name=project_name,
             deployment_name=deployment_name,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3324,14 +4049,18 @@
 
         return deserialized
 
     @distributed_trace
     def begin_delete_deployment(self, project_name: str, deployment_name: str, **kwargs: Any) -> LROPoller[JSON]:
         """Deletes a project deployment.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-deployment
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
@@ -3346,57 +4075,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -3446,17 +4175,244 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
+    def _delete_deployment_from_resources_initial(  # pylint: disable=inconsistent-return-statements
+        self, project_name: str, deployment_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IO, bytes)):
+            _content = body
+        else:
+            _json = body
+
+        request = build_conversation_authoring_delete_deployment_from_resources_request(
+            project_name=project_name,
+            deployment_name=deployment_name,
+            content_type=content_type,
+            api_version=self._config.api_version,
+            json=_json,
+            content=_content,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        response_headers = {}
+        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    @overload
+    def begin_delete_deployment_from_resources(
+        self,
+        project_name: str,
+        deployment_name: str,
+        body: JSON,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a project deployment from the specified assigned resources.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-deployment-from-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param deployment_name: The name of the specific deployment of the project to use. Required.
+        :type deployment_name: str
+        :param body: The options for deleting the deployment. Required.
+        :type body: JSON
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns None
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # JSON input template you can fill out and use as your body input.
+                body = {
+                    "assignedResourceIds": [
+                        "str"  # Optional. Represents the resource IDs to delete the
+                          deployment from."n            If not provided, the deployment will be rolled
+                          out from all the resources it is deployed to."n            If provided, it
+                          will delete the deployment only from the specified assigned resources, and
+                          leave it for the rest.
+                    ]
+                }
+        """
+
+    @overload
+    def begin_delete_deployment_from_resources(
+        self,
+        project_name: str,
+        deployment_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a project deployment from the specified assigned resources.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-deployment-from-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param deployment_name: The name of the specific deployment of the project to use. Required.
+        :type deployment_name: str
+        :param body: The options for deleting the deployment. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns None
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace
+    def begin_delete_deployment_from_resources(
+        self, project_name: str, deployment_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a project deployment from the specified assigned resources.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-deployment-from-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param deployment_name: The name of the specific deployment of the project to use. Required.
+        :type deployment_name: str
+        :param body: The options for deleting the deployment. Is either a model type or a IO type.
+         Required.
+        :type body: JSON or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns None
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        if cont_token is None:
+            raw_result = self._delete_deployment_from_resources_initial(  # type: ignore
+                project_name=project_name,
+                deployment_name=deployment_name,
+                body=body,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+
+        if polling is True:
+            polling_method = cast(
+                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
+            )  # type: PollingMethod
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+
     @distributed_trace
-    def get_deployment_job_status(self, project_name: str, deployment_name: str, job_id: str, **kwargs: Any) -> JSON:
-        """Gets the status of an existing deployment job.
+    def get_deployment_delete_from_resources_status(
+        self, project_name: str, deployment_name: str, job_id: str, **kwargs: Any
+    ) -> JSON:
+        """Gets the status of an existing delete deployment from specific resources job.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-deployment-delete-from-resources-status
+        for more information.
 
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
@@ -3467,74 +4423,201 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        request = build_conversation_authoring_get_deployment_delete_from_resources_status_request(
+            project_name=project_name,
+            deployment_name=deployment_name,
+            job_id=job_id,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        if response.content:
+            deserialized = response.json()
+        else:
+            deserialized = None
+
+        if cls:
+            return cls(pipeline_response, cast(JSON, deserialized), {})
+
+        return cast(JSON, deserialized)
+
+    @distributed_trace
+    def get_deployment_job_status(self, project_name: str, deployment_name: str, job_id: str, **kwargs: Any) -> JSON:
+        """Gets the status of an existing deployment job.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-deployment-status
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param deployment_name: The name of the specific deployment of the project to use. Required.
+        :type deployment_name: str
+        :param job_id: The job ID. Required.
+        :type job_id: str
+        :return: JSON object
+        :rtype: JSON
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
                     "jobId": "str",  # The job ID. Required.
                     "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
                       was updated. Required.
                     "status": "str",  # The job status. Required. Known values are: "notStarted",
                       "running", "succeeded", "failed", "cancelled", "cancelling", and
                       "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_deployment_job_status_request(
+        request = build_conversation_authoring_get_deployment_job_status_request(
             project_name=project_name,
             deployment_name=deployment_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
@@ -3563,14 +4646,18 @@
 
         return cast(JSON, deserialized)
 
     @distributed_trace
     def get_swap_deployments_job_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status of an existing swap deployment job.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-swap-deployments-status
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -3578,74 +4665,79 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_swap_deployments_job_status_request(
+        request = build_conversation_authoring_get_swap_deployments_job_status_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3673,14 +4765,18 @@
 
         return cast(JSON, deserialized)
 
     @distributed_trace
     def get_export_project_job_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status of an export job. Once job completes, returns the project metadata, and assets.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-export-status
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -3688,76 +4784,81 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
                     "resultUrl": "str",  # Optional. The URL to use in order to download the
                       exported project.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_export_project_job_status_request(
+        request = build_conversation_authoring_get_export_project_job_status_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3785,14 +4886,18 @@
 
         return cast(JSON, deserialized)
 
     @distributed_trace
     def get_import_project_job_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status for an import.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-import-status
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -3800,74 +4905,79 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_import_project_job_status_request(
+        request = build_conversation_authoring_get_import_project_job_status_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3897,14 +5007,18 @@
 
     @distributed_trace
     def list_trained_models(
         self, project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> Iterable[JSON]:
         """Lists the trained models belonging to a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-trained-models
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
@@ -3921,30 +5035,37 @@
                     "label": "str",  # The trained model label. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # The last trained date time
                       of the model. Required.
                     "lastTrainingDurationInSeconds": 0,  # The duration of the model's last
                       training request in seconds. Required.
                     "modelExpirationDate": "2020-02-20",  # The model expiration date. Required.
                     "modelId": "str",  # The model ID. Required.
-                    "modelTrainingConfigVersion": "str"  # The model training config version.
+                    "modelTrainingConfigVersion": "str",  # The model training config version.
                       Required.
+                    "hasSnapshot": bool  # Optional. The flag to indicate if the trained model
+                      has a snapshot ready.
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_trained_models_request(
+                request = build_conversation_authoring_list_trained_models_request(
                     project_name=project_name,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -3953,18 +5074,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -3993,14 +5121,18 @@
 
         return ItemPaged(get_next, extract_data)
 
     @distributed_trace
     def get_trained_model(self, project_name: str, trained_model_label: str, **kwargs: Any) -> JSON:
         """Gets the details of a trained model.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-trained-model
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param trained_model_label: The trained model label. Required.
         :type trained_model_label: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -4013,27 +5145,34 @@
                     "label": "str",  # The trained model label. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # The last trained date time
                       of the model. Required.
                     "lastTrainingDurationInSeconds": 0,  # The duration of the model's last
                       training request in seconds. Required.
                     "modelExpirationDate": "2020-02-20",  # The model expiration date. Required.
                     "modelId": "str",  # The model ID. Required.
-                    "modelTrainingConfigVersion": "str"  # The model training config version.
+                    "modelTrainingConfigVersion": "str",  # The model training config version.
                       Required.
+                    "hasSnapshot": bool  # Optional. The flag to indicate if the trained model
+                      has a snapshot ready.
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_trained_model_request(
+        request = build_conversation_authoring_get_trained_model_request(
             project_name=project_name,
             trained_model_label=trained_model_label,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -4063,31 +5202,40 @@
 
     @distributed_trace
     def delete_trained_model(  # pylint: disable=inconsistent-return-statements
         self, project_name: str, trained_model_label: str, **kwargs: Any
     ) -> None:
         """Deletes an existing trained model.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-trained-model
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param trained_model_label: The trained model label. Required.
         :type trained_model_label: str
         :return: None
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[None]
 
-        request = build_delete_trained_model_request(
+        request = build_conversation_authoring_delete_trained_model_request(
             project_name=project_name,
             trained_model_label=trained_model_label,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -4104,28 +5252,216 @@
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response)
 
         if cls:
             return cls(pipeline_response, None, {})
 
+    def _load_snapshot_initial(self, project_name: str, trained_model_label: str, **kwargs: Any) -> Optional[JSON]:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
+
+        request = build_conversation_authoring_load_snapshot_request(
+            project_name=project_name,
+            trained_model_label=trained_model_label,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        deserialized = None
+        response_headers = {}
+        if response.status_code == 200:
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+
+        if response.status_code == 202:
+            response_headers["operation-location"] = self._deserialize(
+                "str", response.headers.get("operation-location")
+            )
+
+        if cls:
+            return cls(pipeline_response, deserialized, response_headers)
+
+        return deserialized
+
+    @distributed_trace
+    def begin_load_snapshot(self, project_name: str, trained_model_label: str, **kwargs: Any) -> LROPoller[JSON]:
+        """Restores the snapshot of this trained model to be the current working directory of the project.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/load-snapshot
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param trained_model_label: The trained model label. Required.
+        :type trained_model_label: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns JSON object
+        :rtype: ~azure.core.polling.LROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        if cont_token is None:
+            raw_result = self._load_snapshot_initial(  # type: ignore
+                project_name=project_name,
+                trained_model_label=trained_model_label,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):
+            response = pipeline_response.http_response
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+            if cls:
+                return cls(pipeline_response, deserialized, {})
+            return deserialized
+
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+
+        if polling is True:
+            polling_method = cast(
+                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
+            )  # type: PollingMethod
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+
     @distributed_trace
     def list_model_evaluation_results(
         self,
         project_name: str,
         trained_model_label: str,
         *,
         string_index_type: str,
         top: Optional[int] = None,
         skip: Optional[int] = None,
         **kwargs: Any
     ) -> Iterable[JSON]:
         """Gets the detailed results of the evaluation for a trained model. This includes the raw
         inference results for the data included in the evaluation process.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-model-evaluation-results
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param trained_model_label: The trained model label. Required.
         :type trained_model_label: str
         :keyword string_index_type: Specifies the method used to interpret string offsets. For
          additional information see https://aka.ms/text-analytics-offsets. "Utf16CodeUnit" Required.
         :paramtype string_index_type: str
@@ -4179,21 +5515,26 @@
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_model_evaluation_results_request(
+                request = build_conversation_authoring_list_model_evaluation_results_request(
                     project_name=project_name,
                     trained_model_label=trained_model_label,
                     string_index_type=string_index_type,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
@@ -4204,18 +5545,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -4245,14 +5593,18 @@
         return ItemPaged(get_next, extract_data)
 
     @distributed_trace
     def get_model_evaluation_summary(self, project_name: str, trained_model_label: str, **kwargs: Any) -> JSON:
         """Gets the evaluation summary of a trained model. The summary includes high level performance
         measurements of the model e.g., F1, Precision, Recall, etc.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-model-evaluation-summary
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param trained_model_label: The trained model label. Required.
         :type trained_model_label: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -4294,25 +5646,14 @@
                         "macroF1": 0.0,  # Represents the macro F1. Required.
                         "macroPrecision": 0.0,  # Represents the macro precision. Required.
                         "macroRecall": 0.0,  # Represents the macro recall. Required.
                         "microF1": 0.0,  # Represents the micro F1. Required.
                         "microPrecision": 0.0,  # Represents the micro precision. Required.
                         "microRecall": 0.0  # Represents the micro recall. Required.
                     },
-                    "evaluationOptions": {
-                        "kind": "str",  # Optional. Represents the evaluation kind. By
-                          default, the evaluation kind is set to percentage. Known values are:
-                          "percentage" and "manual".
-                        "testingSplitPercentage": 0,  # Optional. Represents the testing
-                          dataset split percentage. Only needed in case the evaluation kind is
-                          percentage.
-                        "trainingSplitPercentage": 0  # Optional. Represents the training
-                          dataset split percentage. Only needed in case the evaluation kind is
-                          percentage.
-                    },
                     "intentsEvaluation": {
                         "confusionMatrix": {
                             "str": {
                                 "str": {
                                     "normalizedValue": 0.0,  # Represents
                                       normalized value in percentages. Required.
                                     "rawValue": 0.0  # Represents raw value.
@@ -4340,26 +5681,42 @@
                         },
                         "macroF1": 0.0,  # Represents the macro F1. Required.
                         "macroPrecision": 0.0,  # Represents the macro precision. Required.
                         "macroRecall": 0.0,  # Represents the macro recall. Required.
                         "microF1": 0.0,  # Represents the micro F1. Required.
                         "microPrecision": 0.0,  # Represents the micro precision. Required.
                         "microRecall": 0.0  # Represents the micro recall. Required.
+                    },
+                    "evaluationOptions": {
+                        "kind": "str",  # Optional. Represents the evaluation kind. By
+                          default, the evaluation kind is set to percentage. Known values are:
+                          "percentage" and "manual".
+                        "testingSplitPercentage": 0,  # Optional. Represents the testing
+                          dataset split percentage. Only needed in case the evaluation kind is
+                          percentage.
+                        "trainingSplitPercentage": 0  # Optional. Represents the training
+                          dataset split percentage. Only needed in case the evaluation kind is
+                          percentage.
                     }
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_model_evaluation_summary_request(
+        request = build_conversation_authoring_get_model_evaluation_summary_request(
             project_name=project_name,
             trained_model_label=trained_model_label,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -4384,18 +5741,144 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     @distributed_trace
-    def list_training_jobs(
+    def get_load_snapshot_status(self, project_name: str, trained_model_label: str, job_id: str, **kwargs: Any) -> JSON:
+        """Gets the status for loading a snapshot.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-load-snapshot-status
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param trained_model_label: The trained model label. Required.
+        :type trained_model_label: str
+        :param job_id: The job ID. Required.
+        :type job_id: str
+        :return: JSON object
+        :rtype: JSON
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        request = build_conversation_authoring_get_load_snapshot_status_request(
+            project_name=project_name,
+            trained_model_label=trained_model_label,
+            job_id=job_id,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        if response.content:
+            deserialized = response.json()
+        else:
+            deserialized = None
+
+        if cls:
+            return cls(pipeline_response, cast(JSON, deserialized), {})
+
+        return cast(JSON, deserialized)
+
+    @distributed_trace
+    def list_deployment_resources(
         self, project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> Iterable[JSON]:
-        """Lists the non-expired training jobs created for a project.
+        """Lists the deployments resources assigned to the project.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-deployment-resources
+        for more information.
 
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
@@ -4406,112 +5889,1253 @@
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
+                    "azureResourceId": "str",  # The resource ID. Required.
+                    "region": "str"  # The resource region. Required.
+                }
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_conversation_authoring_list_deployment_resources_request(
+                    project_name=project_name,
+                    top=top,
+                    skip=skip,
+                    api_version=self._config.api_version,
+                    headers=_headers,
+                    params=_params,
+                )
+                path_format_arguments = {
+                    "Endpoint": self._serialize.url(
+                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
+                    ),
+                }
+                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                path_format_arguments = {
+                    "Endpoint": self._serialize.url(
+                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
+                    ),
+                }
+                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+            return request
+
+        def extract_data(pipeline_response):
+            deserialized = pipeline_response.http_response.json()
+            list_of_elem = deserialized["value"]
+            if cls:
+                list_of_elem = cls(list_of_elem)
+            return deserialized.get("nextLink", None), iter(list_of_elem)
+
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response)
+
+            return pipeline_response
+
+        return ItemPaged(get_next, extract_data)
+
+    def _assign_deployment_resources_initial(
+        self, project_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> Optional[JSON]:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IO, bytes)):
+            _content = body
+        else:
+            _json = body
+
+        request = build_conversation_authoring_assign_deployment_resources_request(
+            project_name=project_name,
+            content_type=content_type,
+            api_version=self._config.api_version,
+            json=_json,
+            content=_content,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        deserialized = None
+        response_headers = {}
+        if response.status_code == 200:
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+
+        if response.status_code == 202:
+            response_headers["operation-location"] = self._deserialize(
+                "str", response.headers.get("operation-location")
+            )
+
+        if cls:
+            return cls(pipeline_response, deserialized, response_headers)
+
+        return deserialized
+
+    @overload
+    def begin_assign_deployment_resources(
+        self, project_name: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
+    ) -> LROPoller[JSON]:
+        """Assign new Azure resources to a project to allow deploying new deployments to them. This API is
+        available only via AAD authentication and not supported via subscription key authentication.
+        For more details about AAD authentication, check here:
+        https://learn.microsoft.com/en-us/azure/cognitive-services/authentication?tabs=powershell#authenticate-with-azure-active-directory
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/assign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The new project resources info. Required.
+        :type body: JSON
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns JSON object
+        :rtype: ~azure.core.polling.LROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # JSON input template you can fill out and use as your body input.
+                body = {
+                    "resourcesMetadata": [
+                        {
+                            "azureResourceId": "str",  # Represents the Azure resource
+                              ID. Required.
+                            "customDomain": "str",  # Represents the Azure resource
+                              custom domain. Required.
+                            "region": "str"  # Represents the Azure resource region.
+                              Required.
+                        }
+                    ]
+                }
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+
+    @overload
+    def begin_assign_deployment_resources(
+        self, project_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
+    ) -> LROPoller[JSON]:
+        """Assign new Azure resources to a project to allow deploying new deployments to them. This API is
+        available only via AAD authentication and not supported via subscription key authentication.
+        For more details about AAD authentication, check here:
+        https://learn.microsoft.com/en-us/azure/cognitive-services/authentication?tabs=powershell#authenticate-with-azure-active-directory
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/assign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The new project resources info. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns JSON object
+        :rtype: ~azure.core.polling.LROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+
+    @distributed_trace
+    def begin_assign_deployment_resources(
+        self, project_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> LROPoller[JSON]:
+        """Assign new Azure resources to a project to allow deploying new deployments to them. This API is
+        available only via AAD authentication and not supported via subscription key authentication.
+        For more details about AAD authentication, check here:
+        https://learn.microsoft.com/en-us/azure/cognitive-services/authentication?tabs=powershell#authenticate-with-azure-active-directory
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/assign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The new project resources info. Is either a model type or a IO type. Required.
+        :type body: JSON or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns JSON object
+        :rtype: ~azure.core.polling.LROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        if cont_token is None:
+            raw_result = self._assign_deployment_resources_initial(  # type: ignore
+                project_name=project_name,
+                body=body,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):
+            response = pipeline_response.http_response
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+            if cls:
+                return cls(pipeline_response, deserialized, {})
+            return deserialized
+
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+
+        if polling is True:
+            polling_method = cast(
+                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
+            )  # type: PollingMethod
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+
+    def _unassign_deployment_resources_initial(
+        self, project_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> Optional[JSON]:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IO, bytes)):
+            _content = body
+        else:
+            _json = body
+
+        request = build_conversation_authoring_unassign_deployment_resources_request(
+            project_name=project_name,
+            content_type=content_type,
+            api_version=self._config.api_version,
+            json=_json,
+            content=_content,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        deserialized = None
+        response_headers = {}
+        if response.status_code == 200:
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+
+        if response.status_code == 202:
+            response_headers["operation-location"] = self._deserialize(
+                "str", response.headers.get("operation-location")
+            )
+
+        if cls:
+            return cls(pipeline_response, deserialized, response_headers)
+
+        return deserialized
+
+    @overload
+    def begin_unassign_deployment_resources(
+        self, project_name: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
+    ) -> LROPoller[JSON]:
+        """Unassign resources from a project. This disallows deploying new deployments to these resources,
+        and deletes existing deployments assigned to them.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/unassign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The info for the deployment resources to be deleted. Required.
+        :type body: JSON
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns JSON object
+        :rtype: ~azure.core.polling.LROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # JSON input template you can fill out and use as your body input.
+                body = {
+                    "assignedResourceIds": [
+                        "str"  # Represents the assigned resource IDs to be unassigned.
+                          Required.
+                    ]
+                }
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+
+    @overload
+    def begin_unassign_deployment_resources(
+        self, project_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
+    ) -> LROPoller[JSON]:
+        """Unassign resources from a project. This disallows deploying new deployments to these resources,
+        and deletes existing deployments assigned to them.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/unassign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The info for the deployment resources to be deleted. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns JSON object
+        :rtype: ~azure.core.polling.LROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+
+    @distributed_trace
+    def begin_unassign_deployment_resources(
+        self, project_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> LROPoller[JSON]:
+        """Unassign resources from a project. This disallows deploying new deployments to these resources,
+        and deletes existing deployments assigned to them.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/unassign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The info for the deployment resources to be deleted. Is either a model type or a
+         IO type. Required.
+        :type body: JSON or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns JSON object
+        :rtype: ~azure.core.polling.LROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        if cont_token is None:
+            raw_result = self._unassign_deployment_resources_initial(  # type: ignore
+                project_name=project_name,
+                body=body,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):
+            response = pipeline_response.http_response
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+            if cls:
+                return cls(pipeline_response, deserialized, {})
+            return deserialized
+
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+
+        if polling is True:
+            polling_method = cast(
+                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
+            )  # type: PollingMethod
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+
+    @distributed_trace
+    def get_assign_deployment_resources_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
+        """Gets the status of an existing assign deployment resources job.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-assign-deployment-resources-status
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param job_id: The job ID. Required.
+        :type job_id: str
+        :return: JSON object
+        :rtype: JSON
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
                                 "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
                                 "target": "str"  # Optional. Error target.
                             },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        request = build_conversation_authoring_get_assign_deployment_resources_status_request(
+            project_name=project_name,
+            job_id=job_id,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        if response.content:
+            deserialized = response.json()
+        else:
+            deserialized = None
+
+        if cls:
+            return cls(pipeline_response, cast(JSON, deserialized), {})
+
+        return cast(JSON, deserialized)
+
+    @distributed_trace
+    def get_unassign_deployment_resources_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
+        """Gets the status of an existing unassign deployment resources job.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-unassign-deployment-resources-status
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param job_id: The job ID. Required.
+        :type job_id: str
+        :return: JSON object
+        :rtype: JSON
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
                             "message": "str",  # A human-readable representation of the
                               error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        request = build_conversation_authoring_get_unassign_deployment_resources_status_request(
+            project_name=project_name,
+            job_id=job_id,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        if response.content:
+            deserialized = response.json()
+        else:
+            deserialized = None
+
+        if cls:
+            return cls(pipeline_response, cast(JSON, deserialized), {})
+
+        return cast(JSON, deserialized)
+
+    @distributed_trace
+    def list_training_jobs(
+        self, project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
+    ) -> Iterable[JSON]:
+        """Lists the non-expired training jobs created for a project.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-training-jobs
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :keyword top: The maximum number of resources to return from the collection. Default value is
+         None.
+        :paramtype top: int
+        :keyword skip: An offset into the collection of the first resource to be returned. Default
+         value is None.
+        :paramtype skip: int
+        :return: An iterator like instance of JSON object
+        :rtype: ~azure.core.paging.ItemPaged[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
                     "jobId": "str",  # The job ID. Required.
                     "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
                       was updated. Required.
                     "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
                             "percentComplete": 0,  # Represents progress percentage.
                               Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
+                            "status": "str",  # Represents the status of the
                               sub-operation. Required. Known values are: "notStarted", "running",
                               "succeeded", "failed", "cancelled", "cancelling", and
                               "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
                             "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
                               the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
                             "percentComplete": 0,  # Represents progress percentage.
                               Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
+                            "status": "str",  # Represents the status of the
                               sub-operation. Required. Known values are: "notStarted", "running",
                               "succeeded", "failed", "cancelled", "cancelling", and
                               "partiallyCompleted".
-                        }
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
                     },
                     "status": "str",  # The job status. Required. Known values are: "notStarted",
                       "running", "succeeded", "failed", "cancelled", "cancelling", and
                       "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_training_jobs_request(
+                request = build_conversation_authoring_list_training_jobs_request(
                     project_name=project_name,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -4520,18 +7144,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -4560,14 +7191,18 @@
 
         return ItemPaged(get_next, extract_data)
 
     @distributed_trace
     def get_training_job_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status for a training job.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-training-status
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -4575,107 +7210,112 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_training_job_status_request(
+        request = build_conversation_authoring_get_training_job_status_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -4700,23 +7340,28 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     def _cancel_training_job_initial(self, project_name: str, job_id: str, **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
 
-        request = build_cancel_training_job_request(
+        request = build_conversation_authoring_cancel_training_job_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -4752,14 +7397,18 @@
 
         return deserialized
 
     @distributed_trace
     def begin_cancel_training_job(self, project_name: str, job_id: str, **kwargs: Any) -> LROPoller[JSON]:
         """Triggers a cancellation for a running training job.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/cancel-training-job
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
@@ -4774,90 +7423,90 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -4911,87 +7560,96 @@
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
     @distributed_trace
     def get_project_deletion_job_status(self, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status for a project deletion job.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-project-deletion-status
+        for more information.
+
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_project_deletion_job_status_request(
+        request = build_conversation_authoring_get_project_deletion_job_status_request(
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
@@ -5015,21 +7673,140 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     @distributed_trace
+    def list_assigned_resource_deployments(
+        self, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
+    ) -> Iterable[JSON]:
+        """Lists the deployments to which an Azure resource is assigned. This doesn't return deployments
+        belonging to projects owned by this resource. It only returns deployments belonging to projects
+        owned by other resources.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-assigned-resource-deployments
+        for more information.
+
+        :keyword top: The maximum number of resources to return from the collection. Default value is
+         None.
+        :paramtype top: int
+        :keyword skip: An offset into the collection of the first resource to be returned. Default
+         value is None.
+        :paramtype skip: int
+        :return: An iterator like instance of JSON object
+        :rtype: ~azure.core.paging.ItemPaged[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "deploymentsMetadata": [
+                        {
+                            "deploymentExpirationDate": "2020-02-20",  # Represents
+                              deployment expiration date in the runtime. Required.
+                            "deploymentName": "str",  # Represents the deployment name.
+                              Required.
+                            "lastDeployedDateTime": "2020-02-20 00:00:00"  # Represents
+                              deployment last deployed time. Required.
+                        }
+                    ],
+                    "projectName": "str"  # Represents the project name. Required.
+                }
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_conversation_authoring_list_assigned_resource_deployments_request(
+                    top=top,
+                    skip=skip,
+                    api_version=self._config.api_version,
+                    headers=_headers,
+                    params=_params,
+                )
+                path_format_arguments = {
+                    "Endpoint": self._serialize.url(
+                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
+                    ),
+                }
+                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                path_format_arguments = {
+                    "Endpoint": self._serialize.url(
+                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
+                    ),
+                }
+                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+            return request
+
+        def extract_data(pipeline_response):
+            deserialized = pipeline_response.http_response.json()
+            list_of_elem = deserialized["value"]
+            if cls:
+                list_of_elem = cls(list_of_elem)
+            return deserialized.get("nextLink", None), iter(list_of_elem)
+
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response)
+
+            return pipeline_response
+
+        return ItemPaged(get_next, extract_data)
+
+    @distributed_trace
     def list_supported_languages(
         self, *, project_kind: str, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> Iterable[JSON]:
         """Lists the supported languages for the given project type.
 
-        :keyword project_kind: The project kind. Known values are: "Conversation" and "Orchestration".
-         Required.
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-supported-languages
+        for more information.
+
+        :keyword project_kind: The project kind. Known values are: "Conversation", "Orchestration", and
+         "CustomConversationSummarization". Required.
         :paramtype project_kind: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
         :paramtype skip: int
@@ -5049,21 +7826,26 @@
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_supported_languages_request(
+                request = build_conversation_authoring_list_supported_languages_request(
                     project_kind=project_kind,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -5072,18 +7854,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -5120,14 +7909,18 @@
         multilingual: Optional[bool] = None,
         top: Optional[int] = None,
         skip: Optional[int] = None,
         **kwargs: Any
     ) -> Iterable[JSON]:
         """Lists the supported prebuilt entities that can be used while creating composed entities.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-supported-prebuilt-entities
+        for more information.
+
         :keyword language: The language to get supported prebuilt entities for. Required if
          multilingual is false. This is BCP-47 representation of a language. For example, use "en" for
          English, "en-gb" for English (UK), "es" for Spanish etc. Default value is None.
         :paramtype language: str
         :keyword multilingual: Whether to get the support prebuilt entities for multilingual or
          monolingual projects. If true, the language parameter is ignored. Default value is None.
         :paramtype multilingual: bool
@@ -5152,21 +7945,26 @@
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_supported_prebuilt_entities_request(
+                request = build_conversation_authoring_list_supported_prebuilt_entities_request(
                     language=language,
                     multilingual=multilingual,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
@@ -5176,18 +7974,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -5218,16 +8023,20 @@
 
     @distributed_trace
     def list_training_config_versions(
         self, *, project_kind: str, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> Iterable[JSON]:
         """Lists the support training config version for a given project type.
 
-        :keyword project_kind: The project kind. Known values are: "Conversation" and "Orchestration".
-         Required.
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-training-config-versions
+        for more information.
+
+        :keyword project_kind: The project kind. Known values are: "Conversation", "Orchestration", and
+         "CustomConversationSummarization". Required.
         :paramtype project_kind: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
         :paramtype skip: int
@@ -5247,21 +8056,26 @@
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_training_config_versions_request(
+                request = build_conversation_authoring_list_training_config_versions_request(
                     project_kind=project_kind,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -5270,18 +8084,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/__init__.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -2,20 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from ._client import ConversationAuthoringClient
+from ._client import ConversationAnalysisClient
 
 try:
     from ._patch import __all__ as _patch_all
     from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
-__all__ = ["ConversationAuthoringClient"]
+__all__ = [
+    "ConversationAnalysisClient",
+]
 __all__.extend([p for p in _patch_all if p not in __all__])
 
 _patch_sdk()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_configuration.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/_configuration.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,65 +2,74 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-from .._version import VERSION
+from ._version import VERSION
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
-class ConversationAuthoringClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
-    """Configuration for ConversationAuthoringClient.
+class ConversationAnalysisClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
+    """Configuration for ConversationAnalysisClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
-    :keyword api_version: Api Version. Default value is "2022-05-15-preview". Note that overriding
+    :type credential: ~azure.core.credentials.TokenCredential
+    :keyword api_version: Api Version. Default value is "2022-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, endpoint: str, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
-        super(ConversationAuthoringClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "2022-05-15-preview")  # type: str
+    def __init__(self, endpoint: str, credential: "TokenCredential", **kwargs: Any) -> None:
+        super(ConversationAnalysisClientConfiguration, self).__init__(**kwargs)
+        api_version = kwargs.pop("api_version", "2022-10-01-preview")  # type: Literal["2022-10-01-preview"]
 
         if endpoint is None:
             raise ValueError("Parameter 'endpoint' must not be None.")
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.endpoint = endpoint
         self.credential = credential
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://cognitiveservices.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "ai-language-conversations/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(self, **kwargs: Any) -> None:
+    def _configure(
+        self, **kwargs  # type: Any
+    ):
+        # type: (...) -> None
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = policies.AsyncBearerTokenCredentialPolicy(
+            self.authentication_policy = policies.BearerTokenCredentialPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_client.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,34 +14,33 @@
 
 from .._serialization import Deserializer, Serializer
 from ._configuration import ConversationAuthoringClientConfiguration
 from ._operations import ConversationAuthoringClientOperationsMixin
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from typing import Dict
-
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class ConversationAuthoringClient(
     ConversationAuthoringClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The language service API is a suite of natural language processing (NLP) skills built with
     best-in-class Microsoft machine learning algorithms. The API can be used to analyze
     unstructured text for tasks such as sentiment analysis, key phrase extraction, language
     detection and question answering. Further documentation can be found in :code:`<a
-    href="https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview">https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview</a>`.
+    href="https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview">
+    https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview</a>`.
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
-    :keyword api_version: Api Version. Default value is "2022-05-15-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, endpoint: str, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_patch.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/_patch.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,37 +3,36 @@
 # Licensed under the MIT License.
 # ------------------------------------
 """Customize generated code here.
 
 Follow our quickstart for examples: https://aka.ms/azsdk/python/dpcodegen/python/customize
 """
 from typing import List, Union, Any
-from azure.core.credentials import AzureKeyCredential
-from azure.core.credentials_async import AsyncTokenCredential
+from azure.core.credentials import AzureKeyCredential, TokenCredential
 from azure.core.pipeline.policies import AzureKeyCredentialPolicy
 from ._client import ConversationAuthoringClient as GeneratedConversationAuthoringClient
 
+POLLING_INTERVAL_DEFAULT = 5
+
 
 def _authentication_policy(credential):
     authentication_policy = None
     if credential is None:
         raise ValueError("Parameter 'credential' must not be None.")
     if isinstance(credential, AzureKeyCredential):
-        authentication_policy = AzureKeyCredentialPolicy(
-            name="Ocp-Apim-Subscription-Key", credential=credential
-        )
+        authentication_policy = AzureKeyCredentialPolicy(name="Ocp-Apim-Subscription-Key", credential=credential)
     elif credential is not None and not hasattr(credential, "get_token"):
         raise TypeError(
-            "Unsupported credential: {}. Use an instance of AzureKeyCredential "
-            "or a token credential from azure.identity".format(type(credential))
+            f"Unsupported credential: {type(credential)}. Use an instance of AzureKeyCredential "
+            "or a token credential from azure.identity"
         )
     return authentication_policy
 
 
-class ConversationAuthoringClient(GeneratedConversationAuthoringClient): # pylint: disable=client-accepts-api-version-keyword
+class ConversationAuthoringClient(GeneratedConversationAuthoringClient):
     """The language service API is a suite of natural language processing (NLP) skills built with
     best-in-class Microsoft machine learning algorithms. The API can be used to analyze
     unstructured text for tasks such as sentiment analysis, key phrase extraction, language
     detection and question answering. Further documentation can be found in
     https://docs.microsoft.com/en-us/azure/cognitive-services/language-service/overview.
 
     See https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring for more information about
@@ -41,30 +40,34 @@
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure.
         This can be the an instance of AzureKeyCredential if using a Language API key
         or a token credential from :mod:`azure.identity`.
-    :type credential: ~azure.core.credentials.AzureKeyCredential or ~azure.core.credentials_async.AsyncTokenCredential
-    :keyword api_version: Api Version. Available values are "2022-05-15-preview" and "2022-05-01". Default
-     value is "2022-05-15-preview". Note that overriding this default value may result in unsupported behavior.
+    :type credential: ~azure.core.credentials.AzureKeyCredential or ~azure.core.credentials.TokenCredential
+    :keyword api_version: Api Version. Available values are "2022-10-01-preview", "2022-05-15-preview",
+     "2022-05-01". Default value is "2022-10-01-preview". Note that overriding this default value may result in
+     unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
-    def __init__(
-        self, endpoint: str, credential: Union[AzureKeyCredential, AsyncTokenCredential], **kwargs: Any
-    ) -> None:
+    def __init__(self, endpoint: str, credential: Union[AzureKeyCredential, TokenCredential], **kwargs: Any) -> None:
+        try:
+            endpoint = endpoint.rstrip("/")
+        except AttributeError:
+            raise ValueError("Parameter 'endpoint' must be a string.")
         super().__init__(
             endpoint=endpoint,
             credential=credential,  # type: ignore
             authentication_policy=kwargs.pop("authentication_policy", _authentication_policy(credential)),
-            **kwargs
+            polling_interval=kwargs.pop("polling_interval", POLLING_INTERVAL_DEFAULT),
+            **kwargs,
         )
 
 
 __all__: List[str] = ["ConversationAuthoringClient"]
 
 
 def patch_sdk():
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_vendor.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_vendor.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,23 +4,23 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
 from typing import TYPE_CHECKING
 
-from ._configuration import ConversationAuthoringClientConfiguration
+from ._configuration import ConversationAnalysisClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core import AsyncPipelineClient
 
     from .._serialization import Deserializer, Serializer
 
 
-class MixinABC(ABC):
+class ConversationAnalysisClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
 
     _client: "AsyncPipelineClient"
-    _config: ConversationAuthoringClientConfiguration
+    _config: ConversationAnalysisClientConfiguration
     _serialize: "Serializer"
     _deserialize: "Deserializer"
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/__init__.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/authoring/aio/_operations/_operations.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_operations/_operations.py`

 * *Files 19% similar despite different names*

```diff
@@ -4,81 +4,98 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
-from urllib.parse import parse_qs, urljoin, urlparse
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
 from azure.core.polling.async_base_polling import AsyncLROBasePolling
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 
 from ..._operations._operations import (
-    build_cancel_training_job_request,
-    build_create_project_request,
-    build_delete_deployment_request,
-    build_delete_project_request,
-    build_delete_trained_model_request,
-    build_deploy_project_request,
-    build_export_project_request,
-    build_get_deployment_job_status_request,
-    build_get_deployment_request,
-    build_get_export_project_job_status_request,
-    build_get_import_project_job_status_request,
-    build_get_model_evaluation_summary_request,
-    build_get_project_deletion_job_status_request,
-    build_get_project_request,
-    build_get_swap_deployments_job_status_request,
-    build_get_trained_model_request,
-    build_get_training_job_status_request,
-    build_import_project_request,
-    build_list_deployments_request,
-    build_list_model_evaluation_results_request,
-    build_list_projects_request,
-    build_list_supported_languages_request,
-    build_list_supported_prebuilt_entities_request,
-    build_list_trained_models_request,
-    build_list_training_config_versions_request,
-    build_list_training_jobs_request,
-    build_swap_deployments_request,
-    build_train_request,
+    build_conversation_authoring_assign_deployment_resources_request,
+    build_conversation_authoring_cancel_training_job_request,
+    build_conversation_authoring_create_project_request,
+    build_conversation_authoring_delete_deployment_from_resources_request,
+    build_conversation_authoring_delete_deployment_request,
+    build_conversation_authoring_delete_project_request,
+    build_conversation_authoring_delete_trained_model_request,
+    build_conversation_authoring_deploy_project_request,
+    build_conversation_authoring_export_project_request,
+    build_conversation_authoring_get_assign_deployment_resources_status_request,
+    build_conversation_authoring_get_deployment_delete_from_resources_status_request,
+    build_conversation_authoring_get_deployment_job_status_request,
+    build_conversation_authoring_get_deployment_request,
+    build_conversation_authoring_get_export_project_job_status_request,
+    build_conversation_authoring_get_import_project_job_status_request,
+    build_conversation_authoring_get_load_snapshot_status_request,
+    build_conversation_authoring_get_model_evaluation_summary_request,
+    build_conversation_authoring_get_project_deletion_job_status_request,
+    build_conversation_authoring_get_project_request,
+    build_conversation_authoring_get_swap_deployments_job_status_request,
+    build_conversation_authoring_get_trained_model_request,
+    build_conversation_authoring_get_training_job_status_request,
+    build_conversation_authoring_get_unassign_deployment_resources_status_request,
+    build_conversation_authoring_import_project_request,
+    build_conversation_authoring_list_assigned_resource_deployments_request,
+    build_conversation_authoring_list_deployment_resources_request,
+    build_conversation_authoring_list_deployments_request,
+    build_conversation_authoring_list_model_evaluation_results_request,
+    build_conversation_authoring_list_projects_request,
+    build_conversation_authoring_list_supported_languages_request,
+    build_conversation_authoring_list_supported_prebuilt_entities_request,
+    build_conversation_authoring_list_trained_models_request,
+    build_conversation_authoring_list_training_config_versions_request,
+    build_conversation_authoring_list_training_jobs_request,
+    build_conversation_authoring_load_snapshot_request,
+    build_conversation_authoring_swap_deployments_request,
+    build_conversation_authoring_train_request,
+    build_conversation_authoring_unassign_deployment_resources_request,
 )
-from .._vendor import MixinABC
+from .._vendor import ConversationAuthoringClientMixinABC
 
 if sys.version_info >= (3, 9):
     from collections.abc import MutableMapping
 else:
     from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
 JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ConversationAuthoringClientOperationsMixin(MixinABC):  # pylint: disable=too-many-public-methods
+class ConversationAuthoringClientOperationsMixin(
+    ConversationAuthoringClientMixinABC
+):  # pylint: disable=too-many-public-methods
     @distributed_trace
     def list_projects(
         self, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable[JSON]:
         """Lists the existing projects.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-projects
+        for more information.
+
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
         :paramtype skip: int
         :return: An iterator like instance of JSON object
@@ -88,48 +105,56 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_projects_request(
+                request = build_conversation_authoring_list_projects_request(
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
                 path_format_arguments = {
@@ -137,18 +162,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -179,14 +211,18 @@
 
     @overload
     async def create_project(
         self, project_name: str, project: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
     ) -> JSON:
         """Creates a new project or updates an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/create-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project parameters. Required.
         :type project: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/merge-patch+json".
         :paramtype content_type: str
@@ -195,63 +231,73 @@
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # JSON input template you can fill out and use as your body input.
                 project = {
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "multilingual": bool,  # Optional. Whether the project would be used for
-                      multiple languages or not.
                     "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
                     "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "multilingual": bool,  # Optional. Whether the project would be used for
+                      multiple languages or not.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
 
                 # response body for status code(s): 200, 201
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
 
     @overload
     async def create_project(
         self, project_name: str, project: IO, *, content_type: str = "application/merge-patch+json", **kwargs: Any
     ) -> JSON:
         """Creates a new project or updates an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/create-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project parameters. Required.
         :type project: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/merge-patch+json".
         :paramtype content_type: str
@@ -262,41 +308,48 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200, 201
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
 
     @distributed_trace_async
     async def create_project(self, project_name: str, project: Union[JSON, IO], **kwargs: Any) -> JSON:
         """Creates a new project or updates an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/create-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project parameters. Is either a model type or a IO type. Required.
         :type project: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are:
          'application/merge-patch+json'. Default value is None.
         :paramtype content_type: str
@@ -307,37 +360,45 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200, 201
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
@@ -346,15 +407,15 @@
         _json = None
         _content = None
         if isinstance(project, (IO, bytes)):
             _content = project
         else:
             _json = project
 
-        request = build_create_project_request(
+        request = build_conversation_authoring_create_project_request(
             project_name=project_name,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
@@ -391,58 +452,70 @@
 
         return cast(JSON, deserialized)
 
     @distributed_trace_async
     async def get_project(self, project_name: str, **kwargs: Any) -> JSON:
         """Gets the details of a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Represents the project creation
                       datetime. Required.
-                    "description": "str",  # Optional. The project description.
                     "language": "str",  # The project language. This is BCP-47 representation of
                       a language. For example, use "en" for English, "en-gb" for English (UK), "es" for
                       Spanish etc. Required.
-                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
-                      project last deployed datetime.
                     "lastModifiedDateTime": "2020-02-20 00:00:00",  # Represents the project
                       creation datetime. Required.
+                    "projectKind": "str",  # Represents the project kind. Required. Known values
+                      are: "Conversation", "Orchestration", and "CustomConversationSummarization".
+                    "projectName": "str",  # The new project name. Required.
+                    "description": "str",  # Optional. The project description.
+                    "lastDeployedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
+                      project last deployed datetime.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Optional. Represents the
                       project last trained datetime.
                     "multilingual": bool,  # Optional. Whether the project would be used for
                       multiple languages or not.
-                    "projectKind": "str",  # Represents the project kind. Required. Known values
-                      are: "Conversation" and "Orchestration".
-                    "projectName": "str",  # The new project name. Required.
                     "settings": {
                         "confidenceThreshold": 0.0  # The threshold of the intent with the
                           highest confidence, at which the prediction will automatically be changed to
-                          "None". Required.
-                    }
+                          "None". The value of the threshold should be between 0 and 1 inclusive.
+                          Required.
+                    },
+                    "storageInputContainerName": "str"  # Optional. The storage container name in
+                      case of conversation summarization.
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_project_request(
+        request = build_conversation_authoring_get_project_request(
             project_name=project_name,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
@@ -466,23 +539,28 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     async def _delete_project_initial(self, project_name: str, **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
 
-        request = build_delete_project_request(
+        request = build_conversation_authoring_delete_project_request(
             project_name=project_name,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
@@ -517,14 +595,18 @@
 
         return deserialized
 
     @distributed_trace_async
     async def begin_delete_project(self, project_name: str, **kwargs: Any) -> AsyncLROPoller[JSON]:
         """Deletes a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
@@ -537,57 +619,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -640,29 +722,36 @@
     async def _export_project_initial(
         self,
         project_name: str,
         *,
         string_index_type: str,
         exported_project_format: Optional[str] = None,
         asset_kind: Optional[str] = None,
+        trained_model_label: Optional[str] = None,
         **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
 
-        request = build_export_project_request(
+        request = build_conversation_authoring_export_project_request(
             project_name=project_name,
             string_index_type=string_index_type,
             exported_project_format=exported_project_format,
             asset_kind=asset_kind,
+            trained_model_label=trained_model_label,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
         }
@@ -700,28 +789,36 @@
     async def begin_export_project(
         self,
         project_name: str,
         *,
         string_index_type: str,
         exported_project_format: Optional[str] = None,
         asset_kind: Optional[str] = None,
+        trained_model_label: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Triggers a job to export a project's data.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/export
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword string_index_type: Specifies the method used to interpret string offsets. For
          additional information see https://aka.ms/text-analytics-offsets. "Utf16CodeUnit" Required.
         :paramtype string_index_type: str
         :keyword exported_project_format: The format of the exported project file to use. Known values
          are: "Conversation" and "Luis". Default value is None.
         :paramtype exported_project_format: str
         :keyword asset_kind: Kind of asset to export. Default value is None.
         :paramtype asset_kind: str
+        :keyword trained_model_label: Trained model label to export. If the trainedModelLabel is null,
+         the default behavior is to export the current working copy. Default value is None.
+        :paramtype trained_model_label: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
@@ -732,59 +829,59 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
                     "resultUrl": "str",  # Optional. The URL to use in order to download the
                       exported project.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -798,14 +895,15 @@
         cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
             raw_result = await self._export_project_initial(  # type: ignore
                 project_name=project_name,
                 string_index_type=string_index_type,
                 exported_project_format=exported_project_format,
                 asset_kind=asset_kind,
+                trained_model_label=trained_model_label,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
@@ -845,15 +943,20 @@
         self,
         project_name: str,
         project: Union[JSON, IO],
         *,
         exported_project_format: Optional[str] = None,
         **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -862,15 +965,15 @@
         _json = None
         _content = None
         if isinstance(project, (IO, bytes)):
             _content = project
         else:
             _json = project
 
-        request = build_import_project_request(
+        request = build_conversation_authoring_import_project_request(
             project_name=project_name,
             exported_project_format=exported_project_format,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
@@ -918,14 +1021,18 @@
         exported_project_format: Optional[str] = None,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Triggers a job to import a project. If a project with the same name already exists, the data of
         that project is replaced.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/import
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project data to import. Required.
         :type project: JSON
         :keyword exported_project_format: The format of the exported project file to use. Known values
          are: "Conversation" and "Luis". Default value is None.
         :paramtype exported_project_format: str
@@ -942,86 +1049,200 @@
         :return: An instance of AsyncLROPoller that returns JSON object
         :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
+                # The input is polymorphic. The following are possible polymorphic inputs based off
+                  discriminator "projectKind":
+
+                # JSON input template for discriminator value "Conversation":
+                exported_project_assets = {
+                    "projectKind": "Conversation",
+                    "entities": [
+                        {
+                            "category": "str",  # The category of the entity. Required.
+                            "compositionSetting": "str",  # Optional. The behavior to
+                              follow when the entity's components overlap with each other. Known values
+                              are: "returnLongestOverlap", "requireExactOverlap", "separateComponents",
+                              and "combineComponents".
+                            "list": {
+                                "sublists": [
+                                    {
+                                        "listKey": "str",  # Optional. The
+                                          key of the sub-list.
+                                        "synonyms": [
+                                            {
+                                                "language": "str",  #
+                                                  Optional. Represents the language of the synonyms.
+                                                  This is BCP-47 representation of a language. For
+                                                  example, use "en" for English, "en-gb" for English
+                                                  (UK), "es" for Spanish etc.
+                                                "values": [
+                                                    "str"  #
+                                                      Optional. The list of synonyms.
+                                                ]
+                                            }
+                                        ]
+                                    }
+                                ]
+                            },
+                            "prebuilts": [
+                                {
+                                    "category": "str"  # The prebuilt entity
+                                      category. Required.
+                                }
+                            ],
+                            "regex": {
+                                "expressions": [
+                                    {
+                                        "language": "str",  # Optional.
+                                          Represents the language of the regex expression. This is
+                                          BCP-47 representation of a language. For example, use "en"
+                                          for English, "en-gb" for English (UK), "es" for Spanish etc.
+                                        "regexKey": "str",  # Optional. The
+                                          key of the regex expression.
+                                        "regexPattern": "str"  # Optional.
+                                          The regex pattern.
+                                    }
+                                ]
+                            },
+                            "requiredComponents": [
+                                "str"  # Optional. The required components. Allowed
+                                  values are 'learned', 'list', 'prebuilts' and 'regex'.
+                            ]
+                        }
+                    ],
+                    "intents": [
+                        {
+                            "category": "str"  # The intent category. Required.
+                        }
+                    ],
+                    "utterances": [
+                        {
+                            "intent": "str",  # The intent of the utterance. Required.
+                            "text": "str",  # The utterance text. Required.
+                            "dataset": "str",  # Optional. The dataset for this
+                              utterance. Allowed values are 'Train' and 'Test'.
+                            "entities": [
+                                {
+                                    "category": "str",  # The category of the
+                                      entity label. Required.
+                                    "length": 0,  # Length for the entity text.
+                                      Required.
+                                    "offset": 0  # Start position for the entity
+                                      text. Required.
+                                }
+                            ],
+                            "language": "str"  # Optional. Represents the utterance's
+                              language. This is BCP-47 representation of a language. For example, use
+                              "en" for English, "en-gb" for English (UK), "es" for Spanish etc.
+                        }
+                    ]
+                }
+
+                # JSON input template for discriminator value "Orchestration":
+                exported_project_assets = {
+                    "projectKind": "Orchestration",
+                    "intents": [
+                        {
+                            "category": "str",  # The intent category. Required.
+                            "orchestration": exported_orchestration_options
+                        }
+                    ],
+                    "utterances": [
+                        {
+                            "intent": "str",  # The intent of the utterance. Required.
+                            "text": "str",  # The utterance text. Required.
+                            "dataset": "str",  # Optional. The dataset for this
+                              utterance. Allowed values are 'Train' and 'Test'.
+                            "language": "str"  # Optional. Represents the utterance's
+                              language. This is BCP-47 representation of a language. For example, use
+                              "en" for English, "en-gb" for English (UK), "es" for Spanish etc.
+                        }
+                    ]
+                }
+
                 # JSON input template you can fill out and use as your body input.
                 project = {
-                    "assets": exported_project_assets,
                     "metadata": {
-                        "description": "str",  # Optional. The project description.
                         "language": "str",  # The project language. This is BCP-47
                           representation of a language. For example, use "en" for English, "en-gb" for
                           English (UK), "es" for Spanish etc. Required.
-                        "multilingual": bool,  # Optional. Whether the project would be used
-                          for multiple languages or not.
                         "projectKind": "str",  # Represents the project kind. Required. Known
-                          values are: "Conversation" and "Orchestration".
+                          values are: "Conversation", "Orchestration", and
+                          "CustomConversationSummarization".
                         "projectName": "str",  # The new project name. Required.
+                        "description": "str",  # Optional. The project description.
+                        "multilingual": bool,  # Optional. Whether the project would be used
+                          for multiple languages or not.
                         "settings": {
                             "confidenceThreshold": 0.0  # The threshold of the intent
                               with the highest confidence, at which the prediction will automatically
-                              be changed to "None". Required.
-                        }
+                              be changed to "None". The value of the threshold should be between 0 and
+                              1 inclusive. Required.
+                        },
+                        "storageInputContainerName": "str"  # Optional. The storage container
+                          name in case of conversation summarization.
                     },
                     "projectFileVersion": "str",  # The version of the exported file. Required.
-                    "stringIndexType": "str"  # Specifies the method used to interpret string
+                    "stringIndexType": "str",  # Specifies the method used to interpret string
                       offsets. For additional information see https://aka.ms/text-analytics-offsets.
                       Required. "Utf16CodeUnit"
+                    "assets": exported_project_assets
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1036,14 +1257,18 @@
         exported_project_format: Optional[str] = None,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Triggers a job to import a project. If a project with the same name already exists, the data of
         that project is replaced.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/import
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project data to import. Required.
         :type project: IO
         :keyword exported_project_format: The format of the exported project file to use. Known values
          are: "Conversation" and "Luis". Default value is None.
         :paramtype exported_project_format: str
@@ -1064,57 +1289,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1128,14 +1353,18 @@
         *,
         exported_project_format: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Triggers a job to import a project. If a project with the same name already exists, the data of
         that project is replaced.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/import
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param project: The project data to import. Is either a model type or a IO type. Required.
         :type project: JSON or IO
         :keyword exported_project_format: The format of the exported project file to use. Known values
          are: "Conversation" and "Luis". Default value is None.
         :paramtype exported_project_format: str
@@ -1156,57 +1385,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1261,15 +1490,20 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
     async def _train_initial(self, project_name: str, configuration: Union[JSON, IO], **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -1278,15 +1512,15 @@
         _json = None
         _content = None
         if isinstance(configuration, (IO, bytes)):
             _content = configuration
         else:
             _json = configuration
 
-        request = build_train_request(
+        request = build_conversation_authoring_train_request(
             project_name=project_name,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
@@ -1326,14 +1560,18 @@
 
     @overload
     async def begin_train(
         self, project_name: str, configuration: JSON, *, content_type: str = "application/json", **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Triggers a training job for a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/train
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param configuration: The training input parameters. Required.
         :type configuration: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -1349,113 +1587,113 @@
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # JSON input template you can fill out and use as your body input.
                 configuration = {
+                    "modelLabel": "str",  # Represents the output model label. Required.
+                    "trainingMode": "str",  # Represents the mode of the training operation.
+                      Required. Known values are: "advanced" and "standard".
                     "evaluationOptions": {
                         "kind": "str",  # Optional. Represents the evaluation kind. By
                           default, the evaluation kind is set to percentage. Known values are:
                           "percentage" and "manual".
                         "testingSplitPercentage": 0,  # Optional. Represents the testing
                           dataset split percentage. Only needed in case the evaluation kind is
                           percentage.
                         "trainingSplitPercentage": 0  # Optional. Represents the training
                           dataset split percentage. Only needed in case the evaluation kind is
                           percentage.
                     },
-                    "modelLabel": "str",  # Represents the output model label. Required.
-                    "trainingConfigVersion": "str",  # Optional. Represents training config
+                    "trainingConfigVersion": "str"  # Optional. Represents training config
                       version. By default, "latest" value is used which uses the latest released
                       training config version.
-                    "trainingMode": "str"  # Represents the mode of the training operation.
-                      Required. Known values are: "advanced" and "standard".
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1463,14 +1701,18 @@
 
     @overload
     async def begin_train(
         self, project_name: str, configuration: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Triggers a training job for a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/train
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param configuration: The training input parameters. Required.
         :type configuration: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -1488,90 +1730,90 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1579,14 +1821,18 @@
 
     @distributed_trace_async
     async def begin_train(
         self, project_name: str, configuration: Union[JSON, IO], **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Triggers a training job for a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/train
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param configuration: The training input parameters. Is either a model type or a IO type.
          Required.
         :type configuration: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -1605,90 +1851,90 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1747,14 +1993,18 @@
 
     @distributed_trace
     def list_deployments(
         self, project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable[JSON]:
         """Lists the deployments belonging to a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-deployments
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
@@ -1772,30 +2022,42 @@
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_deployments_request(
+                request = build_conversation_authoring_list_deployments_request(
                     project_name=project_name,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -1804,18 +2066,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -1843,15 +2112,20 @@
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     async def _swap_deployments_initial(
         self, project_name: str, deployments: Union[JSON, IO], **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -1860,15 +2134,15 @@
         _json = None
         _content = None
         if isinstance(deployments, (IO, bytes)):
             _content = deployments
         else:
             _json = deployments
 
-        request = build_swap_deployments_request(
+        request = build_conversation_authoring_swap_deployments_request(
             project_name=project_name,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
@@ -1908,14 +2182,18 @@
 
     @overload
     async def begin_swap_deployments(
         self, project_name: str, deployments: JSON, *, content_type: str = "application/json", **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Swaps two existing deployments with each other.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/swap-deployments
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployments: The job object to swap two deployments. Required.
         :type deployments: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -1941,57 +2219,57 @@
                       Required.
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -1999,14 +2277,18 @@
 
     @overload
     async def begin_swap_deployments(
         self, project_name: str, deployments: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Swaps two existing deployments with each other.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/swap-deployments
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployments: The job object to swap two deployments. Required.
         :type deployments: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -2024,57 +2306,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -2082,14 +2364,18 @@
 
     @distributed_trace_async
     async def begin_swap_deployments(
         self, project_name: str, deployments: Union[JSON, IO], **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Swaps two existing deployments with each other.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/swap-deployments
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployments: The job object to swap two deployments. Is either a model type or a IO
          type. Required.
         :type deployments: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -2108,57 +2394,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -2215,14 +2501,18 @@
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
     @distributed_trace_async
     async def get_deployment(self, project_name: str, deployment_name: str, **kwargs: Any) -> JSON:
         """Gets the details of a deployment.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-deployment
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -2236,27 +2526,39 @@
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_deployment_request(
+        request = build_conversation_authoring_get_deployment_request(
             project_name=project_name,
             deployment_name=deployment_name,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -2283,15 +2585,20 @@
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     async def _deploy_project_initial(
         self, project_name: str, deployment_name: str, deployment: Union[JSON, IO], **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -2300,15 +2607,15 @@
         _json = None
         _content = None
         if isinstance(deployment, (IO, bytes)):
             _content = deployment
         else:
             _json = deployment
 
-        request = build_deploy_project_request(
+        request = build_conversation_authoring_deploy_project_request(
             project_name=project_name,
             deployment_name=deployment_name,
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
@@ -2355,14 +2662,18 @@
         deployment: JSON,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Creates a new deployment or replaces an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/deploy-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :param deployment: The new deployment info. Required.
         :type deployment: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -2380,29 +2691,42 @@
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # JSON input template you can fill out and use as your body input.
                 deployment = {
-                    "trainedModelLabel": "str"  # Represents the trained model label. Required.
+                    "trainedModelLabel": "str",  # Represents the trained model label. Required.
+                    "assignedResourceIds": [
+                        "str"  # Optional. Represents the resource IDs to be assigned to the
+                          deployment."n            If provided, the deployment will be rolled out to
+                          the resources provided here as well as the original resource in which the
+                          project is created.
+                    ]
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "deploymentExpirationDate": "2020-02-20",  # Represents deployment expiration
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
 
     @overload
     async def begin_deploy_project(
         self,
         project_name: str,
@@ -2410,14 +2734,18 @@
         deployment: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Creates a new deployment or replaces an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/deploy-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :param deployment: The new deployment info. Required.
         :type deployment: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -2443,25 +2771,36 @@
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
 
     @distributed_trace_async
     async def begin_deploy_project(
         self, project_name: str, deployment_name: str, deployment: Union[JSON, IO], **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Creates a new deployment or replaces an existing one.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/deploy-project
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :param deployment: The new deployment info. Is either a model type or a IO type. Required.
         :type deployment: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
@@ -2487,16 +2826,23 @@
                       date in the runtime. Required.
                     "deploymentName": "str",  # Represents deployment name. Required.
                     "lastDeployedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       deployed time. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # Represents deployment last
                       trained time. Required.
                     "modelId": "str",  # Represents deployment modelId. Required.
-                    "modelTrainingConfigVersion": "str"  # Represents model training config
+                    "modelTrainingConfigVersion": "str",  # Represents model training config
                       version. Required.
+                    "assignedResources": [
+                        {
+                            "region": "str",  # Represents the resource region. Required.
+                            "resourceId": "str"  # Represents the Azure resource Id.
+                              Required.
+                        }
+                    ]
                 }
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
@@ -2547,23 +2893,28 @@
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
     async def _delete_deployment_initial(
         self, project_name: str, deployment_name: str, **kwargs: Any
     ) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
 
-        request = build_delete_deployment_request(
+        request = build_conversation_authoring_delete_deployment_request(
             project_name=project_name,
             deployment_name=deployment_name,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -2601,14 +2952,18 @@
 
     @distributed_trace_async
     async def begin_delete_deployment(
         self, project_name: str, deployment_name: str, **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Deletes a project deployment.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-deployment
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
@@ -2623,57 +2978,57 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -2724,19 +3079,245 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
+    async def _delete_deployment_from_resources_initial(  # pylint: disable=inconsistent-return-statements
+        self, project_name: str, deployment_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IO, bytes)):
+            _content = body
+        else:
+            _json = body
+
+        request = build_conversation_authoring_delete_deployment_from_resources_request(
+            project_name=project_name,
+            deployment_name=deployment_name,
+            content_type=content_type,
+            api_version=self._config.api_version,
+            json=_json,
+            content=_content,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        response_headers = {}
+        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    @overload
+    async def begin_delete_deployment_from_resources(
+        self,
+        project_name: str,
+        deployment_name: str,
+        body: JSON,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Deletes a project deployment from the specified assigned resources.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-deployment-from-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param deployment_name: The name of the specific deployment of the project to use. Required.
+        :type deployment_name: str
+        :param body: The options for deleting the deployment. Required.
+        :type body: JSON
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns None
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # JSON input template you can fill out and use as your body input.
+                body = {
+                    "assignedResourceIds": [
+                        "str"  # Optional. Represents the resource IDs to delete the
+                          deployment from."n            If not provided, the deployment will be rolled
+                          out from all the resources it is deployed to."n            If provided, it
+                          will delete the deployment only from the specified assigned resources, and
+                          leave it for the rest.
+                    ]
+                }
+        """
+
+    @overload
+    async def begin_delete_deployment_from_resources(
+        self,
+        project_name: str,
+        deployment_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Deletes a project deployment from the specified assigned resources.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-deployment-from-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param deployment_name: The name of the specific deployment of the project to use. Required.
+        :type deployment_name: str
+        :param body: The options for deleting the deployment. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns None
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
     @distributed_trace_async
-    async def get_deployment_job_status(
+    async def begin_delete_deployment_from_resources(
+        self, project_name: str, deployment_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Deletes a project deployment from the specified assigned resources.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-deployment-from-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param deployment_name: The name of the specific deployment of the project to use. Required.
+        :type deployment_name: str
+        :param body: The options for deleting the deployment. Is either a model type or a IO type.
+         Required.
+        :type body: JSON or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns None
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        if cont_token is None:
+            raw_result = await self._delete_deployment_from_resources_initial(  # type: ignore
+                project_name=project_name,
+                deployment_name=deployment_name,
+                body=body,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+
+        if polling is True:
+            polling_method = cast(
+                AsyncPollingMethod,
+                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
+            )  # type: AsyncPollingMethod
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+
+    @distributed_trace_async
+    async def get_deployment_delete_from_resources_status(
         self, project_name: str, deployment_name: str, job_id: str, **kwargs: Any
     ) -> JSON:
-        """Gets the status of an existing deployment job.
+        """Gets the status of an existing delete deployment from specific resources job.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-deployment-delete-from-resources-status
+        for more information.
 
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param deployment_name: The name of the specific deployment of the project to use. Required.
         :type deployment_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
@@ -2747,74 +3328,203 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        request = build_conversation_authoring_get_deployment_delete_from_resources_status_request(
+            project_name=project_name,
+            deployment_name=deployment_name,
+            job_id=job_id,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        if response.content:
+            deserialized = response.json()
+        else:
+            deserialized = None
+
+        if cls:
+            return cls(pipeline_response, cast(JSON, deserialized), {})
+
+        return cast(JSON, deserialized)
+
+    @distributed_trace_async
+    async def get_deployment_job_status(
+        self, project_name: str, deployment_name: str, job_id: str, **kwargs: Any
+    ) -> JSON:
+        """Gets the status of an existing deployment job.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-deployment-status
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param deployment_name: The name of the specific deployment of the project to use. Required.
+        :type deployment_name: str
+        :param job_id: The job ID. Required.
+        :type job_id: str
+        :return: JSON object
+        :rtype: JSON
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
                     "jobId": "str",  # The job ID. Required.
                     "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
                       was updated. Required.
                     "status": "str",  # The job status. Required. Known values are: "notStarted",
                       "running", "succeeded", "failed", "cancelled", "cancelling", and
                       "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_deployment_job_status_request(
+        request = build_conversation_authoring_get_deployment_job_status_request(
             project_name=project_name,
             deployment_name=deployment_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
@@ -2843,14 +3553,18 @@
 
         return cast(JSON, deserialized)
 
     @distributed_trace_async
     async def get_swap_deployments_job_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status of an existing swap deployment job.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-swap-deployments-status
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -2858,74 +3572,79 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_swap_deployments_job_status_request(
+        request = build_conversation_authoring_get_swap_deployments_job_status_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -2953,14 +3672,18 @@
 
         return cast(JSON, deserialized)
 
     @distributed_trace_async
     async def get_export_project_job_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status of an export job. Once job completes, returns the project metadata, and assets.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-export-status
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -2968,76 +3691,81 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
                     "resultUrl": "str",  # Optional. The URL to use in order to download the
                       exported project.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_export_project_job_status_request(
+        request = build_conversation_authoring_get_export_project_job_status_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3065,14 +3793,18 @@
 
         return cast(JSON, deserialized)
 
     @distributed_trace_async
     async def get_import_project_job_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status for an import.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-import-status
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -3080,74 +3812,79 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_import_project_job_status_request(
+        request = build_conversation_authoring_get_import_project_job_status_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3177,14 +3914,18 @@
 
     @distributed_trace
     def list_trained_models(
         self, project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable[JSON]:
         """Lists the trained models belonging to a project.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-trained-models
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
@@ -3201,30 +3942,37 @@
                     "label": "str",  # The trained model label. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # The last trained date time
                       of the model. Required.
                     "lastTrainingDurationInSeconds": 0,  # The duration of the model's last
                       training request in seconds. Required.
                     "modelExpirationDate": "2020-02-20",  # The model expiration date. Required.
                     "modelId": "str",  # The model ID. Required.
-                    "modelTrainingConfigVersion": "str"  # The model training config version.
+                    "modelTrainingConfigVersion": "str",  # The model training config version.
                       Required.
+                    "hasSnapshot": bool  # Optional. The flag to indicate if the trained model
+                      has a snapshot ready.
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_trained_models_request(
+                request = build_conversation_authoring_list_trained_models_request(
                     project_name=project_name,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -3233,18 +3981,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -3273,14 +4028,18 @@
 
         return AsyncItemPaged(get_next, extract_data)
 
     @distributed_trace_async
     async def get_trained_model(self, project_name: str, trained_model_label: str, **kwargs: Any) -> JSON:
         """Gets the details of a trained model.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-trained-model
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param trained_model_label: The trained model label. Required.
         :type trained_model_label: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -3293,27 +4052,34 @@
                     "label": "str",  # The trained model label. Required.
                     "lastTrainedDateTime": "2020-02-20 00:00:00",  # The last trained date time
                       of the model. Required.
                     "lastTrainingDurationInSeconds": 0,  # The duration of the model's last
                       training request in seconds. Required.
                     "modelExpirationDate": "2020-02-20",  # The model expiration date. Required.
                     "modelId": "str",  # The model ID. Required.
-                    "modelTrainingConfigVersion": "str"  # The model training config version.
+                    "modelTrainingConfigVersion": "str",  # The model training config version.
                       Required.
+                    "hasSnapshot": bool  # Optional. The flag to indicate if the trained model
+                      has a snapshot ready.
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_trained_model_request(
+        request = build_conversation_authoring_get_trained_model_request(
             project_name=project_name,
             trained_model_label=trained_model_label,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3343,31 +4109,40 @@
 
     @distributed_trace_async
     async def delete_trained_model(  # pylint: disable=inconsistent-return-statements
         self, project_name: str, trained_model_label: str, **kwargs: Any
     ) -> None:
         """Deletes an existing trained model.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/delete-trained-model
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param trained_model_label: The trained model label. Required.
         :type trained_model_label: str
         :return: None
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[None]
 
-        request = build_delete_trained_model_request(
+        request = build_conversation_authoring_delete_trained_model_request(
             project_name=project_name,
             trained_model_label=trained_model_label,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3384,28 +4159,221 @@
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response)
 
         if cls:
             return cls(pipeline_response, None, {})
 
+    async def _load_snapshot_initial(
+        self, project_name: str, trained_model_label: str, **kwargs: Any
+    ) -> Optional[JSON]:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
+
+        request = build_conversation_authoring_load_snapshot_request(
+            project_name=project_name,
+            trained_model_label=trained_model_label,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        deserialized = None
+        response_headers = {}
+        if response.status_code == 200:
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+
+        if response.status_code == 202:
+            response_headers["operation-location"] = self._deserialize(
+                "str", response.headers.get("operation-location")
+            )
+
+        if cls:
+            return cls(pipeline_response, deserialized, response_headers)
+
+        return deserialized
+
+    @distributed_trace_async
+    async def begin_load_snapshot(
+        self, project_name: str, trained_model_label: str, **kwargs: Any
+    ) -> AsyncLROPoller[JSON]:
+        """Restores the snapshot of this trained model to be the current working directory of the project.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/load-snapshot
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param trained_model_label: The trained model label. Required.
+        :type trained_model_label: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns JSON object
+        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        if cont_token is None:
+            raw_result = await self._load_snapshot_initial(  # type: ignore
+                project_name=project_name,
+                trained_model_label=trained_model_label,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):
+            response = pipeline_response.http_response
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+            if cls:
+                return cls(pipeline_response, deserialized, {})
+            return deserialized
+
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+
+        if polling is True:
+            polling_method = cast(
+                AsyncPollingMethod,
+                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
+            )  # type: AsyncPollingMethod
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+
     @distributed_trace
     def list_model_evaluation_results(
         self,
         project_name: str,
         trained_model_label: str,
         *,
         string_index_type: str,
         top: Optional[int] = None,
         skip: Optional[int] = None,
         **kwargs: Any
     ) -> AsyncIterable[JSON]:
         """Gets the detailed results of the evaluation for a trained model. This includes the raw
         inference results for the data included in the evaluation process.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-model-evaluation-results
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param trained_model_label: The trained model label. Required.
         :type trained_model_label: str
         :keyword string_index_type: Specifies the method used to interpret string offsets. For
          additional information see https://aka.ms/text-analytics-offsets. "Utf16CodeUnit" Required.
         :paramtype string_index_type: str
@@ -3459,21 +4427,26 @@
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_model_evaluation_results_request(
+                request = build_conversation_authoring_list_model_evaluation_results_request(
                     project_name=project_name,
                     trained_model_label=trained_model_label,
                     string_index_type=string_index_type,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
@@ -3484,18 +4457,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -3525,14 +4505,18 @@
         return AsyncItemPaged(get_next, extract_data)
 
     @distributed_trace_async
     async def get_model_evaluation_summary(self, project_name: str, trained_model_label: str, **kwargs: Any) -> JSON:
         """Gets the evaluation summary of a trained model. The summary includes high level performance
         measurements of the model e.g., F1, Precision, Recall, etc.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-model-evaluation-summary
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param trained_model_label: The trained model label. Required.
         :type trained_model_label: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -3574,25 +4558,14 @@
                         "macroF1": 0.0,  # Represents the macro F1. Required.
                         "macroPrecision": 0.0,  # Represents the macro precision. Required.
                         "macroRecall": 0.0,  # Represents the macro recall. Required.
                         "microF1": 0.0,  # Represents the micro F1. Required.
                         "microPrecision": 0.0,  # Represents the micro precision. Required.
                         "microRecall": 0.0  # Represents the micro recall. Required.
                     },
-                    "evaluationOptions": {
-                        "kind": "str",  # Optional. Represents the evaluation kind. By
-                          default, the evaluation kind is set to percentage. Known values are:
-                          "percentage" and "manual".
-                        "testingSplitPercentage": 0,  # Optional. Represents the testing
-                          dataset split percentage. Only needed in case the evaluation kind is
-                          percentage.
-                        "trainingSplitPercentage": 0  # Optional. Represents the training
-                          dataset split percentage. Only needed in case the evaluation kind is
-                          percentage.
-                    },
                     "intentsEvaluation": {
                         "confusionMatrix": {
                             "str": {
                                 "str": {
                                     "normalizedValue": 0.0,  # Represents
                                       normalized value in percentages. Required.
                                     "rawValue": 0.0  # Represents raw value.
@@ -3620,28 +4593,168 @@
                         },
                         "macroF1": 0.0,  # Represents the macro F1. Required.
                         "macroPrecision": 0.0,  # Represents the macro precision. Required.
                         "macroRecall": 0.0,  # Represents the macro recall. Required.
                         "microF1": 0.0,  # Represents the micro F1. Required.
                         "microPrecision": 0.0,  # Represents the micro precision. Required.
                         "microRecall": 0.0  # Represents the micro recall. Required.
+                    },
+                    "evaluationOptions": {
+                        "kind": "str",  # Optional. Represents the evaluation kind. By
+                          default, the evaluation kind is set to percentage. Known values are:
+                          "percentage" and "manual".
+                        "testingSplitPercentage": 0,  # Optional. Represents the testing
+                          dataset split percentage. Only needed in case the evaluation kind is
+                          percentage.
+                        "trainingSplitPercentage": 0  # Optional. Represents the training
+                          dataset split percentage. Only needed in case the evaluation kind is
+                          percentage.
                     }
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        request = build_conversation_authoring_get_model_evaluation_summary_request(
+            project_name=project_name,
+            trained_model_label=trained_model_label,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        if response.content:
+            deserialized = response.json()
+        else:
+            deserialized = None
+
+        if cls:
+            return cls(pipeline_response, cast(JSON, deserialized), {})
+
+        return cast(JSON, deserialized)
+
+    @distributed_trace_async
+    async def get_load_snapshot_status(
+        self, project_name: str, trained_model_label: str, job_id: str, **kwargs: Any
+    ) -> JSON:
+        """Gets the status for loading a snapshot.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-load-snapshot-status
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param trained_model_label: The trained model label. Required.
+        :type trained_model_label: str
+        :param job_id: The job ID. Required.
+        :type job_id: str
+        :return: JSON object
+        :rtype: JSON
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_model_evaluation_summary_request(
+        request = build_conversation_authoring_get_load_snapshot_status_request(
             project_name=project_name,
             trained_model_label=trained_model_label,
+            job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
         }
@@ -3664,18 +4777,22 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     @distributed_trace
-    def list_training_jobs(
+    def list_deployment_resources(
         self, project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable[JSON]:
-        """Lists the non-expired training jobs created for a project.
+        """Lists the deployments resources assigned to the project.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-deployment-resources
+        for more information.
 
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
@@ -3686,112 +4803,1255 @@
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
+                    "azureResourceId": "str",  # The resource ID. Required.
+                    "region": "str"  # The resource region. Required.
+                }
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_conversation_authoring_list_deployment_resources_request(
+                    project_name=project_name,
+                    top=top,
+                    skip=skip,
+                    api_version=self._config.api_version,
+                    headers=_headers,
+                    params=_params,
+                )
+                path_format_arguments = {
+                    "Endpoint": self._serialize.url(
+                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
+                    ),
+                }
+                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                path_format_arguments = {
+                    "Endpoint": self._serialize.url(
+                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
+                    ),
+                }
+                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = pipeline_response.http_response.json()
+            list_of_elem = deserialized["value"]
+            if cls:
+                list_of_elem = cls(list_of_elem)
+            return deserialized.get("nextLink", None), AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    async def _assign_deployment_resources_initial(
+        self, project_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> Optional[JSON]:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IO, bytes)):
+            _content = body
+        else:
+            _json = body
+
+        request = build_conversation_authoring_assign_deployment_resources_request(
+            project_name=project_name,
+            content_type=content_type,
+            api_version=self._config.api_version,
+            json=_json,
+            content=_content,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        deserialized = None
+        response_headers = {}
+        if response.status_code == 200:
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+
+        if response.status_code == 202:
+            response_headers["operation-location"] = self._deserialize(
+                "str", response.headers.get("operation-location")
+            )
+
+        if cls:
+            return cls(pipeline_response, deserialized, response_headers)
+
+        return deserialized
+
+    @overload
+    async def begin_assign_deployment_resources(
+        self, project_name: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
+    ) -> AsyncLROPoller[JSON]:
+        """Assign new Azure resources to a project to allow deploying new deployments to them. This API is
+        available only via AAD authentication and not supported via subscription key authentication.
+        For more details about AAD authentication, check here:
+        https://learn.microsoft.com/en-us/azure/cognitive-services/authentication?tabs=powershell#authenticate-with-azure-active-directory
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/assign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The new project resources info. Required.
+        :type body: JSON
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns JSON object
+        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # JSON input template you can fill out and use as your body input.
+                body = {
+                    "resourcesMetadata": [
+                        {
+                            "azureResourceId": "str",  # Represents the Azure resource
+                              ID. Required.
+                            "customDomain": "str",  # Represents the Azure resource
+                              custom domain. Required.
+                            "region": "str"  # Represents the Azure resource region.
+                              Required.
+                        }
+                    ]
+                }
+
+                # response body for status code(s): 200
+                response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+
+    @overload
+    async def begin_assign_deployment_resources(
+        self, project_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
+    ) -> AsyncLROPoller[JSON]:
+        """Assign new Azure resources to a project to allow deploying new deployments to them. This API is
+        available only via AAD authentication and not supported via subscription key authentication.
+        For more details about AAD authentication, check here:
+        https://learn.microsoft.com/en-us/azure/cognitive-services/authentication?tabs=powershell#authenticate-with-azure-active-directory
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/assign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The new project resources info. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns JSON object
+        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+
+    @distributed_trace_async
+    async def begin_assign_deployment_resources(
+        self, project_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> AsyncLROPoller[JSON]:
+        """Assign new Azure resources to a project to allow deploying new deployments to them. This API is
+        available only via AAD authentication and not supported via subscription key authentication.
+        For more details about AAD authentication, check here:
+        https://learn.microsoft.com/en-us/azure/cognitive-services/authentication?tabs=powershell#authenticate-with-azure-active-directory
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/assign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The new project resources info. Is either a model type or a IO type. Required.
+        :type body: JSON or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns JSON object
+        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        if cont_token is None:
+            raw_result = await self._assign_deployment_resources_initial(  # type: ignore
+                project_name=project_name,
+                body=body,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):
+            response = pipeline_response.http_response
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+            if cls:
+                return cls(pipeline_response, deserialized, {})
+            return deserialized
+
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+
+        if polling is True:
+            polling_method = cast(
+                AsyncPollingMethod,
+                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
+            )  # type: AsyncPollingMethod
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+
+    async def _unassign_deployment_resources_initial(
+        self, project_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> Optional[JSON]:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IO, bytes)):
+            _content = body
+        else:
+            _json = body
+
+        request = build_conversation_authoring_unassign_deployment_resources_request(
+            project_name=project_name,
+            content_type=content_type,
+            api_version=self._config.api_version,
+            json=_json,
+            content=_content,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        deserialized = None
+        response_headers = {}
+        if response.status_code == 200:
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+
+        if response.status_code == 202:
+            response_headers["operation-location"] = self._deserialize(
+                "str", response.headers.get("operation-location")
+            )
+
+        if cls:
+            return cls(pipeline_response, deserialized, response_headers)
+
+        return deserialized
+
+    @overload
+    async def begin_unassign_deployment_resources(
+        self, project_name: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
+    ) -> AsyncLROPoller[JSON]:
+        """Unassign resources from a project. This disallows deploying new deployments to these resources,
+        and deletes existing deployments assigned to them.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/unassign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The info for the deployment resources to be deleted. Required.
+        :type body: JSON
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns JSON object
+        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # JSON input template you can fill out and use as your body input.
+                body = {
+                    "assignedResourceIds": [
+                        "str"  # Represents the assigned resource IDs to be unassigned.
+                          Required.
+                    ]
+                }
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
                                 "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
                                 "target": "str"  # Optional. Error target.
                             },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+
+    @overload
+    async def begin_unassign_deployment_resources(
+        self, project_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
+    ) -> AsyncLROPoller[JSON]:
+        """Unassign resources from a project. This disallows deploying new deployments to these resources,
+        and deletes existing deployments assigned to them.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/unassign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The info for the deployment resources to be deleted. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns JSON object
+        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
                             "message": "str",  # A human-readable representation of the
                               error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+
+    @distributed_trace_async
+    async def begin_unassign_deployment_resources(
+        self, project_name: str, body: Union[JSON, IO], **kwargs: Any
+    ) -> AsyncLROPoller[JSON]:
+        """Unassign resources from a project. This disallows deploying new deployments to these resources,
+        and deletes existing deployments assigned to them.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/unassign-deployment-resources
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param body: The info for the deployment resources to be deleted. Is either a model type or a
+         IO type. Required.
+        :type body: JSON or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
+         for this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns JSON object
+        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = kwargs.pop("params", {}) or {}
+
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        if cont_token is None:
+            raw_result = await self._unassign_deployment_resources_initial(  # type: ignore
+                project_name=project_name,
+                body=body,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):
+            response = pipeline_response.http_response
+            if response.content:
+                deserialized = response.json()
+            else:
+                deserialized = None
+            if cls:
+                return cls(pipeline_response, deserialized, {})
+            return deserialized
+
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+
+        if polling is True:
+            polling_method = cast(
+                AsyncPollingMethod,
+                AsyncLROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs),
+            )  # type: AsyncPollingMethod
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+
+    @distributed_trace_async
+    async def get_assign_deployment_resources_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
+        """Gets the status of an existing assign deployment resources job.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-assign-deployment-resources-status
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param job_id: The job ID. Required.
+        :type job_id: str
+        :return: JSON object
+        :rtype: JSON
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        request = build_conversation_authoring_get_assign_deployment_resources_status_request(
+            project_name=project_name,
+            job_id=job_id,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        if response.content:
+            deserialized = response.json()
+        else:
+            deserialized = None
+
+        if cls:
+            return cls(pipeline_response, cast(JSON, deserialized), {})
+
+        return cast(JSON, deserialized)
+
+    @distributed_trace_async
+    async def get_unassign_deployment_resources_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
+        """Gets the status of an existing unassign deployment resources job.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-unassign-deployment-resources-status
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :param job_id: The job ID. Required.
+        :type job_id: str
+        :return: JSON object
+        :rtype: JSON
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
+                    "warnings": [
+                        {
+                            "code": "str",  # The warning code. Required.
+                            "message": "str"  # The warning message. Required.
+                        }
+                    ]
+                }
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        request = build_conversation_authoring_get_unassign_deployment_resources_status_request(
+            project_name=project_name,
+            job_id=job_id,
+            api_version=self._config.api_version,
+            headers=_headers,
+            params=_params,
+        )
+        path_format_arguments = {
+            "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
+        }
+        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response)
+
+        if response.content:
+            deserialized = response.json()
+        else:
+            deserialized = None
+
+        if cls:
+            return cls(pipeline_response, cast(JSON, deserialized), {})
+
+        return cast(JSON, deserialized)
+
+    @distributed_trace
+    def list_training_jobs(
+        self, project_name: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
+    ) -> AsyncIterable[JSON]:
+        """Lists the non-expired training jobs created for a project.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-training-jobs
+        for more information.
+
+        :param project_name: The name of the project to use. Required.
+        :type project_name: str
+        :keyword top: The maximum number of resources to return from the collection. Default value is
+         None.
+        :paramtype top: int
+        :keyword skip: An offset into the collection of the first resource to be returned. Default
+         value is None.
+        :paramtype skip: int
+        :return: An iterator like instance of JSON object
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
+                      job. Required.
                     "jobId": "str",  # The job ID. Required.
                     "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
                       was updated. Required.
                     "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
                             "percentComplete": 0,  # Represents progress percentage.
                               Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
+                            "status": "str",  # Represents the status of the
                               sub-operation. Required. Known values are: "notStarted", "running",
                               "succeeded", "failed", "cancelled", "cancelling", and
                               "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
                             "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
                               the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
                             "percentComplete": 0,  # Represents progress percentage.
                               Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
+                            "status": "str",  # Represents the status of the
                               sub-operation. Required. Known values are: "notStarted", "running",
                               "succeeded", "failed", "cancelled", "cancelling", and
                               "partiallyCompleted".
-                        }
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
                     },
                     "status": "str",  # The job status. Required. Known values are: "notStarted",
                       "running", "succeeded", "failed", "cancelled", "cancelling", and
                       "partiallyCompleted".
+                    "errors": [
+                        {
+                            "code": "str",  # One of a server-defined set of error codes.
+                              Required. Known values are: "InvalidRequest", "InvalidArgument",
+                              "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
+                              "OperationNotFound", "AzureCognitiveSearchNotFound",
+                              "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
+                              "AzureCognitiveSearchThrottling",
+                              "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
+                              "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
+                              "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
+                            "details": [
+                                ...
+                            ],
+                            "innererror": {
+                                "code": "str",  # One of a server-defined set of
+                                  error codes. Required. Known values are: "InvalidRequest",
+                                  "InvalidParameterValue", "KnowledgeBaseNotFound",
+                                  "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
+                                  "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
+                                  "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
+                                  "InvalidDocumentBatch", "UnsupportedLanguageCode", and
+                                  "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
+                                "details": {
+                                    "str": "str"  # Optional. Error details.
+                                },
+                                "innererror": ...,
+                                "target": "str"  # Optional. Error target.
+                            },
+                            "target": "str"  # Optional. The target of the error.
+                        }
+                    ],
+                    "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
+                      time of the job.
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_training_jobs_request(
+                request = build_conversation_authoring_list_training_jobs_request(
                     project_name=project_name,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -3800,18 +6060,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -3840,14 +6107,18 @@
 
         return AsyncItemPaged(get_next, extract_data)
 
     @distributed_trace_async
     async def get_training_job_status(self, project_name: str, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status for a training job.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-training-status
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -3855,107 +6126,112 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_training_job_status_request(
+        request = build_conversation_authoring_get_training_job_status_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -3980,23 +6256,28 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     async def _cancel_training_job_initial(self, project_name: str, job_id: str, **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
 
-        request = build_cancel_training_job_request(
+        request = build_conversation_authoring_cancel_training_job_request(
             project_name=project_name,
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
@@ -4032,14 +6313,18 @@
 
         return deserialized
 
     @distributed_trace_async
     async def begin_cancel_training_job(self, project_name: str, job_id: str, **kwargs: Any) -> AsyncLROPoller[JSON]:
         """Triggers a cancellation for a running training job.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/cancel-training-job
+        for more information.
+
         :param project_name: The name of the project to use. Required.
         :type project_name: str
         :param job_id: The job ID. Required.
         :type job_id: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
@@ -4054,90 +6339,90 @@
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "result": {
+                        "modelLabel": "str",  # Represents trained model label. Required.
+                        "trainingConfigVersion": "str",  # Represents training config
+                          version. Required.
+                        "trainingStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
+                          Represents the estimated end date time for training and evaluation.
+                        "evaluationStatus": {
+                            "percentComplete": 0,  # Represents progress percentage.
+                              Required.
+                            "status": "str",  # Represents the status of the
+                              sub-operation. Required. Known values are: "notStarted", "running",
+                              "succeeded", "failed", "cancelled", "cancelling", and
+                              "partiallyCompleted".
+                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
+                              the end date time.
+                            "startDateTime": "2020-02-20 00:00:00"  # Optional.
+                              Represents the start date time.
+                        },
+                        "trainingMode": "str"  # Optional. Represents the mode of the
+                          training operation. Known values are: "advanced" and "standard".
+                    },
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "result": {
-                        "estimatedEndDateTime": "2020-02-20 00:00:00",  # Optional.
-                          Represents the estimated end date time for training and evaluation.
-                        "evaluationStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        },
-                        "modelLabel": "str",  # Represents trained model label. Required.
-                        "trainingConfigVersion": "str",  # Represents training config
-                          version. Required.
-                        "trainingMode": "str",  # Optional. Represents the mode of the
-                          training operation. Known values are: "advanced" and "standard".
-                        "trainingStatus": {
-                            "endDateTime": "2020-02-20 00:00:00",  # Optional. Represents
-                              the end date time.
-                            "percentComplete": 0,  # Represents progress percentage.
-                              Required.
-                            "startDateTime": "2020-02-20 00:00:00",  # Optional.
-                              Represents the start date time.
-                            "status": "str"  # Represents the status of the
-                              sub-operation. Required. Known values are: "notStarted", "running",
-                              "succeeded", "failed", "cancelled", "cancelling", and
-                              "partiallyCompleted".
-                        }
-                    },
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
@@ -4192,87 +6477,96 @@
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
     @distributed_trace_async
     async def get_project_deletion_job_status(self, job_id: str, **kwargs: Any) -> JSON:
         """Gets the status for a project deletion job.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-project-deletion-status
+        for more information.
+
         :param job_id: The job ID. Required.
         :type job_id: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # The creation date time of the
                       job. Required.
+                    "jobId": "str",  # The job ID. Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
+                      was updated. Required.
+                    "status": "str",  # The job status. Required. Known values are: "notStarted",
+                      "running", "succeeded", "failed", "cancelled", "cancelling", and
+                      "partiallyCompleted".
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional. The expiration date
                       time of the job.
-                    "jobId": "str",  # The job ID. Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # The last date time the job
-                      was updated. Required.
-                    "status": "str",  # The job status. Required. Known values are: "notStarted",
-                      "running", "succeeded", "failed", "cancelled", "cancelling", and
-                      "partiallyCompleted".
                     "warnings": [
                         {
                             "code": "str",  # The warning code. Required.
                             "message": "str"  # The warning message. Required.
                         }
                     ]
                 }
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        request = build_get_project_deletion_job_status_request(
+        request = build_conversation_authoring_get_project_deletion_job_status_request(
             job_id=job_id,
             api_version=self._config.api_version,
             headers=_headers,
             params=_params,
         )
         path_format_arguments = {
             "Endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
@@ -4296,21 +6590,140 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     @distributed_trace
+    def list_assigned_resource_deployments(
+        self, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
+    ) -> AsyncIterable[JSON]:
+        """Lists the deployments to which an Azure resource is assigned. This doesn't return deployments
+        belonging to projects owned by this resource. It only returns deployments belonging to projects
+        owned by other resources.
+
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-assigned-resource-deployments
+        for more information.
+
+        :keyword top: The maximum number of resources to return from the collection. Default value is
+         None.
+        :paramtype top: int
+        :keyword skip: An offset into the collection of the first resource to be returned. Default
+         value is None.
+        :paramtype skip: int
+        :return: An iterator like instance of JSON object
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
+        :raises ~azure.core.exceptions.HttpResponseError:
+
+        Example:
+            .. code-block:: python
+
+                # response body for status code(s): 200
+                response == {
+                    "deploymentsMetadata": [
+                        {
+                            "deploymentExpirationDate": "2020-02-20",  # Represents
+                              deployment expiration date in the runtime. Required.
+                            "deploymentName": "str",  # Represents the deployment name.
+                              Required.
+                            "lastDeployedDateTime": "2020-02-20 00:00:00"  # Represents
+                              deployment last deployed time. Required.
+                        }
+                    ],
+                    "projectName": "str"  # Represents the project name. Required.
+                }
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = kwargs.pop("params", {}) or {}
+
+        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_conversation_authoring_list_assigned_resource_deployments_request(
+                    top=top,
+                    skip=skip,
+                    api_version=self._config.api_version,
+                    headers=_headers,
+                    params=_params,
+                )
+                path_format_arguments = {
+                    "Endpoint": self._serialize.url(
+                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
+                    ),
+                }
+                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                path_format_arguments = {
+                    "Endpoint": self._serialize.url(
+                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
+                    ),
+                }
+                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = pipeline_response.http_response.json()
+            list_of_elem = deserialized["value"]
+            if cls:
+                list_of_elem = cls(list_of_elem)
+            return deserialized.get("nextLink", None), AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    @distributed_trace
     def list_supported_languages(
         self, *, project_kind: str, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable[JSON]:
         """Lists the supported languages for the given project type.
 
-        :keyword project_kind: The project kind. Known values are: "Conversation" and "Orchestration".
-         Required.
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-supported-languages
+        for more information.
+
+        :keyword project_kind: The project kind. Known values are: "Conversation", "Orchestration", and
+         "CustomConversationSummarization". Required.
         :paramtype project_kind: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
         :paramtype skip: int
@@ -4330,21 +6743,26 @@
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_supported_languages_request(
+                request = build_conversation_authoring_list_supported_languages_request(
                     project_kind=project_kind,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -4353,18 +6771,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -4401,14 +6826,18 @@
         multilingual: Optional[bool] = None,
         top: Optional[int] = None,
         skip: Optional[int] = None,
         **kwargs: Any
     ) -> AsyncIterable[JSON]:
         """Lists the supported prebuilt entities that can be used while creating composed entities.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/get-supported-prebuilt-entities
+        for more information.
+
         :keyword language: The language to get supported prebuilt entities for. Required if
          multilingual is false. This is BCP-47 representation of a language. For example, use "en" for
          English, "en-gb" for English (UK), "es" for Spanish etc. Default value is None.
         :paramtype language: str
         :keyword multilingual: Whether to get the support prebuilt entities for multilingual or
          monolingual projects. If true, the language parameter is ignored. Default value is None.
         :paramtype multilingual: bool
@@ -4433,21 +6862,26 @@
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_supported_prebuilt_entities_request(
+                request = build_conversation_authoring_list_supported_prebuilt_entities_request(
                     language=language,
                     multilingual=multilingual,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
@@ -4457,18 +6891,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
@@ -4499,16 +6940,20 @@
 
     @distributed_trace
     def list_training_config_versions(
         self, *, project_kind: str, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable[JSON]:
         """Lists the support training config version for a given project type.
 
-        :keyword project_kind: The project kind. Known values are: "Conversation" and "Orchestration".
-         Required.
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversational-analysis-authoring/list-training-config-versions
+        for more information.
+
+        :keyword project_kind: The project kind. Known values are: "Conversation", "Orchestration", and
+         "CustomConversationSummarization". Required.
         :paramtype project_kind: str
         :keyword top: The maximum number of resources to return from the collection. Default value is
          None.
         :paramtype top: int
         :keyword skip: An offset into the collection of the first resource to be returned. Default
          value is None.
         :paramtype skip: int
@@ -4528,21 +6973,26 @@
                 }
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = kwargs.pop("params", {}) or {}
 
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
 
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_training_config_versions_request(
+                request = build_conversation_authoring_list_training_config_versions_request(
                     project_kind=project_kind,
                     top=top,
                     skip=skip,
                     api_version=self._config.api_version,
                     headers=_headers,
                     params=_params,
                 )
@@ -4551,18 +7001,25 @@
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
-                _parsed_next_link = urlparse(next_link)
-                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
                 _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 path_format_arguments = {
                     "Endpoint": self._serialize.url(
                         "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                     ),
                 }
                 request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/__init__.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -2,20 +2,25 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from ._client import ConversationAnalysisClient
+from ._client import ConversationAuthoringClient
+from ._version import VERSION
+
+__version__ = VERSION
 
 try:
     from ._patch import __all__ as _patch_all
     from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
-__all__ = ["ConversationAnalysisClient"]
+__all__ = [
+    "ConversationAuthoringClient",
+]
 __all__.extend([p for p in _patch_all if p not in __all__])
 
 _patch_sdk()
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_configuration.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_configuration.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,45 +2,51 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
-class ConversationAnalysisClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
-    """Configuration for ConversationAnalysisClient.
+class ConversationAuthoringClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
+    """Configuration for ConversationAuthoringClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
-    :keyword api_version: Api Version. Default value is "2022-05-15-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, endpoint: str, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
-        super(ConversationAnalysisClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "2022-05-15-preview")  # type: str
+        super(ConversationAuthoringClientConfiguration, self).__init__(**kwargs)
+        api_version = kwargs.pop("api_version", "2022-10-01-preview")  # type: Literal["2022-10-01-preview"]
 
         if endpoint is None:
             raise ValueError("Parameter 'endpoint' must not be None.")
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.endpoint = endpoint
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_client.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,16 +14,14 @@
 
 from .._serialization import Deserializer, Serializer
 from ._configuration import ConversationAnalysisClientConfiguration
 from ._operations import ConversationAnalysisClientOperationsMixin
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from typing import Dict
-
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class ConversationAnalysisClient(
     ConversationAnalysisClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The language service conversations API is a suite of natural language processing (NLP) skills
@@ -38,15 +36,15 @@
     Summarization and Conversational PII detection.
 
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
-    :keyword api_version: Api Version. Default value is "2022-05-15-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, endpoint: str, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_patch.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_patch.py`

 * *Files 9% similar despite different names*

```diff
@@ -29,33 +29,32 @@
 # https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/customize_code/how-to-patch-sdk-code.md
 
 from typing import List, Union, Any
 from azure.core.credentials import AzureKeyCredential
 from azure.core.credentials_async import AsyncTokenCredential
 from azure.core.pipeline.policies import AzureKeyCredentialPolicy
 from ._client import ConversationAnalysisClient as GeneratedConversationAnalysisClient
+from .._patch import POLLING_INTERVAL_DEFAULT
 
 
 def _authentication_policy(credential):
     authentication_policy = None
     if credential is None:
         raise ValueError("Parameter 'credential' must not be None.")
     if isinstance(credential, AzureKeyCredential):
-        authentication_policy = AzureKeyCredentialPolicy(
-            name="Ocp-Apim-Subscription-Key", credential=credential
-        )
+        authentication_policy = AzureKeyCredentialPolicy(name="Ocp-Apim-Subscription-Key", credential=credential)
     elif credential is not None and not hasattr(credential, "get_token"):
         raise TypeError(
-            "Unsupported credential: {}. Use an instance of AzureKeyCredential "
-            "or a token credential from azure.identity".format(type(credential))
+            f"Unsupported credential: {type(credential)}. Use an instance of AzureKeyCredential "
+            "or a token credential from azure.identity"
         )
     return authentication_policy
 
 
-class ConversationAnalysisClient(GeneratedConversationAnalysisClient): # pylint: disable=client-accepts-api-version-keyword
+class ConversationAnalysisClient(GeneratedConversationAnalysisClient):
     """The language service conversations API is a suite of natural language processing (NLP) skills
     that can be used to analyze structured conversations (textual or spoken). The synchronous API
     in this suite accepts a request and mediates among multiple language projects, such as LUIS
     Generally Available, Question Answering, Conversational Language Understanding, and then calls
     the best candidate service to handle the request. At last, it returns a response with the
     candidate service's response as a payload.
 
@@ -65,29 +64,35 @@
     :param endpoint: Supported Cognitive Services endpoint (e.g.,
      https://:code:`<resource-name>`.cognitiveservices.azure.com). Required.
     :type endpoint: str
     :param credential: Credential needed for the client to connect to Azure.
         This can be the an instance of AzureKeyCredential if using a Language API key
         or a token credential from :mod:`azure.identity`.
     :type credential: ~azure.core.credentials.AzureKeyCredential or ~azure.core.credentials_async.AsyncTokenCredential
-    :keyword api_version: Api Version. Available values are "2022-05-15-preview" and "2022-05-01". Default
-     value is "2022-05-15-preview". Note that overriding this default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Available values are "2022-10-01-preview", "2022-05-15-preview",
+     "2022-05-01". Default value is "2022-10-01-preview". Note that overriding this default value may result in
+     unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self, endpoint: str, credential: Union[AzureKeyCredential, AsyncTokenCredential], **kwargs: Any
     ) -> None:
+        try:
+            endpoint = endpoint.rstrip("/")
+        except AttributeError:
+            raise ValueError("Parameter 'endpoint' must be a string.")
         super().__init__(
             endpoint=endpoint,
             credential=credential,  # type: ignore
             authentication_policy=kwargs.pop("authentication_policy", _authentication_policy(credential)),
-            **kwargs
+            polling_interval=kwargs.pop("polling_interval", POLLING_INTERVAL_DEFAULT),
+            **kwargs,
         )
 
 
 __all__: List[str] = ["ConversationAnalysisClient"]
 
 
 def patch_sdk():
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_vendor.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/authoring/aio/_vendor.py`

 * *Files 26% similar despite different names*

```diff
@@ -4,23 +4,23 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
 from typing import TYPE_CHECKING
 
-from ._configuration import ConversationAnalysisClientConfiguration
+from ._configuration import ConversationAuthoringClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core import AsyncPipelineClient
 
     from .._serialization import Deserializer, Serializer
 
 
-class MixinABC(ABC):
+class ConversationAuthoringClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
 
     _client: "AsyncPipelineClient"
-    _config: ConversationAnalysisClientConfiguration
+    _config: ConversationAuthoringClientConfiguration
     _serialize: "Serializer"
     _deserialize: "Deserializer"
```

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/__init__.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-ai-language-conversations-1.1.0b2/azure/ai/language/conversations/aio/_operations/_operations.py` & `azure-ai-language-conversations-1.1.0b3/azure/ai/language/conversations/aio/_operations/_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -10,41 +10,49 @@
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
+    ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
 from azure.core.polling.async_base_polling import AsyncLROBasePolling
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 
-from ..._operations._operations import build_analyze_conversation_request, build_conversation_analysis_request
-from .._vendor import MixinABC
+from ..._operations._operations import (
+    build_conversation_analysis_analyze_conversation_request,
+    build_conversation_analysis_conversation_analysis_request,
+)
+from .._vendor import ConversationAnalysisClientMixinABC
 
 if sys.version_info >= (3, 9):
     from collections.abc import MutableMapping
 else:
     from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
 JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ConversationAnalysisClientOperationsMixin(MixinABC):
+class ConversationAnalysisClientOperationsMixin(ConversationAnalysisClientMixinABC):
     @overload
     async def analyze_conversation(self, task: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
         """Analyzes the input conversation utterance.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis/analyze-conversation
+        for more information.
+
         :param task: A single conversational task to execute. Required.
         :type task: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :return: JSON object
         :rtype: JSON
@@ -57,33 +65,33 @@
                   discriminator "kind":
 
                 # JSON input template for discriminator value "Conversation":
                 analyze_conversation_task = {
                     "analysisInput": {
                         "conversationItem": {
                             "id": "str",  # The ID of a conversation item. Required.
+                            "participantId": "str",  # The participant ID of a
+                              conversation item. Required.
                             "language": "str",  # Optional. The override language of a
                               conversation item in BCP 47 language representation.
                             "modality": "str",  # Optional. Enumeration of supported
                               conversational modalities. Known values are: "transcript" and "text".
-                            "participantId": "str",  # The participant ID of a
-                              conversation item. Required.
                             "role": "str"  # Optional. The role of the participant. Known
                               values are: "agent", "customer", and "generic".
                         }
                     },
                     "kind": "Conversation",
                     "parameters": {
                         "deploymentName": "str",  # The name of the deployment to use.
                           Required.
+                        "projectName": "str",  # The name of the project to use. Required.
                         "directTarget": "str",  # Optional. The name of a target project to
                           forward the request to.
                         "isLoggingEnabled": bool,  # Optional. If true, the service will keep
                           the query for further review.
-                        "projectName": "str",  # The name of the project to use. Required.
                         "stringIndexType": "TextElements_v8",  # Optional. Default value is
                           "TextElements_v8". Specifies the method used to interpret string offsets. Set
                           to "UnicodeCodePoint" for Python strings. Known values are:
                           "TextElements_v8", "UnicodeCodePoint", and "Utf16CodeUnit".
                         "targetProjectParameters": {
                             "str": analysis_parameters
                         },
@@ -97,95 +105,227 @@
                 # The response is polymorphic. The following are possible polymorphic responses based
                   off discriminator "kind":
 
                 # JSON input template for discriminator value "ConversationResult":
                 analyze_conversation_task_result = {
                     "kind": "ConversationResult",
                     "result": {
-                        "detectedLanguage": "str",  # Optional. The system detected language
-                          for the query in BCP 47 language representation..
                         "prediction": base_prediction,
-                        "query": "str"  # The conversation utterance given by the caller.
+                        "query": "str",  # The conversation utterance given by the caller.
                           Required.
+                        "detectedLanguage": "str"  # Optional. The system detected language
+                          for the query in BCP 47 language representation..
                     }
                 }
 
+                # JSON input template for discriminator value "Conversation":
+                base_prediction = {
+                    "entities": [
+                        {
+                            "category": "str",  # The entity category. Required.
+                            "confidenceScore": 0.0,  # The entity confidence score.
+                              Required.
+                            "length": 0,  # The length of the text. Required.
+                            "offset": 0,  # The starting index of this entity in the
+                              query. Required.
+                            "text": "str",  # The predicted entity text. Required.
+                            "extraInformation": [
+                                base_extra_information
+                            ],
+                            "resolutions": [
+                                base_resolution
+                            ]
+                        }
+                    ],
+                    "intents": [
+                        {
+                            "category": "str",  # A predicted class. Required.
+                            "confidenceScore": 0.0  # The confidence score of the class
+                              from 0.0 to 1.0. Required.
+                        }
+                    ],
+                    "projectKind": "Conversation",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
+                # JSON input template for discriminator value "Orchestration":
+                base_prediction = {
+                    "intents": {
+                        "str": target_intent_result
+                    },
+                    "projectKind": "Orchestration",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
                 # response body for status code(s): 200
                 response == analyze_conversation_task_result
         """
 
     @overload
     async def analyze_conversation(self, task: IO, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
         """Analyzes the input conversation utterance.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis/analyze-conversation
+        for more information.
+
         :param task: A single conversational task to execute. Required.
         :type task: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
+
                 # The response is polymorphic. The following are possible polymorphic responses based
                   off discriminator "kind":
 
                 # JSON input template for discriminator value "ConversationResult":
                 analyze_conversation_task_result = {
                     "kind": "ConversationResult",
                     "result": {
-                        "detectedLanguage": "str",  # Optional. The system detected language
-                          for the query in BCP 47 language representation..
                         "prediction": base_prediction,
-                        "query": "str"  # The conversation utterance given by the caller.
+                        "query": "str",  # The conversation utterance given by the caller.
                           Required.
+                        "detectedLanguage": "str"  # Optional. The system detected language
+                          for the query in BCP 47 language representation..
                     }
                 }
 
+                # JSON input template for discriminator value "Conversation":
+                base_prediction = {
+                    "entities": [
+                        {
+                            "category": "str",  # The entity category. Required.
+                            "confidenceScore": 0.0,  # The entity confidence score.
+                              Required.
+                            "length": 0,  # The length of the text. Required.
+                            "offset": 0,  # The starting index of this entity in the
+                              query. Required.
+                            "text": "str",  # The predicted entity text. Required.
+                            "extraInformation": [
+                                base_extra_information
+                            ],
+                            "resolutions": [
+                                base_resolution
+                            ]
+                        }
+                    ],
+                    "intents": [
+                        {
+                            "category": "str",  # A predicted class. Required.
+                            "confidenceScore": 0.0  # The confidence score of the class
+                              from 0.0 to 1.0. Required.
+                        }
+                    ],
+                    "projectKind": "Conversation",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
+                # JSON input template for discriminator value "Orchestration":
+                base_prediction = {
+                    "intents": {
+                        "str": target_intent_result
+                    },
+                    "projectKind": "Orchestration",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
                 # response body for status code(s): 200
                 response == analyze_conversation_task_result
         """
 
     @distributed_trace_async
     async def analyze_conversation(self, task: Union[JSON, IO], **kwargs: Any) -> JSON:
         """Analyzes the input conversation utterance.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis/analyze-conversation
+        for more information.
+
         :param task: A single conversational task to execute. Is either a model type or a IO type.
          Required.
         :type task: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :return: JSON object
         :rtype: JSON
         :raises ~azure.core.exceptions.HttpResponseError:
 
         Example:
             .. code-block:: python
+
                 # The response is polymorphic. The following are possible polymorphic responses based
                   off discriminator "kind":
 
                 # JSON input template for discriminator value "ConversationResult":
                 analyze_conversation_task_result = {
                     "kind": "ConversationResult",
                     "result": {
-                        "detectedLanguage": "str",  # Optional. The system detected language
-                          for the query in BCP 47 language representation..
                         "prediction": base_prediction,
-                        "query": "str"  # The conversation utterance given by the caller.
+                        "query": "str",  # The conversation utterance given by the caller.
                           Required.
+                        "detectedLanguage": "str"  # Optional. The system detected language
+                          for the query in BCP 47 language representation..
                     }
                 }
 
+                # JSON input template for discriminator value "Conversation":
+                base_prediction = {
+                    "entities": [
+                        {
+                            "category": "str",  # The entity category. Required.
+                            "confidenceScore": 0.0,  # The entity confidence score.
+                              Required.
+                            "length": 0,  # The length of the text. Required.
+                            "offset": 0,  # The starting index of this entity in the
+                              query. Required.
+                            "text": "str",  # The predicted entity text. Required.
+                            "extraInformation": [
+                                base_extra_information
+                            ],
+                            "resolutions": [
+                                base_resolution
+                            ]
+                        }
+                    ],
+                    "intents": [
+                        {
+                            "category": "str",  # A predicted class. Required.
+                            "confidenceScore": 0.0  # The confidence score of the class
+                              from 0.0 to 1.0. Required.
+                        }
+                    ],
+                    "projectKind": "Conversation",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
+                # JSON input template for discriminator value "Orchestration":
+                base_prediction = {
+                    "intents": {
+                        "str": target_intent_result
+                    },
+                    "projectKind": "Orchestration",
+                    "topIntent": "str"  # Optional. The intent with the highest score.
+                }
+
                 # response body for status code(s): 200
                 response == analyze_conversation_task_result
         """
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
@@ -194,15 +334,15 @@
         _json = None
         _content = None
         if isinstance(task, (IO, bytes)):
             _content = task
         else:
             _json = task
 
-        request = build_analyze_conversation_request(
+        request = build_conversation_analysis_analyze_conversation_request(
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
         )
@@ -228,15 +368,20 @@
 
         if cls:
             return cls(pipeline_response, cast(JSON, deserialized), {})
 
         return cast(JSON, deserialized)
 
     async def _conversation_analysis_initial(self, task: Union[JSON, IO], **kwargs: Any) -> Optional[JSON]:
-        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
         cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]
@@ -245,15 +390,15 @@
         _json = None
         _content = None
         if isinstance(task, (IO, bytes)):
             _content = task
         else:
             _json = task
 
-        request = build_conversation_analysis_request(
+        request = build_conversation_analysis_conversation_analysis_request(
             content_type=content_type,
             api_version=self._config.api_version,
             json=_json,
             content=_content,
             headers=_headers,
             params=_params,
         )
@@ -295,14 +440,18 @@
         self, task: JSON, *, content_type: str = "application/json", **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Submit analysis job for conversations.
 
         Submit a collection of conversations for analysis. Specify one or more unique tasks to be
         executed.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime/submit-job
+        for more information.
+
         :param task: The collection of conversations to analyze and one or more tasks to execute.
          Required.
         :type task: JSON
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -322,100 +471,111 @@
                 # JSON input template you can fill out and use as your body input.
                 task = {
                     "analysisInput": {
                         "conversations": [
                             conversation
                         ]
                     },
-                    "displayName": "str",  # Optional. Optional display name for the analysis
-                      job.
                     "tasks": [
                         analyze_conversation_lro_task
-                    ]
+                    ],
+                    "displayName": "str"  # Optional. Optional display name for the analysis job.
                 }
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Required.
+                    "jobId": "str",  # Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
+                    "status": "str",  # The status of the task at the mentioned last update time.
+                      Required. Known values are: "notStarted", "running", "succeeded", "failed",
+                      "cancelled", "cancelling", and "partiallyCompleted".
+                    "tasks": {
+                        "completed": 0,  # Count of tasks completed successfully. Required.
+                        "failed": 0,  # Count of tasks that failed. Required.
+                        "inProgress": 0,  # Count of tasks in progress currently. Required.
+                        "total": 0,  # Total count of tasks submitted as part of the job.
+                          Required.
+                        "items": [
+                            analyze_conversation_job_result
+                        ]
+                    },
                     "displayName": "str",  # Optional.
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional.
-                    "jobId": "str",  # Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
                     "nextLink": "str",  # Optional.
                     "statistics": {
                         "conversationsCount": 0,  # Number of conversations submitted in the
                           request. Required.
+                        "documentsCount": 0,  # Number of documents submitted in the request.
+                          Required.
                         "erroneousConversationsCount": 0,  # Number of invalid documents.
                           This includes empty, over-size limit or non-supported languages documents.
                           Required.
+                        "erroneousDocumentsCount": 0,  # Number of invalid documents. This
+                          includes empty, over-size limit or non-supported languages documents.
+                          Required.
                         "transactionsCount": 0,  # Number of transactions for the request.
                           Required.
-                        "validConversationsCount": 0  # Number of conversations documents.
+                        "validConversationsCount": 0,  # Number of conversations documents.
                           This excludes empty, over-size limit or non-supported languages documents.
                           Required.
-                    },
-                    "status": "str",  # Required. Known values are: "notStarted", "running",
-                      "succeeded", "partiallyCompleted", "failed", "cancelled", and "cancelling".
-                    "tasks": {
-                        "completed": 0,  # Count of tasks completed successfully. Required.
-                        "failed": 0,  # Count of tasks that failed. Required.
-                        "inProgress": 0,  # Count of tasks in progress currently. Required.
-                        "items": [
-                            analyze_conversation_job_result
-                        ],
-                        "total": 0  # Total count of tasks submitted as part of the job.
-                          Required.
+                        "validDocumentsCount": 0  # Number of valid documents. This excludes
+                          empty, over-size limit or non-supported languages documents. Required.
                     }
                 }
         """
 
     @overload
     async def begin_conversation_analysis(
         self, task: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> AsyncLROPoller[JSON]:
         """Submit analysis job for conversations.
 
         Submit a collection of conversations for analysis. Specify one or more unique tasks to be
         executed.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime/submit-job
+        for more information.
+
         :param task: The collection of conversations to analyze and one or more tasks to execute.
          Required.
         :type task: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -431,88 +591,100 @@
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Required.
+                    "jobId": "str",  # Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
+                    "status": "str",  # The status of the task at the mentioned last update time.
+                      Required. Known values are: "notStarted", "running", "succeeded", "failed",
+                      "cancelled", "cancelling", and "partiallyCompleted".
+                    "tasks": {
+                        "completed": 0,  # Count of tasks completed successfully. Required.
+                        "failed": 0,  # Count of tasks that failed. Required.
+                        "inProgress": 0,  # Count of tasks in progress currently. Required.
+                        "total": 0,  # Total count of tasks submitted as part of the job.
+                          Required.
+                        "items": [
+                            analyze_conversation_job_result
+                        ]
+                    },
                     "displayName": "str",  # Optional.
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional.
-                    "jobId": "str",  # Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
                     "nextLink": "str",  # Optional.
                     "statistics": {
                         "conversationsCount": 0,  # Number of conversations submitted in the
                           request. Required.
+                        "documentsCount": 0,  # Number of documents submitted in the request.
+                          Required.
                         "erroneousConversationsCount": 0,  # Number of invalid documents.
                           This includes empty, over-size limit or non-supported languages documents.
                           Required.
+                        "erroneousDocumentsCount": 0,  # Number of invalid documents. This
+                          includes empty, over-size limit or non-supported languages documents.
+                          Required.
                         "transactionsCount": 0,  # Number of transactions for the request.
                           Required.
-                        "validConversationsCount": 0  # Number of conversations documents.
+                        "validConversationsCount": 0,  # Number of conversations documents.
                           This excludes empty, over-size limit or non-supported languages documents.
                           Required.
-                    },
-                    "status": "str",  # Required. Known values are: "notStarted", "running",
-                      "succeeded", "partiallyCompleted", "failed", "cancelled", and "cancelling".
-                    "tasks": {
-                        "completed": 0,  # Count of tasks completed successfully. Required.
-                        "failed": 0,  # Count of tasks that failed. Required.
-                        "inProgress": 0,  # Count of tasks in progress currently. Required.
-                        "items": [
-                            analyze_conversation_job_result
-                        ],
-                        "total": 0  # Total count of tasks submitted as part of the job.
-                          Required.
+                        "validDocumentsCount": 0  # Number of valid documents. This excludes
+                          empty, over-size limit or non-supported languages documents. Required.
                     }
                 }
         """
 
     @distributed_trace_async
     async def begin_conversation_analysis(self, task: Union[JSON, IO], **kwargs: Any) -> AsyncLROPoller[JSON]:
         """Submit analysis job for conversations.
 
         Submit a collection of conversations for analysis. Specify one or more unique tasks to be
         executed.
 
+        See
+        https://learn.microsoft.com/rest/api/language/2022-10-01-preview/conversation-analysis-runtime/submit-job
+        for more information.
+
         :param task: The collection of conversations to analyze and one or more tasks to execute. Is
          either a model type or a IO type. Required.
         :type task: JSON or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -528,77 +700,85 @@
 
         Example:
             .. code-block:: python
 
                 # response body for status code(s): 200
                 response == {
                     "createdDateTime": "2020-02-20 00:00:00",  # Required.
+                    "jobId": "str",  # Required.
+                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
+                    "status": "str",  # The status of the task at the mentioned last update time.
+                      Required. Known values are: "notStarted", "running", "succeeded", "failed",
+                      "cancelled", "cancelling", and "partiallyCompleted".
+                    "tasks": {
+                        "completed": 0,  # Count of tasks completed successfully. Required.
+                        "failed": 0,  # Count of tasks that failed. Required.
+                        "inProgress": 0,  # Count of tasks in progress currently. Required.
+                        "total": 0,  # Total count of tasks submitted as part of the job.
+                          Required.
+                        "items": [
+                            analyze_conversation_job_result
+                        ]
+                    },
                     "displayName": "str",  # Optional.
                     "errors": [
                         {
                             "code": "str",  # One of a server-defined set of error codes.
                               Required. Known values are: "InvalidRequest", "InvalidArgument",
                               "Unauthorized", "Forbidden", "NotFound", "ProjectNotFound",
                               "OperationNotFound", "AzureCognitiveSearchNotFound",
                               "AzureCognitiveSearchIndexNotFound", "TooManyRequests",
                               "AzureCognitiveSearchThrottling",
                               "AzureCognitiveSearchIndexLimitReached", "InternalServerError",
                               "ServiceUnavailable", "Timeout", "QuotaExceeded", "Conflict", and
                               "Warning".
+                            "message": "str",  # A human-readable representation of the
+                              error. Required.
                             "details": [
                                 ...
                             ],
                             "innererror": {
                                 "code": "str",  # One of a server-defined set of
                                   error codes. Required. Known values are: "InvalidRequest",
                                   "InvalidParameterValue", "KnowledgeBaseNotFound",
                                   "AzureCognitiveSearchNotFound", "AzureCognitiveSearchThrottling",
                                   "ExtractionFailure", "InvalidRequestBodyFormat", "EmptyRequest",
                                   "MissingInputDocuments", "InvalidDocument", "ModelVersionIncorrect",
                                   "InvalidDocumentBatch", "UnsupportedLanguageCode", and
                                   "InvalidCountryHint".
+                                "message": "str",  # Error message. Required.
                                 "details": {
                                     "str": "str"  # Optional. Error details.
                                 },
                                 "innererror": ...,
-                                "message": "str",  # Error message. Required.
                                 "target": "str"  # Optional. Error target.
                             },
-                            "message": "str",  # A human-readable representation of the
-                              error. Required.
                             "target": "str"  # Optional. The target of the error.
                         }
                     ],
                     "expirationDateTime": "2020-02-20 00:00:00",  # Optional.
-                    "jobId": "str",  # Required.
-                    "lastUpdatedDateTime": "2020-02-20 00:00:00",  # Required.
                     "nextLink": "str",  # Optional.
                     "statistics": {
                         "conversationsCount": 0,  # Number of conversations submitted in the
                           request. Required.
+                        "documentsCount": 0,  # Number of documents submitted in the request.
+                          Required.
                         "erroneousConversationsCount": 0,  # Number of invalid documents.
                           This includes empty, over-size limit or non-supported languages documents.
                           Required.
+                        "erroneousDocumentsCount": 0,  # Number of invalid documents. This
+                          includes empty, over-size limit or non-supported languages documents.
+                          Required.
                         "transactionsCount": 0,  # Number of transactions for the request.
                           Required.
-                        "validConversationsCount": 0  # Number of conversations documents.
+                        "validConversationsCount": 0,  # Number of conversations documents.
                           This excludes empty, over-size limit or non-supported languages documents.
                           Required.
-                    },
-                    "status": "str",  # Required. Known values are: "notStarted", "running",
-                      "succeeded", "partiallyCompleted", "failed", "cancelled", and "cancelling".
-                    "tasks": {
-                        "completed": 0,  # Count of tasks completed successfully. Required.
-                        "failed": 0,  # Count of tasks that failed. Required.
-                        "inProgress": 0,  # Count of tasks in progress currently. Required.
-                        "items": [
-                            analyze_conversation_job_result
-                        ],
-                        "total": 0  # Total count of tasks submitted as part of the job.
-                          Required.
+                        "validDocumentsCount": 0  # Number of valid documents. This excludes
+                          empty, over-size limit or non-supported languages documents. Required.
                     }
                 }
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = kwargs.pop("params", {}) or {}
 
         content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
```

